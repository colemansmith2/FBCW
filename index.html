<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Baseball Civil War</title>

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/png" sizes="32x32" href="league_logo.png">
    <link rel="icon" type="image/png" sizes="16x16" href="league_logo.png">

    <!-- For iOS/Safari bookmarks -->
    <link rel="apple-touch-icon" sizes="180x180" href="league_logo.png">

    <style>
        /* 1. Define the Custom Fonts */
        @font-face {
            font-family: 'Arcade Gamer';
            src: url('data/fonts/PressStart2P.ttf') format('truetype'); /* Ensure this path matches your file */
        }
        
        @font-face {
            font-family: 'Basis33';
            src: url('data/fonts/basis33.ttf') format('truetype'); /* Ensure this path matches your file */
        }
        
        /* 2. Apply Basis33 to everything by default */
        body {
            font-family: 'Basis33', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 1.1rem; /* Pixel fonts are often smaller, so we bump the size slightly */
        }
        
        /* 3. Apply Arcade Gamer to headings */
        h1, h2, h3, h4, h5, h6,
        .panel-title,           /* For "Final Standings", "Draft Results" */
        .modal-header h2,       /* For Modal Titles */
        .keeper-modal-header h2,
        .season-bet-title,      /* For Sportsbook headers */
        .card-header,           /* For Baseball Card headers */
        .draft-grade-letter     /* For Draft Grades */
        {
            font-family: 'Arcade Gamer', sans-serif;
            letter-spacing: 1px; /* Pixel title fonts often look better with slight spacing */
            text-transform: uppercase; /* Arcade fonts usually look best in all caps */
        }
        
        /* Optional: Fix for inputs/selects which sometimes don't inherit body font */
        input, select, button, textarea {
            font-family: 'Basis33', sans-serif;
        }
        
        /* ============================================
           RETRO COLOR PALETTE - Bright, flat colors
           ============================================ */
        :root {
            /* Primary Blues - Brighter, more vibrant */
            --retro-blue: #0048ba;
            --retro-blue-light: #1a5cd6;
            --retro-blue-dark: #003a99;
            
            /* Gold/Yellow - Bright and cheerful */
            --retro-gold: #ffcc00;
            --retro-gold-light: #ffe066;
            --retro-gold-dark: #e6b800;
            
            /* Accent Colors */
            --retro-red: #e63946;
            --retro-green: #2ecc71;
            --retro-orange: #ff9f1c;
            
            /* Neutral/Background */
            --retro-cream: #f5e6c8;
            --retro-gray: #6c757d;
            --retro-dark: #2c3e50;
            
            /* Status Colors */
            --status-win: #2ecc71;
            --status-loss: #e63946;
            --status-tie: #f39c12;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Basis33', sans-serif;
            background: var(--retro-blue);
            color: #333;
            min-height: 100vh;
            padding-top: 120px;
            font-size: 18px;
            /* header (70px) + nav (~50px) */
        }

        header.desktop-header {
            background: #4a5d23;
            /* Olive/brown color to match banner edges */
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
        }

        /* Mobile header - hidden on desktop */
        header.mobile-header {
            display: none;
        }

        /* Mobile menu - hidden on desktop */
        .mobile-menu,
        .mobile-menu-overlay {
            display: none;
        }

        .header-container {
            position: relative;
            display: block;
        }

        .header-banner {
            width: 100%;
            height: auto;
            display: block;
            max-height: 70px;
            object-fit: cover;
        }

        .header-league-link {
            position: absolute;
            top: 0;
            left: 0;
            width: 12%;
            /* Full width of FBCW red box area */
            height: 100%;
            cursor: pointer;
            z-index: 10;
        }

        .header-league-link:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .league-logo {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .header-content {
            flex: 1;
        }

        h1 {
            color: var(--retro-blue);
            font-size: 2.2rem;
            margin-bottom: 0.3rem;
        }

        @media (max-width: 768px) {

            /* Hide desktop header on mobile */
            header.desktop-header {
                display: none;
            }

            /* Show mobile header */
            header.mobile-header {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 200;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            }

            .mobile-header-container {
                position: relative;
                width: 100%;
            }

            .mobile-header-banner {
                width: 100%;
                height: auto;
                display: block;
            }

            /* Clickable zones positioned over the banner */
            .mobile-zone {
                position: absolute;
                top: 0;
                height: 100%;
                z-index: 10;
            }

            .mobile-zone:active {
                background: rgba(255, 255, 255, 0.15);
            }

            /* Zone positions based on new banner layout */
            /* Logo area covers the left FBCW box */
            .zone-logo {
                left: 0;
                width: 28%;
            }

            /* Menu button on the right */
            .zone-menu {
                right: 0;
                left: auto;
                width: 15%;
                cursor: pointer;
            }

            /* Mobile Slide-in Menu */
            .mobile-menu-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 299;
                opacity: 0;
                transition: opacity 0.3s ease;
            }

            .mobile-menu-overlay.active {
                display: block;
                opacity: 1;
            }

            .mobile-menu {
                display: block;
                position: fixed;
                top: 0;
                right: -280px;
                width: 280px;
                height: 100vh;
                height: 100dvh; /* Dynamic viewport height for mobile browsers */
                background: var(--retro-blue);
                z-index: 300;
                transition: right 0.3s ease;
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
                display: flex;
                flex-direction: column;
            }

            .mobile-menu.active {
                right: 0;
            }

            .mobile-menu-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 1rem 1.25rem;
                background: rgba(0, 0, 0, 0.2);
                border-bottom: 2px solid #d4af37;
                /* Sticky header - stays visible when scrolling menu items */
                flex-shrink: 0;
                position: sticky;
                top: 0;
                z-index: 10;
            }

            .mobile-menu-header span {
                font-size: 1.2rem;
                font-weight: 700;
                color: #d4af37;
                letter-spacing: 1px;
            }

            .mobile-menu-close {
                background: none;
                border: none;
                color: #fff;
                font-size: 2rem;
                cursor: pointer;
                padding: 0;
                line-height: 1;
            }

            .mobile-menu-items {
                padding: 0.5rem 0;
                /* Allow scrolling within the items container */
                overflow-y: auto;
                flex: 1;
                /* Bottom padding to ensure last item clears Safari's address bar */
                padding-bottom: 80px;
                -webkit-overflow-scrolling: touch;
            }

            .mobile-menu-item {
                display: flex;
                align-items: center;
                gap: 1rem;
                padding: 1rem 1.25rem;
                color: #fff;
                cursor: pointer;
                transition: background 0.2s;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .mobile-menu-item:hover,
            .mobile-menu-item:active {
                background: rgba(212, 175, 55, 0.2);
            }

            .mobile-menu-item.active {
                background: rgba(212, 175, 55, 0.3);
                border-left: 4px solid #d4af37;
            }

            .mobile-menu-item img {
                width: 40px;
                height: 40px;
                object-fit: contain;
                border-radius: 8px;
            }

            .mobile-menu-item span {
                font-size: 1rem;
                font-weight: 500;
            }

            /* Hide desktop nav on mobile */
            nav.top-nav {
                display: none;
            }

            body {
                padding-top: 55px;
                padding-left: 0;
            }

            /* Prevent body scroll when menu is open - iOS Safari compatible */
            body.menu-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            .header-league-link {
                width: 18%;
                /* Larger tap target on mobile */
            }

            .league-logo {
                width: 40px;
                height: 40px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .section {
                padding: 1rem;
            }
        }

        .tagline {
            color: #666;
            font-style: italic;
            font-size: 0.95rem;
        }

        /* Hide old top nav */
        nav.top-nav {
            display: none;
        }

        /* Side Navigation */
        .side-nav {
            position: fixed;
            top: 50px; /* Below header */
            left: 0;
            width: 80px;
            height: calc(100vh - 50px);
            background: var(--retro-blue-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 0;
            z-index: 150;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }
        
        .side-nav::-webkit-scrollbar {
            width: 4px;
        }
        
        .side-nav::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .side-nav::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }
        
        .side-nav::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        .side-nav-item {
            position: relative;
            width: 58px;
            height: 58px;
            margin: 0.4rem 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            border: 2px solid transparent;
            flex-shrink: 0;
        }
        
        .side-nav-item:first-child {
            margin-top: 0.5rem;
        }

        .side-nav-item:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .side-nav-item.active {
            background: #ff6b6b;
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }

        .side-nav-item img {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            object-fit: cover;
            background: rgba(255, 255, 255, 0.2);
            pointer-events: none;
        }

        .side-nav-item .nav-icon {
            width: 32px;
            height: 32px;
            fill: white;
            opacity: 0.9;
        }

        .side-nav-item:hover .nav-icon {
            opacity: 1;
        }

        /* Tooltip on hover - using fixed position to avoid overflow clipping */
        .side-nav-tooltip {
            position: fixed;
            left: 85px;
            top: auto;
            transform: translateY(-50%);
            background: var(--retro-blue);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 9999;
            pointer-events: none;
        }
        
        .side-nav-tooltip::before {
            content: '';
            position: absolute;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
            border: 6px solid transparent;
            border-right-color: var(--retro-blue);
        }

        .side-nav-item:hover .side-nav-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Adjust body and container for side nav */
        /* No body padding - nav overlays the margin area */
        body {
            padding-left: 0;
        }

        @media (max-width: 768px) {
            /* Hide side nav on mobile - use header zones instead */
            .side-nav {
                display: none;
            }
            
            body {
                padding-left: 0;
                padding-top: 55px;
            }
        }

        @media (min-width: 769px) {
            body {
                padding-top: 50px;
            }
        }

        .container {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 0 1rem;
            /* Add left margin to account for side nav, keeping content centered on screen */
            margin-left: max(calc((100% - 1200px) / 2), 90px);
        }
        
        @media (min-width: 1400px) {
            /* On wide screens, the container is naturally centered with space on both sides */
            .container {
                margin-left: auto;
                margin-right: auto;
            }
        }

        .section {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            overflow-x: hidden;
        }

        @media (max-width: 768px) {
            .section {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }

            .container {
                padding: 0 0.5rem;
                margin: 0.5rem auto;
                margin-left: auto;
            }
        }

        .section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: var(--retro-blue);
            margin-bottom: 1.5rem;
            border-bottom: 3px solid #ff6b6b;
            padding-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            h2 {
                font-size: 1.2rem;
                margin-bottom: 0.75rem;
            }

            h3 {
                font-size: 1rem;
            }

            label {
                font-size: 0.85rem;
            }

            select {
                font-size: 0.85rem;
                padding: 0.4rem;
            }
        }

        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.95rem;
        }

        .team-logo {
            width: 30px;
            height: 30px;
            object-fit: contain;
            vertical-align: middle;
            margin-right: 0.5rem;
            border-radius: 50%;
            background: white;
            padding: 0.15rem;
        }

        .manager-cell {
            display: flex;
            align-items: center;
        }

        .team-cell-content {
            display: flex;
            align-items: center;
        }

        .player-award-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-award-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            .table-wrapper {
                overflow-x: visible;
            }
        }

        @media (max-width: 768px) {
            .standings-table {
                font-size: 0.65rem;
                width: 100%;
                table-layout: fixed;
                border-collapse: collapse;
            }

            .standings-table th,
            .standings-table td {
                padding: 0.3rem 0.2rem;
                white-space: nowrap;
                overflow: hidden;
                vertical-align: middle;
            }

            .standings-table tr {
                border-bottom: 1px solid #ddd;
            }

            .standings-table td {
                border-bottom: none;
                /* Remove individual cell borders, use row border instead */
            }

            /* Column widths for mobile */
            .standings-table th:nth-child(1),
            .standings-table td:nth-child(1) {
                width: 8%;
            }

            /* Rank */

            .standings-table th:nth-child(2),
            .standings-table td:nth-child(2) {
                width: 18%;
            }

            /* Manager */

            .standings-table th:nth-child(3),
            .standings-table td:nth-child(3) {
                width: 28%;
            }

            /* Team Name */

            .standings-table th:nth-child(3) {
                width: 32%;
            }

            .standings-table td:nth-child(3) {
                width: 32%;
                white-space: normal;
                /* Allows text to wrap */
                line-height: 1.1;
                /* Tight line height */
                overflow: visible;
                padding-right: 2px;
            }

            .standings-table td:nth-child(3) .team-cell-content {
                display: flex;
                /* Enables side-by-side layout */
                align-items: center;
                /* Vertically centers logo and text */
            }

            /* Wins */

            .standings-table th:nth-child(5),
            .standings-table td:nth-child(5) {
                width: 9%;
            }

            /* Losses */

            .standings-table th:nth-child(6),
            .standings-table td:nth-child(6) {
                width: 9%;
            }

            /* Win % */

            .standings-table th:nth-child(7),
            .standings-table td:nth-child(7) {
                width: 14%;
            }

            /* Total Points */

            .standings-table .team-logo {
                width: 24px;
                /* Increased from 16px */
                height: 24px;
                /* Increased from 16px */
                min-width: 24px;
                /* Prevents squishing */
                margin-right: 4px;
                object-fit: contain;
            }
        }

        .standings-table th {
            background: var(--retro-blue);
            color: white;
            padding: 1rem;
            text-align: left;
        }

        .standings-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #ddd;
        }

        .standings-table tr:hover {
            background: #f5f5f5;
        }

        .season-selector {
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .season-selector label {
            font-weight: bold;
            margin-right: 0.5rem;
            color: var(--retro-blue);
        }

        .season-selector select {
            padding: 0.5rem;
            font-size: 1rem;
            border: 2px solid var(--retro-blue);
            border-radius: 5px;
        }
        
        /* Mario-style Week Selector */
        .header-week-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .week-label {
            font-weight: bold;
            color: var(--retro-blue);
        }
        
        .mario-week-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .week-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--retro-blue);
            background: var(--retro-gold);
            border: 3px solid #5d4037;
            border-radius: 6px;
            padding: 0.3rem 0.6rem;
            min-width: 2rem;
            text-align: center;
            box-shadow: 
                inset 0 -3px 0 rgba(0,0,0,0.2),
                inset 0 3px 0 rgba(255,255,255,0.3),
                2px 2px 4px rgba(0,0,0,0.3);
            text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .week-number:hover {
            background: var(--retro-gold-light);
            transform: scale(1.05);
        }
        
        .mario-arrow {
            background: var(--retro-gold);
            border: 2px solid #5d4037;
            border-radius: 4px;
            color: #5d4037;
            font-size: 0.6rem;
            width: 24px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 
                inset 0 -2px 0 rgba(0,0,0,0.2),
                inset 0 2px 0 rgba(255,255,255,0.3),
                1px 1px 2px rgba(0,0,0,0.2);
            line-height: 1;
            padding: 0;
        }
        
        .mario-arrow:hover {
            background: var(--retro-gold-light);
            transform: scale(1.1);
        }
        
        .mario-arrow:active {
            transform: scale(0.95);
            box-shadow: 
                inset 0 2px 0 rgba(0,0,0,0.2),
                inset 0 -2px 0 rgba(255,255,255,0.3);
        }
        
        .mario-arrow:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }
        
        .mario-up {
            margin-bottom: 2px;
        }
        
        .mario-down {
            margin-top: 2px;
        }
        
        /* Week Dropdown */
        .week-dropdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9998;
            display: none;
        }
        
        .week-dropdown-overlay.active {
            display: block;
        }
        
        .week-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 3px solid #5d4037;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            padding: 0.5rem;
            z-index: 9999;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .week-dropdown.active {
            display: block;
        }
        
        .week-dropdown-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }
        
        .week-dropdown-item {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            border: 2px solid #bdbdbd;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.85rem;
            color: #333;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .week-dropdown-item:hover {
            background: var(--retro-gold);
            border-color: #5d4037;
            transform: scale(1.1);
        }
        
        .week-dropdown-item.active {
            background: var(--retro-gold);
            border-color: #5d4037;
            color: var(--retro-blue);
        }
        
        .week-dropdown-item.unavailable {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* Clickable team cells */
        .team-cell-clickable {
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 4px;
            padding: 2px 4px;
            margin: -2px -4px;
        }
        
        .team-cell-clickable:hover {
            background: rgba(42, 82, 152, 0.1);
            transform: scale(1.02);
        }
        
        /* Schedule Modal */
        .schedule-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .schedule-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .schedule-modal {
            background: white;
            border-radius: 12px;
            max-width: 95vw;
            width: 900px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: scale(0.9) translateY(20px);
            transition: all 0.3s ease;
        }
        
        .schedule-modal-overlay.active .schedule-modal {
            transform: scale(1) translateY(0);
        }
        
        .schedule-modal-header {
            background: var(--retro-blue);
            color: white;
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .schedule-modal-header .team-logo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            background: white;
            padding: 3px;
        }
        
        .schedule-modal-title {
            flex: 1;
        }
        
        .schedule-modal-title h3 {
            margin: 0;
            font-size: 1.3rem;
        }
        
        .schedule-modal-title p {
            margin: 0.25rem 0 0;
            opacity: 0.8;
            font-size: 0.9rem;
        }
        
        .schedule-modal-close {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .schedule-modal-close:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        
        .schedule-modal-body {
            padding: 1rem;
            max-height: calc(90vh - 80px);
            overflow-y: auto;
        }
        
        /* Schedule Cards Grid */
        .schedule-cards-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.75rem;
        }
        
        /* Schedule Card */
        .schedule-card {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            transition: all 0.2s ease;
        }
        
        .schedule-card.win {
            background: #d4f5d4;
            border-color: #4caf50;
        }
        
        .schedule-card.loss {
            background: #ffd4d4;
            border-color: #f44336;
        }
        
        .schedule-card.tie {
            background: #fff3cc;
            border-color: #ff9800;
        }
        
        .schedule-card.upcoming {
            background: #fafafa;
            border-color: #9e9e9e;
        }
        
        .schedule-card.playoff-tbd {
            background: #f0f0f0;
            border-color: #9e9e9e;
            opacity: 0.7;
        }
        
        .schedule-card-header {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .schedule-card-week {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--retro-blue);
            background: rgba(30, 60, 114, 0.1);
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
        }
        
        .schedule-card.win .schedule-card-week {
            background: rgba(46, 125, 50, 0.15);
            color: #2e7d32;
        }
        
        .schedule-card.loss .schedule-card-week {
            background: rgba(198, 40, 40, 0.15);
            color: #c62828;
        }
        
        .schedule-card.playoff-tbd .schedule-card-week {
            background: rgba(0, 0, 0, 0.1);
            color: #666;
        }
        
        .schedule-card-result {
            position: absolute;
            right: 0;
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }
        
        .schedule-card-result.win {
            background: #4caf50;
            color: white;
        }
        
        .schedule-card-result.loss {
            background: #f44336;
            color: white;
        }
        
        .schedule-card-result.tie {
            background: #ff9800;
            color: white;
        }
        
        .schedule-card-opponent {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .schedule-card-opponent .team-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            padding: 2px;
            flex-shrink: 0;
        }
        
        .schedule-card-opponent-info {
            flex: 1;
            min-width: 0;
        }
        
        .schedule-card-team-name {
            font-size: 0.75rem;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .schedule-card-manager {
            font-size: 0.85rem;
            font-weight: bold;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .schedule-card-score {
            text-align: center;
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            padding: 0.25rem 0;
            border-top: 1px solid rgba(0,0,0,0.1);
            border-bottom: 1px solid rgba(0,0,0,0.1);
            margin: 0.25rem 0;
        }
        
        .schedule-card.win .schedule-card-score {
            color: #2e7d32;
        }
        
        .schedule-card.loss .schedule-card-score {
            color: #c62828;
        }
        
        .schedule-card.upcoming .schedule-card-score {
            color: #9e9e9e;
            font-size: 0.9rem;
        }
        
        .schedule-card-h2h {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }
        
        .schedule-card-h2h-label {
            color: #666;
        }
        
        .schedule-card-h2h-record {
            font-weight: bold;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }
        
        .schedule-card-h2h-record.good {
            background: #d4f5d4;
            color: #2e7d32;
        }
        
        .schedule-card-h2h-record.bad {
            background: #ffd4d4;
            color: #c62828;
        }
        
        .schedule-card-h2h-record.neutral {
            background: #fff3cc;
            color: #f57f17;
        }
        
        .schedule-card-h2h-record.no-history {
            background: #f5f5f5;
            color: #9e9e9e;
        }
        
        @media (max-width: 900px) {
            .schedule-cards-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 700px) {
            .schedule-cards-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .schedule-modal {
                width: 100%;
                max-width: 100%;
                max-height: 100vh;
                border-radius: 0;
            }
        }
        
        @media (max-width: 480px) {
            .schedule-cards-grid {
                grid-template-columns: 1fr;
            }
            
            .schedule-card {
                padding: 1rem;
            }
            
            .schedule-card-opponent .team-logo {
                width: 44px;
                height: 44px;
            }
            
            .schedule-card-manager {
                font-size: 1rem;
            }
            
            .schedule-card-score {
                font-size: 1.3rem;
            }
        }

        /* Standings and Draft side-by-side layout */
        .standings-draft-container {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            align-items: flex-start;
        }

        .standings-panel {
            flex: 1;
            min-width: 0;
        }

        .standings-panel .table-wrapper {
            margin: 0;
        }

        .draft-panel {
            flex: 0 0 440px;
            min-width: 0;
        }

        .panel-title {
            color: var(--retro-blue);
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--retro-blue);
            margin-top: 0;
        }

        .draft-table-wrapper {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 1.5rem;
        }

        .draft-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }

        .draft-table thead {
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Round separator row */
        .draft-round-separator {
            background: var(--retro-blue);
            color: white;
            font-weight: bold;
            text-align: center;
        }

        .draft-round-separator td {
            padding: 0.4rem !important;
            font-size: 0.8rem;
            border-bottom: none !important;
        }

        .draft-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.5rem 0.4rem;
            text-align: left;
            font-size: 0.75rem;
        }

        /* Column widths for draft table */
        .draft-table th:nth-child(1),
        .draft-table td:nth-child(1) {
            width: 30px;
        }

        /* Rd */
        .draft-table th:nth-child(2),
        .draft-table td:nth-child(2) {
            width: 35px;
        }

        /* Pick */
        .draft-table th:nth-child(3),
        .draft-table td:nth-child(3) {
            width: auto;
        }

        /* Player - takes remaining space */
        .draft-table th:nth-child(4),
        .draft-table td:nth-child(4) {
            width: 40px;
            text-align: center;
        }

        /* Team */
        .draft-table th:nth-child(5),
        .draft-table td:nth-child(5) {
            width: 50px;
            text-align: right;
        }

        /* Pts */
        .draft-table th:nth-child(6),
        .draft-table td:nth-child(6) {
            width: 55px;
            text-align: center;
        }

        /* Rank */

        .draft-table td {
            padding: 0.4rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .draft-table tr:hover {
            background: #f5f5f5;
        }

        .draft-player-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .draft-headshot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .draft-player-info {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .draft-player-name {
            font-weight: 500;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .keeper-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: transparent;
            border: 2px solid #d4af37;
            border-radius: 50%;
            color: #d4af37;
            font-size: 0.6rem;
            font-weight: bold;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .prospect-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: transparent;
            border: 2px solid #17a2b8;
            border-radius: 50%;
            color: #17a2b8;
            font-size: 0.6rem;
            font-weight: bold;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .prospect-free {
            color: #17a2b8 !important;
            background: transparent !important;
        }

        .is-prospect {
            background: rgba(23, 162, 184, 0.08);
        }

        /* Keeper Management Styles */
        .btn-select-keepers {
            padding: 0.5rem 1.25rem;
            background: #d4af37;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .btn-select-keepers:hover {
            background: #e0bc3f;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .keeper-modal-content {
            max-width: 1150px !important;
            width: 95vw !important;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        /* When showing auth screen, constrain the modal width */
        .keeper-modal-content.auth-view {
            max-width: 550px !important;
            width: 90vw !important;
        }

        /* Styled close button with gold circle */
        .keeper-modal-close {
            position: absolute;
            right: 1rem;
            top: 1rem;
            width: 32px;
            height: 32px;
            border: 2px solid #d4af37;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 20;
            line-height: 1;
        }

        .keeper-modal-close:hover {
            background: #d4af37;
            color: var(--retro-blue);
        }

        #keeper-modal-selection {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 0;
            min-height: 0;
        }

        /* Two column body layout */
        .keeper-selection-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            gap: 1rem;
            padding: 0 1rem;
            min-height: 0;
        }

        /* Progress Bar Container */
        .keeper-progress-container {
            width: 100%;
            max-width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 0.5rem 0;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* The Dynamic Progress Bar */
        .keeper-progress-bar {
            height: 100%;
            width: 0%;
            background: var(--retro-green);
            border-radius: 5px;
            transition: width 0.3s ease-out, background 0.3s;
        }

        .keeper-progress-bar.full {
            background: var(--retro-gold-dark);
        }

        /* Draft Picks Panel */
        .keeper-picks-section {
            width: 220px;
            flex-shrink: 0;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
        }

        .keeper-picks-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .keeper-pick-box {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #666;
            background: white;
            position: relative;
            overflow: hidden;
        }

        .keeper-pick-box.traded-away {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            opacity: 0.6;
        }

        .keeper-pick-box.traded-for {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .keeper-pick-box.used-for-keeper {
            border-color: #d4af37;
            background: #fff9e6;
        }

        .keeper-pick-box .pick-round {
            font-size: 0.7rem;
            color: #888;
        }

        .keeper-pick-box .pick-number {
            font-size: 1rem;
            font-weight: 700;
            color: var(--retro-blue);
        }

        .keeper-pick-box .keeper-headshot {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 6px;
        }

        .keeper-pick-box .keeper-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            padding: 0.25rem;
            text-align: center;
        }

        .keeper-pick-box .keeper-overlay span {
            color: white;
            font-size: 0.6rem;
            font-weight: 600;
        }

        .keeper-pick-box .traded-label {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .keeper-pick-box.prospect-pick {
            border-color: #17a2b8;
            background: #e8f7fa;
        }

        .keeper-pick-box .prospect-overlay {
            background: linear-gradient(transparent, rgba(23, 162, 184, 0.8));
        }

        .keeper-prospects-divider {
            grid-column: 1 / -1;
            text-align: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: #17a2b8;
            padding: 0.5rem 0 0.25rem;
            border-top: 1px dashed #17a2b8;
            margin-top: 0.5rem;
        }

        @media (max-width: 900px) {
            .keeper-selection-body {
                flex-direction: column;
            }

            .keeper-picks-section {
                width: 100%;
                max-height: 150px;
            }

            .keeper-picks-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        /* Header Layout */
        .keeper-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 1.25rem 1.5rem;
            padding-right: 3.5rem;
            /* Make room for close button */
            background: var(--retro-blue);
            color: white;
            flex-shrink: 0;
        }

        .keeper-header-left {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            flex: 1;
        }

        .keeper-header-logo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: white;
            object-fit: contain;
            padding: 3px;
            flex-shrink: 0;
        }

        .keeper-header-info {
            flex: 1;
        }

        .keeper-header-actions {
            position: absolute;
            right: 1rem;
            top: 3.5rem;
        }

        .keeper-header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        /* Draft Picks Header with Toggle */
        .keeper-picks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }

        .keeper-picks-header h4 {
            color: var(--retro-blue);
            font-size: 0.9rem;
            margin: 0;
            padding: 0;
            border: none;
        }

        .keeper-toggle-traded-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            background: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
            color: #495057;
            transition: all 0.2s;
        }

        .keeper-toggle-traded-btn:hover {
            background: #dee2e6;
        }

        .keeper-toggle-traded-btn.active {
            background: var(--retro-blue);
            color: white;
            border-color: var(--retro-blue);
        }

        .keeper-modal-header h2 {
            margin: 0 0 0.25rem 0;
            font-size: 1.1rem;
            color: #f5d742;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .keeper-status {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .keeper-status.full {
            color: #f5d742;
            font-weight: bold;
            opacity: 1;
        }

        .keeper-switch-btn {
            padding: 0.35rem 0.7rem;
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .keeper-switch-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            color: #fff;
        }

        .keeper-modal-auth {
            padding: 2rem;
            text-align: center;
        }

        .keeper-modal-auth h2 {
            color: var(--retro-blue);
            margin-bottom: 0.5rem;
        }

        /* Roster Section - contains the table which scrolls independently */
        .keeper-roster-section {
            flex: 1;
            overflow: hidden;
            padding: 0.5rem 0;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .keeper-roster-table-wrapper {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow-y: auto;
            overflow-x: auto;
            flex: 1;
            min-height: 0;
        }

        .keeper-roster-table-wrapper table {
            width: 100%;
            border-collapse: collapse;
        }

        .keeper-roster-table-wrapper thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .keeper-roster-table-wrapper thead th {
            background: var(--retro-blue) !important;
            color: white;
        }

        /* Fixed Footer */
        .keeper-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid #e0e0e0;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        /* Prevent body scroll when modal is open */
        body.keeper-modal-open {
            overflow: hidden;
        }

        .keeper-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid #e0e0e0;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        .keeper-selected-summary {
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            min-height: 50px;
            max-height: 80px;
            overflow: hidden;
        }

        .keeper-summary-header {
            font-weight: 600;
            color: var(--retro-blue);
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .keeper-summary-list {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.5rem;
            overflow-x: auto;
            padding-bottom: 0.25rem;
        }

        .keeper-summary-list::-webkit-scrollbar {
            height: 6px;
        }

        .keeper-summary-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .keeper-summary-list::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .keeper-summary-list::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        .keeper-selected-summary .selected-player {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.3rem 0.5rem;
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid #d4af37;
            border-radius: 20px;
            font-size: 0.8rem;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .keeper-selected-summary .selected-player .remove-keeper {
            cursor: pointer;
            color: #888;
            margin-left: 0.25rem;
        }

        .keeper-selected-summary .selected-player .remove-keeper:hover {
            color: #dc3545;
        }

        .keeper-selected-summary .no-selection {
            color: #888;
            font-style: italic;
        }

        .keeper-cost-tag {
            background: #28a745;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-tag {
            background: var(--retro-blue);
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-tag.adjusted {
            background: #6c5ce7;
            position: relative;
        }

        .keeper-round-tag.adjusted::after {
            content: '*';
            font-size: 0.6rem;
        }

        .keeper-round-tag.no-pick {
            background: #dc3545;
        }

        .selected-player.no-pick-warning {
            background: rgba(220, 53, 69, 0.15);
            border-color: #dc3545;
        }

        /* Cost columns in keeper table */
        .keeper-cost-col {
            text-align: center;
            font-size: 0.85rem;
        }

        .keeper-draft-round {
            color: #666;
        }

        .keeper-round-cost {
            color: var(--retro-blue);
            font-weight: 600;
        }

        .keeper-dollar-cost {
            color: #28a745;
            font-weight: 700;
        }
        
        .keeper-rdexp {
            color: #666;
            font-size: 0.85rem;
        }
        
        .keeper-value {
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .keeper-value.value-positive {
            color: #28a745;
        }
        
        .keeper-value.value-negative {
            color: #dc3545;
        }

        .keeper-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .keeper-cancel-btn {
            padding: 0.6rem 1.5rem;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .keeper-cancel-btn:hover {
            background: #5a6268;
        }

        .keeper-submit-btn {
            padding: 0.6rem 1.5rem;
            background: var(--retro-green);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
        }

        .keeper-submit-btn:hover {
            background: #3dd87a;
        }

        .keeper-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .keeper-auth-container {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 500px;
        }

        .keeper-auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .keeper-auth-field {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .keeper-auth-field label {
            min-width: 100px;
            font-weight: 500;
        }

        .keeper-auth-field select,
        .keeper-auth-field input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .keeper-auth-btn {
            padding: 0.5rem 1.25rem;
            background: var(--retro-blue);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .keeper-auth-btn:hover {
            background: var(--retro-blue);
        }

        .keeper-auth-error {
            color: #dc3545;
            margin-top: 0.75rem;
            font-size: 0.9rem;
        }

        .keeper-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--retro-blue);
            border-radius: 8px;
            color: white;
        }

        .keeper-header-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .keeper-team-name {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .keeper-status {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .keeper-lock-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
        }

        .keeper-lock-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .keeper-roster-section h4 {
            color: var(--retro-blue);
            margin-bottom: 0.75rem;
        }

        .keeper-table .keeper-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .keeper-table tr.is-keeper {
            background: rgba(212, 175, 55, 0.15) !important;
        }

        .keeper-table tr.not-keeper {
            opacity: 0.5;
        }

        .keeper-table .keeper-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            margin-left: 0.5rem;
            padding: 0.15rem 0.5rem;
            background: #d4af37;
            color: white;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        /* Sortable headers for keeper table */
        #keeper-roster-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        #keeper-roster-table th.sortable::after {
            content: '';
            margin-left: 4px;
            opacity: 0.5;
        }

        #keeper-roster-table th.sortable.sort-asc::after {
            content: '';
            opacity: 1;
        }

        #keeper-roster-table th.sortable.sort-desc::after {
            content: '';
            opacity: 1;
        }

        /* =========================================
           KEEPER VALUE ANALYSIS STYLES
           ========================================= */
        .keeper-value-section {
            margin-top: 3rem;
            border-top: 2px solid #e0e0e0;
            padding-top: 2rem;
        }

        .keeper-value-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .keeper-value-header h3 {
            color: var(--retro-blue);
            margin: 0;
        }

        /* Expected Points Chart Container */
        .expected-points-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.25rem;
            margin-bottom: 2rem;
        }

        .expected-points-chart-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .expected-points-chart-wrapper h4 {
            margin: 0 0 0.75rem 0;
            color: var(--retro-blue);
            font-size: 0.95rem;
        }

        .expected-points-chart {
            height: 200px;
            position: relative;
        }

        /* League Rankings Table */
        .value-rankings-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }
        
        .value-rankings-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .value-rankings-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.5rem 0.6rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .value-rankings-table th:first-child {
            border-radius: 6px 0 0 0;
        }

        .value-rankings-table th:last-child {
            border-radius: 0 6px 0 0;
            text-align: left;
        }
        
        .value-rankings-table td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
            white-space: nowrap;
        }

        .value-rankings-table tr:hover {
            background: #f8f9fa;
        }

        .value-rankings-table .rank-cell {
            font-weight: 700;
            color: var(--retro-blue);
            text-align: center;
        }

        .value-rankings-table .team-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .value-rankings-table .team-logo-small {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: contain;
            flex-shrink: 0;
        }

        .value-rankings-table .value-cell {
            text-align: center;
            font-weight: 700;
        }
        
        /* Best player cell in rankings */
        .best-player-cell {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            padding: 0.15rem 0;
            min-width: 140px;
        }
        
        .best-player-cell .player-headshot-mini {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        
        .best-player-cell .player-info {
            display: flex;
            flex-direction: column;
            line-height: 1.1;
            min-width: 0;
            flex: 1;
        }
        
        .best-player-cell .player-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 75px;
            font-size: 0.65rem;
        }
        
        .best-player-cell .player-details {
            color: #666;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            gap: 0.2rem;
        }
        
        .best-player-cell .player-details .pos-badge {
            font-size: 0.5rem;
            padding: 0.05rem 0.2rem;
        }
        
        .best-player-cell .player-value {
            font-weight: 600;
            font-size: 0.65rem;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .top-players-cell {
            display: inline-flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        /* Draft pick circles in rankings */
        .top-picks-cell {
            display: inline-flex;
            gap: 0.4rem;
            align-items: center;
        }
        
        .pick-value-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.1rem;
        }
        
        .pick-circle {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #4a148c;
            border: 2px solid #d4af37;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #d4af37;
            font-weight: 700;
            font-size: 0.75rem;
        }
        
        .pick-expected {
            font-size: 0.6rem;
            color: #666;
            font-weight: 500;
        }

        .value-rankings-wrapper h4 {
            margin: 0 0 1rem 0;
            color: var(--retro-blue);
            font-size: 1rem;
        }
        
        /* Sortable headers */
        .value-rankings-table .sortable-header {
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        
        .value-rankings-table .sortable-header:hover {
            background: var(--retro-blue-light);
        }
        
        .value-rankings-table .sortable-header .sort-icon {
            font-size: 0.7rem;
            margin-left: 0.25rem;
            opacity: 0.5;
        }
        
        .value-rankings-table .sortable-header.active .sort-icon {
            opacity: 1;
        }

        .value-positive {
            color: #28a745;
        }

        .value-negative {
            color: #dc3545;
        }

        .value-neutral {
            color: #6c757d;
        }

        /* Team Value Cards Grid */
        .team-value-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 1.25rem;
            margin-bottom: 2rem;
        }

        .team-value-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .team-value-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--retro-blue);
            color: white;
        }

        .team-value-card-header .team-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .team-value-card-header .team-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            object-fit: contain;
            padding: 2px;
        }

        .team-value-card-header .team-name {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .team-value-card-header .team-manager {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .team-value-card-header .total-value {
            font-size: 1.1rem;
            font-weight: 700;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
        }

        .team-value-card-header .total-value.positive {
            background: rgba(40, 167, 69, 0.3);
        }

        .team-value-card-header .total-value.negative {
            background: rgba(220, 53, 69, 0.3);
        }

        .team-value-card-body {
            padding: 0;
        }

        .team-value-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .team-value-table th {
            background: #f8f9fa;
            padding: 0.5rem 0.6rem;
            text-align: left;
            font-weight: 600;
            color: #666;
            border-bottom: 1px solid #e0e0e0;
        }

        .team-value-table th:nth-child(3),
        .team-value-table th:nth-child(4),
        .team-value-table th:nth-child(5) {
            text-align: right;
        }

        .team-value-table td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid #eee;
        }

        .team-value-table td:nth-child(3),
        .team-value-table td:nth-child(4),
        .team-value-table td:nth-child(5) {
            text-align: right;
        }

        .team-value-table tr:last-child td {
            border-bottom: none;
        }

        .team-value-table .player-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .team-value-table .player-headshot-tiny {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
        }

        .team-value-card-footer {
            padding: 0.6rem 1rem;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
        }

        .team-value-card-footer .label {
            color: #666;
        }

        .team-value-card-footer .value {
            font-weight: 600;
        }

        /* Prospects Section */
        .prospects-value-section {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(23, 162, 184, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }

        .prospects-value-section h4 {
            color: #17a2b8;
            margin: 0 0 1rem 0;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .prospects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .prospect-value-item {
            background: white;
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .prospect-value-item .prospect-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .prospect-value-item .prospect-team-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .prospect-value-item .prospect-pts {
            font-weight: 600;
            color: #17a2b8;
        }

        /* Scatter Plot Container */
        .value-scatter-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-top: 1.5rem;
        }

        .value-scatter-wrapper h4 {
            margin: 0 0 1rem 0;
            color: var(--retro-blue);
            font-size: 1rem;
        }

        .value-scatter-chart {
            height: 350px;
            position: relative;
        }

        /* Loading state */
        .keeper-value-loading {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        /* League Keepers Grid */
        .keeper-league-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .keeper-team-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .keeper-team-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--retro-blue);
            color: white;
        }

        .keeper-team-card-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            object-fit: contain;
            padding: 2px;
        }

        .keeper-team-card-info h5 {
            margin: 0;
            font-size: 0.95rem;
        }

        .keeper-team-card-info span {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .keeper-team-card-body {
            padding: 0.75rem 1rem;
        }

        .keeper-team-card-body .no-keepers {
            color: #888;
            font-style: italic;
            font-size: 0.85rem;
        }

        .keeper-by-tag {
            font-size: 0.7rem;
            color: #d4af37;
            font-weight: 600;
            margin-top: 2px;
        }

        /* Keeper row styling in projections table */
        #proj-table tr.is-keeper {
            background: rgba(212, 175, 55, 0.12) !important;
        }

        #proj-table tr.is-keeper:hover {
            background: rgba(212, 175, 55, 0.2) !important;
        }

        .keeper-player-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .keeper-player-row:last-child {
            border-bottom: none;
        }

        .keeper-player-row .keeper-badge {
            margin-left: 0;
            margin-right: 0.25rem;
        }

        .keeper-player-row .player-name {
            flex: 1;
            font-weight: 500;
        }

        .keeper-player-row .player-pos {
            color: #666;
            font-size: 0.85rem;
        }

        .keeper-player-row .player-pts {
            font-weight: 600;
            color: var(--retro-blue);
            min-width: 32px;
            text-align: right;
        }

        .keeper-cost-small {
            background: #28a745;
            color: white;
            padding: 0.1rem 0.35rem;
            border-radius: 2px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-small {
            background: var(--retro-blue);
            color: white;
            padding: 0.1rem 0.35rem;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-small.no-pick {
            background: #dc3545;
        }

        .keeper-player-row.no-pick-warning {
            background: rgba(220, 53, 69, 0.15);
        }

        .keeper-budget-used {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.15rem 0.4rem;
            border-radius: 8px;
            font-size: 0.75rem;
            margin-left: 0.5rem;
        }

        /* League Keeper Budget Bar */
        .league-budget-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        .league-budget-bar-wrapper {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .league-budget-bar {
            height: 100%;
            background: var(--retro-green);
            border-radius: 4px;
            transition: width 0.3s ease-out, background 0.3s;
        }

        .league-budget-bar.full {
            background: var(--retro-gold-dark);
        }

        .league-budget-bar.over {
            background: var(--retro-red);
        }

        .league-budget-text {
            font-size: 0.7rem;
            opacity: 0.9;
            white-space: nowrap;
        }

        .prospect-count {
            color: #17a2b8;
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* ===== TRADE MANAGEMENT STYLES ===== */
        .btn-new-trade {
            padding: 0.5rem 1rem;
            background: var(--retro-blue);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-new-trade:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 60, 114, 0.3);
        }

        .btn-export-trades {
            padding: 0.5rem 1rem;
            background: var(--retro-gray);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-export-trades:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        .btn-toggle-prospects {
            padding: 0.4rem 0.8rem;
            background: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-toggle-prospects:hover {
            background: #dee2e6;
        }

        .btn-toggle-prospects.active {
            background: #17a2b8;
            color: white;
            border-color: #17a2b8;
        }

        .btn-adjust-budgets {
            padding: 0.4rem 0.8rem;
            background: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-adjust-budgets:hover {
            background: #ffc107;
            color: #212529;
            border-color: #ffc107;
        }

        .budget-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .budget-row:last-child {
            border-bottom: none;
        }

        .budget-row .team-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: contain;
            background: #f0f0f0;
            padding: 2px;
        }

        .budget-row .team-info {
            flex: 1;
        }

        .budget-row .team-name {
            font-weight: 600;
            color: var(--retro-blue);
        }

        .budget-row .manager-name {
            font-size: 0.85rem;
            color: #666;
        }

        .budget-row .budget-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .budget-row .budget-input {
            width: 70px;
            padding: 0.4rem 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .budget-row .budget-diff {
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 50px;
        }

        .budget-row .budget-diff.positive {
            color: #28a745;
        }

        .budget-row .budget-diff.negative {
            color: #dc3545;
        }

        /* Firebase connection status */
        .firebase-status {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .firebase-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .firebase-status.connected {
            background: rgba(40, 167, 69, 0.15);
            color: #28a745;
        }

        .firebase-status.connected .status-dot {
            background: #28a745;
            box-shadow: 0 0 6px #28a745;
        }

        .firebase-status.disconnected {
            background: rgba(108, 117, 125, 0.15);
            color: #6c757d;
        }

        .firebase-status.disconnected .status-dot {
            background: #6c757d;
        }

        /* Scrollable trades list */
        .trades-list-scrollable {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f9fa;
            padding: 1rem;
        }

        .trades-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Scrollable projections table with fixed header */
        .proj-table-scrollable {
            max-height: 700px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            position: relative;
        }

        .proj-table-scrollable table {
            width: 100%;
            border-collapse: collapse;
        }

        .proj-table-scrollable thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: var(--retro-blue);
        }

        .proj-table-scrollable thead th {
            background: transparent;
            color: white;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            text-align: left;
            border-bottom: 2px solid var(--retro-blue);
        }

        .proj-table-scrollable tbody tr {
            border-bottom: 1px solid #eee;
        }

        .proj-table-scrollable tbody tr:hover {
            background: #f0f4ff;
        }

        .no-trades {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 2rem;
        }

        .trade-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .trade-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .trade-card-date {
            font-size: 0.85rem;
            color: #666;
        }

        .trade-card-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .trade-card-actions button:hover {
            opacity: 1;
        }

        .trade-card-body {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .trade-card-side {
            flex: 1;
            padding: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .trade-card-team {
            font-weight: 600;
            color: var(--retro-blue);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .trade-card-team img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        .trade-card-assets {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .trade-asset-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin: 0.1rem;
        }

        .trade-asset-tag.player {
            background: #e3f2fd;
            color: #1565c0;
        }

        .trade-asset-tag.pick {
            background: #fff3e0;
            color: #e65100;
        }

        .trade-asset-tag.money {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .trade-card-arrow {
            font-size: 1.5rem;
            color: var(--retro-blue);
        }

        .trade-card-notes {
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
        }

        /* Trade Modal Styles */
        .trade-modal-content {
            max-width: 900px;
            width: 95vw;
        }

        .trade-modal-header {
            background: var(--retro-blue);
            color: white;
            padding: 1.25rem 1.5rem;
            margin: -0px;
            border-radius: 15px 15px 0 0;
        }

        .trade-modal-header h2 {
            margin: 0 0 0.25rem 0;
            color: #f5d742;
        }

        .trade-modal-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .trade-builder {
            display: flex;
            gap: 1rem;
            padding: 1.5rem;
            align-items: flex-start;
        }

        .trade-side {
            flex: 1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1rem;
            min-height: 300px;
        }

        .trade-team-selector {
            margin-bottom: 1rem;
        }

        .trade-team-selector label {
            display: block;
            font-weight: 600;
            color: var(--retro-blue);
            margin-bottom: 0.5rem;
        }

        .trade-team-selector select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
        }

        .trade-team-info {
            background: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }

        .trade-budget-display {
            font-size: 0.9rem;
            color: #28a745;
            font-weight: 600;
        }

        .trade-assets {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
            min-height: 100px;
        }

        .trade-asset-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .trade-asset-item .asset-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .trade-asset-item .asset-type-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .trade-asset-item .asset-type-icon.player {
            background: #e3f2fd;
            color: #1565c0;
        }

        .trade-asset-item .asset-type-icon.pick {
            background: #fff3e0;
            color: #e65100;
        }

        .trade-asset-item .asset-type-icon.money {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .trade-asset-item .remove-asset {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            opacity: 0.6;
        }

        .trade-asset-item .remove-asset:hover {
            opacity: 1;
        }

        .trade-add-asset select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        }

        .trade-asset-selector {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .trade-asset-selector select,
        .trade-asset-selector input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        .trade-asset-selector input[type="number"] {
            width: 80px;
            flex: none;
        }

        .trade-asset-selector button {
            padding: 0.5rem 0.75rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .trade-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--retro-blue);
            padding: 0 0.5rem;
        }

        .trade-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid #e0e0e0;
            background: #f8f9fa;
        }

        .trade-notes {
            margin-bottom: 1rem;
        }

        .trade-notes label {
            display: block;
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .trade-notes input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        .trade-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            .trade-builder {
                flex-direction: column;
            }

            .trade-arrow {
                transform: rotate(90deg);
                padding: 0.5rem 0;
            }

            .trade-card-body {
                flex-direction: column;
            }

            .trade-card-arrow {
                transform: rotate(90deg);
            }
        }

        @media (max-width: 600px) {
            .keeper-auth-field {
                flex-direction: column;
                align-items: flex-start;
            }

            .keeper-auth-field label {
                min-width: auto;
            }

            .keeper-auth-field select,
            .keeper-auth-field input {
                width: 100%;
            }

            .keeper-header {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }

            .keeper-league-grid {
                grid-template-columns: 1fr;
            }
        }

        .draft-team-cell {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            position: relative;
        }

        .draft-team-logo {
            width: 24px;
            height: 24px;
            object-fit: contain;
            border-radius: 50%;
            background: white;
            padding: 2px;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .draft-team-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 4px;
        }

        .draft-team-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.85);
        }

        .draft-team-cell:hover .draft-team-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .draft-pts {
            font-weight: 600;
            color: var(--retro-blue);
        }

        .draft-rank {
            font-size: 0.75rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            text-align: center;
        }

        .draft-rank.top-10 {
            background: #c6efce;
            color: #006400;
        }

        .draft-rank.top-25 {
            background: #ffeb9c;
            color: #9c5700;
        }

        .draft-rank.top-50 {
            background: #ffc7ce;
            color: #9c0006;
        }

        .draft-empty {
            padding: 2rem;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        @media (max-width: 1024px) {
            .standings-draft-container {
                flex-direction: column;
            }

            .draft-panel {
                flex: 1;
            }

            .draft-table-wrapper {
                max-height: 400px;
            }
        }

        @media (max-width: 768px) {
            .standings-draft-container {
                flex-direction: column;
                gap: 1rem;
            }

            .draft-panel {
                flex: 1;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            .draft-table-wrapper {
                max-height: 350px;
                max-width: 100%;
                overflow-x: auto;
            }

            .draft-table {
                font-size: 0.75rem;
                min-width: 300px;
            }

            .draft-table th,
            .draft-table td {
                padding: 0.3rem 0.25rem;
            }

            .draft-headshot {
                width: 24px;
                height: 24px;
            }

            .draft-player-name {
                font-size: 0.7rem;
            }

            .draft-player-pos {
                font-size: 0.6rem;
            }

            .draft-team-logo {
                width: 16px;
                height: 16px;
            }
            
            /* Draft Grades Ticker mobile fix */
            #draft-performance-ticker {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow: hidden;
            }
            
            .draft-performance-grid {
                width: 100%;
                max-width: 100%;
            }
            
            .draft-ticker-wrapper {
                width: 100%;
                max-width: 100%;
            }
            
            .draft-ticker-viewport {
                width: calc(100% - 58px);
                max-width: calc(100% - 58px);
            }
            
            .draft-ticker-card {
                flex: 0 0 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
        }

        .manager-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        @media (max-width: 768px) {
            .manager-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        .manager-card {
            background: #0048ba;
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            cursor: pointer;
        }

        .manager-card:hover {
            transform: translateY(-5px);
        }

        .manager-card.inactive {
            background: #6c757d;
            opacity: 0.8;
        }

        .manager-card h3 {
            margin-bottom: 1rem;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .manager-card .manager-logo-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .manager-card .manager-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
            background: white;
            border-radius: 50%;
            padding: 0.25rem;
        }
        
        .manager-card .manager-ring-badge {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            object-fit: contain;
        }

        .manager-card .stat {
            margin: 0.5rem 0;
            font-size: 0.95rem;
        }

        .manager-card .stat strong {
            display: inline-block;
            width: 140px;
        }

        .manager-card .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.3);
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.85rem;
        }

        .manager-card .awards-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .manager-card .award-badge {
            position: relative;
            font-size: 1.6rem;
            line-height: 1;
            display: inline-block;
        }

        .manager-card .award-count {
            position: absolute;
            bottom: -2px;
            right: -4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.55rem;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
            min-width: 14px;
            text-align: center;
        }

        /* Global award badge styles (for modal and other uses) */
        .awards-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .award-badge {
            position: relative;
            font-size: 1.6rem;
            line-height: 1;
            display: inline-block;
            cursor: pointer;
        }

        .award-badge[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 5px;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .award-badge[data-tooltip]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
        }

        .award-image {
            width: 28px;
            height: 28px;
            object-fit: contain;
            vertical-align: middle;
        }

        .award-count {
            position: absolute;
            bottom: -2px;
            right: -4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.55rem;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
            min-width: 14px;
            text-align: center;
        }

        /* Manager Detail Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 0;
            border-radius: 15px;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid var(--retro-blue);
            border-radius: 15px 15px 0 0;
        }

        .modal-body-scroll {
            overflow-y: auto;
            padding: 2rem;
            flex: 1;
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .modal-header {
                padding: 1.5rem;
                padding-bottom: 1rem;
            }

            .modal-body-scroll {
                padding: 1.5rem;
            }
        }

        .modal-close {
            position: absolute;
            right: 1.5rem;
            top: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
            transition: color 0.3s;
            z-index: 11;
        }

        .modal-close:hover {
            color: #000;
        }

        .modal-header {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid var(--retro-blue);
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            color: var(--retro-blue);
            margin-bottom: 0.5rem;
            border: none;
            padding: 0;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 768px) {
            .modal-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }

            .stat-box {
                padding: 0.75rem;
            }

            .stat-box .value {
                font-size: 1.4rem;
            }

            .stat-box .label {
                font-size: 0.8rem;
            }
        }

        .stat-box {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--retro-blue);
        }

        .stat-box .label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .timeline {
            margin: 2rem 0;
        }

        .timeline h3 {
            color: var(--retro-blue);
            margin-bottom: 1rem;
        }

        .timeline-item {
            display: flex;
            padding: 1rem;
            border-left: 3px solid var(--retro-blue);
            margin-bottom: 1rem;
            background: #f8f9fa;
            border-radius: 0 8px 8px 0;
            align-items: center;
        }

        .timeline-item .year {
            font-weight: bold;
            color: var(--retro-blue);
            min-width: 60px;
            font-size: 1.1rem;
        }

        .timeline-item .details {
            flex: 1;
            margin-left: 1rem;
        }

        .timeline-item .timeline-logo {
            width: 35px;
            height: 35px;
            object-fit: contain;
            border-radius: 50%;
            background: white;
            padding: 0.25rem;
            margin-left: 1rem;
        }

        .timeline-item .rank {
            display: inline-block;
            background: var(--retro-blue);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            margin-right: 1rem;
            font-size: 0.9rem;
        }

        .timeline-item .rank.champion {
            background: #ffd700;
            color: #000;
        }

        .timeline-item .rank.runner-up {
            background: #c0c0c0;
            color: #000;
        }
        
        /* Draft Grade Styles */
        .draft-grade-section {
            margin: 1rem 0;
            display: flex;
            justify-content: center;
        }
        
        .draft-grade-overall {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 2rem;
            border-radius: 12px;
            border: 2px solid;
            min-width: 150px;
        }
        
        .draft-grade-letter {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
        }
        
        .draft-grade-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.25rem;
        }
        
        .draft-grade-score {
            font-size: 0.8rem;
            font-weight: 500;
            margin-top: 0.25rem;
        }
        
        .draft-grade-badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        /* Draft Performance Ticker */
        .draft-performance-grid {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
        
        .draft-ticker-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            max-width: 100%;
        }
        
        .draft-ticker-viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-width: 0;
        }
        
        .draft-ticker-track {
            display: flex;
            gap: 0.75rem;
            transition: transform 0.5s ease;
        }
        
        .draft-ticker-card {
            flex: 0 0 100%;
            background: white;
            border-radius: 8px;
            padding: 0.75rem;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-left: 4px solid;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
        }
        
        .draft-ticker-card:hover {
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }
        
        .ticker-nav-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: none;
            background: var(--retro-blue);
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        
        .ticker-nav-btn:hover {
            background: var(--retro-blue);
        }
        
        .ticker-dots {
            display: flex;
            justify-content: center;
            gap: 0.35rem;
            margin-top: 0.5rem;
        }
        
        .ticker-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }
        
        .ticker-dot:hover {
            background: #999;
        }
        
        .ticker-dot.active {
            background: var(--retro-blue);
            transform: scale(1.2);
        }
        
        .draft-perf-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .draft-perf-logo {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: contain;
        }
        
        .draft-perf-logo-placeholder {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e0e0e0;
        }
        
        .draft-perf-team-info {
            flex: 1;
            min-width: 0;
        }
        
        .draft-perf-team-name {
            font-weight: 600;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .draft-perf-manager {
            font-size: 0.7rem;
            color: #666;
        }
        
        .draft-perf-grade {
            font-size: 1.25rem;
            font-weight: 700;
            padding: 0.2rem 0.4rem;
            border-radius: 5px;
            min-width: 38px;
            text-align: center;
        }
        
        .draft-perf-stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.25rem;
            font-size: 0.75rem;
            padding-top: 0.4rem;
            border-top: 1px solid #eee;
        }
        
        .draft-perf-stat {
            text-align: center;
        }
        
        .draft-perf-stat-value {
            font-weight: 600;
            font-size: 0.85rem;
        }
        
        .draft-perf-stat-label {
            color: #888;
            font-size: 0.65rem;
        }
        
        .draft-perf-diff-positive {
            color: #28a745;
        }
        
        .draft-perf-diff-negative {
            color: #dc3545;
        }
        
        /* Matchups Ticker Styles */
        .matchups-ticker-grid {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }
        
        .matchups-ticker-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
            max-width: 100%;
        }
        
        .matchups-ticker-viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-width: 0;
        }
        
        .matchups-ticker-track {
            display: flex;
            gap: 0.75rem;
            transition: transform 0.5s ease;
        }
        
        .matchup-ticker-card {
            flex: 0 0 100%;
            background: white;
            border-radius: 8px;
            padding: 0.75rem;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-sizing: border-box;
        }
        
        .matchup-teams {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }
        
        .matchup-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            min-width: 0;
        }
        
        .matchup-team.winner .matchup-score {
            color: #28a745;
        }
        
        .matchup-team.loser .matchup-score {
            color: #dc3545;
        }
        
        .matchup-team-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: contain;
            margin-bottom: 0.15rem;
        }
        
        .matchup-team-hat {
            width: 22px;
            height: 22px;
            object-fit: contain;
            margin-bottom: 0.15rem;
        }
        
        .matchup-team-name {
            font-size: 0.7rem;
            font-weight: 600;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        .matchup-manager {
            font-size: 0.65rem;
            color: #666;
        }
        
        .matchup-record {
            font-size: 0.6rem;
            color: #888;
        }
        
        .matchup-score {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .matchup-vs {
            font-size: 0.8rem;
            font-weight: 600;
            color: #999;
            padding: 0 0.25rem;
        }
        
        .matchup-ticker-nav-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: none;
            background: var(--retro-blue);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        
        .matchup-ticker-nav-btn:hover {
            background: var(--retro-blue);
        }
        
        .matchup-ticker-dots {
            display: flex;
            justify-content: center;
            gap: 0.3rem;
            margin-top: 0.4rem;
        }
        
        .matchup-ticker-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #ccc;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }
        
        .matchup-ticker-dot:hover {
            background: #999;
        }
        
        .matchup-ticker-dot.active {
            background: var(--retro-blue);
            transform: scale(1.2);
        }
        
        @media (max-width: 768px) {
            .matchup-team-logo {
                width: 28px;
                height: 28px;
            }
            
            .matchup-team-name {
                font-size: 0.65rem;
            }
            
            .matchup-score {
                font-size: 0.95rem;
            }
            
            .matchup-ticker-nav-btn {
                width: 20px;
                height: 20px;
                font-size: 0.85rem;
            }
        }
        
        /* Mobile optimization for draft ticker */
        @media (max-width: 768px) {
            #draft-performance-ticker {
                margin-top: 1rem;
            }
            
            .draft-ticker-wrapper {
                gap: 0.25rem;
            }
            
            .ticker-nav-btn {
                width: 24px;
                height: 24px;
                font-size: 1rem;
                min-width: 24px;
            }
            
            .draft-ticker-card {
                padding: 0.6rem;
                gap: 0.4rem;
            }
            
            .draft-perf-logo {
                width: 28px;
                height: 28px;
            }
            
            .draft-perf-logo-placeholder {
                width: 28px;
                height: 28px;
            }
            
            .draft-perf-header {
                gap: 0.4rem;
            }
            
            .draft-perf-team-name {
                font-size: 0.75rem;
            }
            
            .draft-perf-manager {
                font-size: 0.65rem;
            }
            
            .draft-perf-grade {
                font-size: 1.1rem;
                padding: 0.15rem 0.35rem;
                min-width: 34px;
            }
            
            .draft-perf-stats {
                gap: 0.2rem;
                padding-top: 0.35rem;
            }
            
            .draft-perf-stat-value {
                font-size: 0.8rem;
            }
            
            .draft-perf-stat-label {
                font-size: 0.6rem;
            }
            
            .ticker-dots {
                gap: 0.25rem;
                margin-top: 0.4rem;
            }
            
            .ticker-dot {
                width: 6px;
                height: 6px;
            }
        }

        /* ===== PLAYOFF BRACKET STYLES ===== */
        .playoff-bracket {
            padding: 1.5rem 2rem;
            background: #f8f9fa;
            border-radius: 12px;
            overflow-x: auto;
        }

        .bracket-wrapper {
            position: relative;
            min-width: 800px;
            min-height: 400px;
        }

        .bracket-lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .bracket-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            padding-top: 10px;
            min-height: 450px;
        }

        .bracket-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 170px;
        }

        .bracket-column.qf-column {
            /* Offset QF matchups down so their midpoints align with SF bottom teams */
            padding-top: 35px;
        }

        .bracket-column.sf-column {
            /* SF column starts at top */
        }

        .bracket-column.finals-column {
            /* Center finals between SF1 and SF2 - calculated to be roughly in the middle */
            justify-content: center;
            min-height: 100%;
        }

        .bracket-connector-space {
            width: 110px;
            flex-shrink: 0;
        }

        .bracket-round-label {
            text-align: center;
            font-weight: bold;
            color: var(--retro-blue);
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .bracket-matchup {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bracket-spacer {
            height: 60px;
        }

        .bracket-team {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: white;
            border-radius: 8px;
            border: 2px solid var(--retro-blue);
            min-width: 150px;
            height: 66px;
            box-sizing: border-box;
        }

        .bracket-team.winner {
            border-color: var(--retro-blue);
            background: white;
            box-shadow: 0 2px 8px rgba(30, 60, 114, 0.2);
        }

        .bracket-team.champion-path {
            border-color: #d4af37;
            background: #fff9e6;
            box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
        }

        .bracket-team.loser {
            opacity: 0.6;
            border-color: #ccc;
        }

        .bracket-team.champion {
            border-color: #d4af37;
            border-width: 3px;
            background: #fff9e6;
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
        }

        .bracket-hat {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .bracket-team.loser .bracket-hat {
            filter: grayscale(100%);
        }

        .bracket-team-info {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 0;
        }

        .bracket-manager {
            font-weight: bold;
            font-size: 0.85rem;
            color: var(--retro-blue);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .bracket-score {
            font-size: 0.9rem;
            font-weight: bold;
            color: #333;
        }

        .bracket-team.loser .bracket-score {
            color: #999;
        }

        .bracket-team.winner .bracket-score {
            color: var(--retro-blue);
        }

        /* Champion badge */
        .champion-badge {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .champion-badge img {
            width: 20px;
            height: 20px;
        }

        .champion-badge span {
            font-size: 0.7rem;
            font-weight: bold;
            color: #d4af37;
            text-transform: uppercase;
        }

        /* Mobile adjustments for bracket */
        @media (max-width: 900px) {
            .playoff-bracket {
                padding: 0.75rem;
            }
            
            .bracket-wrapper {
                min-width: 700px;
            }

            .bracket-column {
                width: 140px;
            }

            .bracket-connector-space {
                width: 70px;
            }

            .bracket-team {
                min-width: 120px;
                padding: 0.4rem 0.5rem;
                height: 56px;
            }

            .bracket-hat {
                width: 40px;
                height: 40px;
            }

            .bracket-manager {
                font-size: 0.75rem;
            }

            .bracket-score {
                font-size: 0.8rem;
            }
        }

        /* ===== IN-SEASON TOOLS STYLES ===== */
        .inseason-section {
            background: white;
            border-radius: 10px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .top-performers-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        
        @media (max-width: 768px) {
            .top-performers-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .performers-column h4 {
            color: var(--retro-blue);
            margin: 0 0 0.75rem 0;
            font-size: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .performers-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .performer-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid var(--retro-blue);
        }
        
        .performer-rank {
            font-weight: 700;
            font-size: 1rem;
            color: var(--retro-blue);
            min-width: 24px;
        }
        
        .performer-headshot {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .performer-info {
            flex: 1;
            min-width: 0;
        }
        
        .performer-name {
            font-weight: 600;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .performer-team {
            font-size: 0.7rem;
            color: #666;
        }
        
        .performer-points {
            font-weight: 700;
            font-size: 1rem;
            color: #28a745;
        }
        
        .category-leaders-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 1rem;
        }
        
        .category-leader-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        
        .category-name {
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        
        .category-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--retro-blue);
        }
        
        .category-leader-name {
            font-size: 0.8rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .category-leader-team {
            font-size: 0.65rem;
            color: #888;
        }
        
        /* Stats Heatmap Table */
        .stats-table-wrapper {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        .stats-heatmap-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
            min-width: 800px;
        }
        
        .stats-heatmap-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.6rem 0.4rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.75rem;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .stats-heatmap-table th:first-child,
        .stats-heatmap-table th:nth-child(2) {
            text-align: left;
            position: sticky;
            left: 0;
            z-index: 2;
        }
        
        .stats-heatmap-table td {
            padding: 0.5rem 0.4rem;
            text-align: center;
            border-bottom: 1px solid #eee;
        }
        
        .stats-heatmap-table td:first-child {
            text-align: center;
            font-weight: 700;
            color: var(--retro-blue);
        }
        
        .stats-heatmap-table td:nth-child(2) {
            text-align: left;
            white-space: nowrap;
        }
        
        .stats-heatmap-table tbody tr:hover {
            background: rgba(42, 82, 152, 0.05);
        }
        
        .stats-team-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .stats-team-logo {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }
        
        .stats-team-name {
            font-weight: 500;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        
        /* Heatmap colors */
        .heat-1 { background-color: #1a9641; color: white; }
        .heat-2 { background-color: #52b947; color: white; }
        .heat-3 { background-color: #8dd35f; }
        .heat-4 { background-color: #c4e687; }
        .heat-5 { background-color: #e6f5a3; }
        .heat-6 { background-color: #ffffbf; }
        .heat-7 { background-color: #fee99d; }
        .heat-8 { background-color: #fdca7d; }
        .heat-9 { background-color: #f99d59; }
        .heat-10 { background-color: #e85b3a; color: white; }
        .heat-11 { background-color: #d62f27; color: white; }
        .heat-12 { background-color: #a50026; color: white; }
        
        /* Inverse heatmap for stats where lower is better (ERA, L, ER, etc) */
        .heat-inv-1 { background-color: #a50026; color: white; }
        .heat-inv-2 { background-color: #d62f27; color: white; }
        .heat-inv-3 { background-color: #e85b3a; color: white; }
        .heat-inv-4 { background-color: #f99d59; }
        .heat-inv-5 { background-color: #fdca7d; }
        .heat-inv-6 { background-color: #fee99d; }
        .heat-inv-7 { background-color: #ffffbf; }
        .heat-inv-8 { background-color: #e6f5a3; }
        .heat-inv-9 { background-color: #c4e687; }
        .heat-inv-10 { background-color: #8dd35f; }
        .heat-inv-11 { background-color: #52b947; color: white; }
        .heat-inv-12 { background-color: #1a9641; color: white; }
        
        .week-selector {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            justify-content: center;
        }
        
        .week-selector label {
            font-weight: 600;
            color: var(--retro-blue);
        }
        
        .week-selector select {
            padding: 0.5rem 1rem;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }
        
        .week-circles-container {
            display: flex;
            justify-content: center;
            padding: 0.5rem 0;
        }
        
        .week-circles {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
        }
        
        .week-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid var(--retro-blue);
            background: white;
            color: var(--retro-blue);
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .week-circle:hover {
            background: #e8eef7;
        }
        
        .week-circle.active {
            background: var(--retro-blue);
            color: white;
        }
        
        .week-circle.cumulative {
            width: auto;
            padding: 0 12px;
            border-radius: 16px;
            font-size: 0.7rem;
        }
        
        @media (max-width: 768px) {
            .week-circle {
                width: 28px;
                height: 28px;
                font-size: 0.7rem;
            }
            
            .week-circle.cumulative {
                padding: 0 8px;
                font-size: 0.6rem;
            }
        }
        
        .no-data {
            text-align: center;
            padding: 2rem;
            color: #888;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .stats-heatmap-table {
                font-size: 0.7rem;
                min-width: 600px;
            }
            
            .stats-heatmap-table th,
            .stats-heatmap-table td {
                padding: 0.4rem 0.25rem;
            }
            
            .stats-team-name {
                max-width: 100px;
            }
            
            .category-leaders-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
                gap: 0.5rem;
            }
            
            .category-leader-card {
                padding: 0.5rem;
            }
            
            .category-value {
                font-size: 1.2rem;
            }
        }

        .matchup-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            overflow-x: auto;
            display: block;
        }

        .matchup-table thead,
        .matchup-table tbody,
        .matchup-table tr {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        @media (max-width: 768px) {
            .matchup-table {
                font-size: 0.8rem;
            }

            .matchup-table th,
            .matchup-table td {
                padding: 0.5rem 0.25rem;
            }
        }

        .matchup-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.75rem;
            text-align: left;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .matchup-table th.sortable::after {
            content: ' ';
            opacity: 0.5;
            font-size: 0.8rem;
        }

        .matchup-table th.sorted-asc::after {
            content: ' ';
            opacity: 1;
        }

        .matchup-table th.sorted-desc::after {
            content: ' ';
            opacity: 1;
        }

        .matchup-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
        }

        .matchup-table tr:hover {
            background: #f8f9fa;
        }

        .awards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .awards-grid {
                grid-template-columns: 1fr;
            }
        }

        .award-section {
            margin-bottom: 1rem;
        }

        .award-section h3 {
            color: var(--retro-blue);
            margin-bottom: 1rem;
            font-size: 1.1rem;
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }
        
        .award-title-wrapper {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }
        
        .award-name {
            font-size: 1.1rem;
        }
        
        .award-description {
            font-size: 0.75rem;
            font-weight: normal;
            color: #666;
            font-family: 'Basis33', sans-serif;
        }

        .award-icon {
            font-size: 1.3rem;
        }

        .award-icon img {
            width: 32px;
            height: 32px;
        }

        .award-header-image {
            width: 32px;
            height: 32px;
            object-fit: contain;
            vertical-align: middle;
        }

        .award-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 1rem;
        }

        .award-table {
            width: 100%;
            border-collapse: collapse;
        }

        .award-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.75rem;
            text-align: left;
            white-space: nowrap;
        }

        .award-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
        }

        .award-table tr:hover {
            background: #f8f9fa;
        }

        .award-value {
            font-weight: bold;
            color: var(--retro-blue);
        }

        /* ===== PLAYER SCORING STYLES ===== */
        .player-controls {
            margin-bottom: 1.5rem;
        }

        .player-control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: flex-end;
        }

        .player-control-row .season-selector,
        .player-control-row .position-filter,
        .player-control-row .manager-filter,
        .player-control-row .stat-type-toggle {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .stat-type-toggle .toggle-buttons {
            display: flex;
            gap: 0;
        }

        .toggle-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--retro-blue);
            background: white;
            color: var(--retro-blue);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }

        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
            border-left: none;
        }

        .toggle-btn:hover {
            background: #f0f4f8;
        }

        .toggle-btn.active {
            background: var(--retro-blue);
            color: white;
        }

        .player-control-row label {
            font-weight: bold;
            color: var(--retro-blue);
            font-size: 0.85rem;
        }

        .player-control-row select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            min-width: 150px;
        }
        
        .player-controls-logo {
            margin-left: auto;
            display: flex;
            align-items: center;
        }
        
        .player-controls-league-logo {
            width: 60px;
            height: 60px;
            object-fit: contain;
        }

        .player-search {
            width: 100%;
            max-width: 400px;
        }

        .player-search input {
            width: 100%;
            padding: 0.6rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .player-search input:focus {
            outline: none;
            border-color: var(--retro-blue);
            box-shadow: 0 0 0 2px rgba(42, 82, 152, 0.1);
        }

        .player-summary {
            margin-bottom: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        .player-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .player-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .player-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.75rem 0.5rem;
            text-align: left;
            white-space: nowrap;
            position: sticky;
            top: 0;
        }

        .player-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .player-table th.sort-asc::after {
            content: ' ';
            font-size: 0.7rem;
        }

        .player-table th.sort-desc::after {
            content: ' ';
            font-size: 0.7rem;
        }

        .player-table th.bpa-header {
            cursor: help;
        }

        .player-table th.bpa-header:hover {
            background: var(--retro-blue-light);
        }

        .player-table .bpa-value {
            font-weight: 600;
            color: var(--retro-blue);
        }

        /* Projected Round Divider Bars */
        .player-table .round-divider {
            background: #d4a017;
            border: none;
        }
        
        .player-table .round-divider td {
            background: #d4a017;
            color: white;
            font-weight: 700;
            font-size: 0.85rem;
            text-align: center;
            padding: 0.5rem;
            border: none;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Mobile: Hide Export CSV button and left-align round divider text */
        @media (max-width: 768px) {
            .hide-mobile {
                display: none !important;
            }
            
            .player-table .round-divider td {
                text-align: left;
                padding-left: 1rem;
            }
        }

        .player-table td {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .player-table tbody tr:hover {
            background: #f0f4f8;
        }

        .player-table thead tr:hover {
            background: transparent;
        }

        .player-table .stat-col {
            text-align: center;
        }

        .player-name-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .player-name-cell:hover .player-name {
            color: var(--retro-blue);
            text-decoration: underline;
        }

        .player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #f0f0f0;
        }

        .player-name {
            font-weight: 500;
        }

        .player-mlb-team {
            font-size: 0.75rem;
            color: #888;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .player-mlb-logo {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }

        .player-team-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .player-team-logo {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            background: white;
        }

        .player-fantasy-team {
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        .player-position {
            font-weight: 500;
            color: #555;
        }

        .player-points {
            font-weight: bold;
            color: var(--retro-blue);
        }

        /* =========================================
           UNIVERSAL POSITION COLOR SYSTEM
           9 distinct colors with dark text on light backgrounds
           ========================================= */
        :root {
            /* --- POSITION PLAYERS (Dark text colors) --- */
            --pos-c-dark:     #4a148c; /* C: Deep Purple */
            --pos-c-light:    rgba(74, 20, 140, 0.15);
            
            --pos-1b-dark:    #1565c0; /* 1B: Blue */
            --pos-1b-light:   rgba(21, 101, 192, 0.15);
            
            --pos-2b-dark:    #e65100; /* 2B: Orange */
            --pos-2b-light:   rgba(230, 81, 0, 0.15);
            
            --pos-3b-dark:    #b71c1c; /* 3B: Red */
            --pos-3b-light:   rgba(183, 28, 28, 0.15);
            
            --pos-ss-dark:    #9c7c00; /* SS: Gold */
            --pos-ss-light:   rgba(200, 160, 0, 0.18);
            
            --pos-of-dark:    #2e7d32; /* OF: Green */
            --pos-of-light:   rgba(46, 125, 50, 0.15);
            
            --pos-dh-dark:    #546e7a; /* DH/Util: Grey */
            --pos-dh-light:   rgba(84, 110, 122, 0.15);
        
            /* --- PITCHERS --- */
            --pos-sp-dark:    #7e57c2; /* SP: Faded Light Purple/Lavender */
            --pos-sp-light:   rgba(126, 87, 194, 0.15);
            
            --pos-rp-dark:    #00838f; /* RP: Cyan/Teal */
            --pos-rp-light:   rgba(0, 131, 143, 0.15);
            
            /* P uses same as SP for consistency */
            --pos-p-dark:     #7e57c2;
            --pos-p-light:    rgba(126, 87, 194, 0.15);
        }
        
        /* UNIFIED POSITION BADGE STYLE
           Dark text on light background for all contexts */
        .position-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            text-align: center;
            min-width: 26px;
            width: fit-content;
            margin-right: 2px;
            text-transform: uppercase;
        }
        
        /* Position-specific colors */
        .position-badge.pos-C  { color: var(--pos-c-dark); background-color: var(--pos-c-light); }
        .position-badge.pos-1B { color: var(--pos-1b-dark); background-color: var(--pos-1b-light); }
        .position-badge.pos-2B { color: var(--pos-2b-dark); background-color: var(--pos-2b-light); }
        .position-badge.pos-3B { color: var(--pos-3b-dark); background-color: var(--pos-3b-light); }
        .position-badge.pos-SS { color: var(--pos-ss-dark); background-color: var(--pos-ss-light); }
        .position-badge.pos-OF, 
        .position-badge.pos-LF, 
        .position-badge.pos-CF, 
        .position-badge.pos-RF { color: var(--pos-of-dark); background-color: var(--pos-of-light); }
        .position-badge.pos-DH, 
        .position-badge.pos-Util { color: var(--pos-dh-dark); background-color: var(--pos-dh-light); }
        .position-badge.pos-SP { color: var(--pos-sp-dark); background-color: var(--pos-sp-light); }
        .position-badge.pos-RP { color: var(--pos-rp-dark); background-color: var(--pos-rp-light); }
        .position-badge.pos-P  { color: var(--pos-p-dark); background-color: var(--pos-p-light); }
        
        /* Default/unknown position */
        .position-badge:not([class*="pos-"]) {
            color: #666;
            background-color: rgba(0, 0, 0, 0.08);
        }
        
        /* DRAFT TABLE BADGES - Same style, lowercase class names for compatibility */
        .draft-player-pos {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 700;
            text-align: center;
            min-width: 26px;
            width: fit-content;
            align-self: flex-start;
            text-transform: uppercase;
        }
        
        .draft-player-pos.pos-c  { color: var(--pos-c-dark); background-color: var(--pos-c-light); }
        .draft-player-pos.pos-1b { color: var(--pos-1b-dark); background-color: var(--pos-1b-light); }
        .draft-player-pos.pos-2b { color: var(--pos-2b-dark); background-color: var(--pos-2b-light); }
        .draft-player-pos.pos-3b { color: var(--pos-3b-dark); background-color: var(--pos-3b-light); }
        .draft-player-pos.pos-ss { color: var(--pos-ss-dark); background-color: var(--pos-ss-light); }
        .draft-player-pos.pos-of,
        .draft-player-pos.pos-lf,
        .draft-player-pos.pos-cf,
        .draft-player-pos.pos-rf { color: var(--pos-of-dark); background-color: var(--pos-of-light); }
        .draft-player-pos.pos-dh,
        .draft-player-pos.pos-util { color: var(--pos-dh-dark); background-color: var(--pos-dh-light); }
        .draft-player-pos.pos-sp { color: var(--pos-sp-dark); background-color: var(--pos-sp-light); }
        .draft-player-pos.pos-rp { color: var(--pos-rp-dark); background-color: var(--pos-rp-light); }
        .draft-player-pos.pos-p  { color: var(--pos-p-dark); background-color: var(--pos-p-light); }

        /* Hide batter/pitcher stats based on filter */
        .show-batters .pitcher-stat,
        .show-pitchers .batter-stat {
            display: none;
        }

        /* Player Modal Styles */
        .player-modal-content {
            max-width: 480px;
            width: 90vw;
            background: transparent;
            box-shadow: none;
            border-radius: 12px;
            overflow: visible;
        }

        /* 1987 Topps Baseball Card - Horizontal Layout */
        .baseball-card {
            background: 
                repeating-linear-gradient(
                    90deg,
                    #c4a574 0px,
                    #d4b584 2px,
                    #c4a574 4px,
                    #b89564 6px,
                    #c4a574 8px
                );
            border-radius: 10px;
            padding: 12px;
            box-shadow: 
                0 10px 40px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .card-inner {
            background: #1a1a1a;
            border-radius: 6px;
            overflow: visible;
            border: 2px solid #111;
        }

        /* ===== CARD FRONT - Photo Section ===== */
        .card-front {
            position: relative;
            overflow: visible;
        }

        .card-photo-wrapper {
            position: relative;
            padding: 8px;
            background: var(--retro-blue);
        }

        .card-photo-container {
            position: relative;
            aspect-ratio: 16 / 9;
            width: 100%;
            overflow: hidden;
            clip-path: polygon(
                0 18px,
                18px 0,
                100% 0,
                100% calc(100% - 18px),
                calc(100% - 18px) 100%,
                0 100%
            );
            background: var(--retro-blue-light);
        }

        .card-action-shot {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center 25%;
        }

        .card-headshot-fallback {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center center;
        }

        /* MLB Logo - top left corner */
        .card-mlb-logo {
            position: absolute;
            top: 0;
            left: 0;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            padding: 3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-mlb-logo img {
            width: 85%;
            height: 85%;
            object-fit: contain;
        }

        .card-mlb-logo.fa-badge {
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--retro-blue);
        }

        /* Fantasy Logo - bottom right corner */
        .card-fantasy-logo {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 54px;
            height: 54px;
            background: white;
            border-radius: 50%;
            padding: 2px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 10;
            border: 3px solid #d4af37;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-fantasy-logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 50%;
        }

        .card-fantasy-logo.fa-badge {
            font-weight: bold;
            font-size: 0.65rem;
            color: #666;
            border-color: #ccc;
        }

        /* Player Name Banner */
        .card-name-banner {
            background: var(--retro-blue);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            position: relative;
        }

        .card-name-banner::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 3px;
            background: #d4af37;
        }

        /* Player Name Banner */
        .card-name-banner {
            background: var(--retro-blue);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            position: relative;
        }

        .card-name-banner::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 3px;
            background: #d4af37;
        }

        .card-year-badge {
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 900;
            color: white;
            background: #c41e3a;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            margin-right: 0.5rem;
            border: 1px solid rgba(255,255,255,0.3);
            position: relative;
            z-index: 1;
        }

        .card-player-name {
            color: white;
            font-size: 1rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            background: #c41e3a;
            padding: 0.2rem 0.6rem;
            border-radius: 0 3px 3px 0;
            margin-left: -0.5rem;
            position: relative;
            z-index: 0;
        }

        .card-position-badge {
            background: #d4af37;
            color: var(--retro-blue);
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-left: auto;
        }

        /* ===== CARD BACK - Stats Section ===== */
        .card-back {
            background: linear-gradient(135deg, #f5e6c8 0%, #e8d9b8 100%);
            position: relative;
        }

        .card-back::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(circle at 15% 85%, rgba(139, 119, 80, 0.08) 0%, transparent 40%),
                radial-gradient(circle at 85% 15%, rgba(139, 119, 80, 0.08) 0%, transparent 40%);
            pointer-events: none;
        }

        /* Back header with player info and headshot */
        .card-back-header {
            background: var(--retro-blue);
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.6rem;
            position: relative;
        }

        .card-back-number {
            background: #d4af37;
            color: var(--retro-blue);
            font-weight: 900;
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            clip-path: polygon(0 0, 100% 0, 85% 100%, 0 100%);
            padding-right: 0.8rem;
        }

        .card-back-info {
            flex: 1;
        }

        .card-back-name {
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-transform: uppercase;
        }

        .card-back-team {
            color: #d4af37;
            font-size: 0.85rem;
        }

        .card-back-headshot {
            width: 46px;
            height: 46px;
            border-radius: 50%;
            border: 2px solid #d4af37;
            object-fit: cover;
            background: #e0e0e0;
        }

        /* Stats toggle */
        .card-stats-toggle {
            background: var(--retro-blue);
            padding: 0.4rem 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-top: 2px solid #d4af37;
        }

        .card-stats-title {
            color: #d4af37;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .card-toggle-btns {
            display: flex;
        }

        .card-toggle-btn {
            padding: 0.25rem 0.6rem;
            border: 2px solid #d4af37;
            background: transparent;
            color: #d4af37;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }

        .card-toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
            border-left: none;
        }

        .card-toggle-btn:hover {
            background: rgba(212, 175, 55, 0.2);
        }

        .card-toggle-btn.active {
            background: #d4af37;
            color: var(--retro-blue);
        }

        /* Stats table */
        .card-stats-row {
            display: flex;
            background: var(--retro-blue);
        }

        .card-stats-label {
            background: #d4af37;
            color: var(--retro-blue);
            font-weight: bold;
            font-size: 0.75rem;
            padding: 0.3rem 0.5rem;
            min-width: 58px;
            display: flex;
            align-items: center;
            clip-path: polygon(0 0, 100% 0, 85% 100%, 0 100%);
            padding-right: 0.8rem;
        }

        .card-stats-cells {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }

        .card-stats-header-cell {
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
            text-align: center;
            padding: 0.3rem 0.1rem;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card-stats-data-row {
            display: flex;
            background: #f5e6c8;
            border-bottom: 1px solid #d4c4a4;
        }

        .card-stats-data-row:nth-child(even) {
            background: #ebe0c8;
        }

        .card-stats-data-label {
            background: #d4af37;
            color: var(--retro-blue);
            font-weight: bold;
            font-size: 0.8rem;
            padding: 0.35rem 0.5rem;
            min-width: 58px;
            display: flex;
            align-items: center;
            clip-path: polygon(0 0, 100% 0, 85% 100%, 0 100%);
            padding-right: 0.8rem;
        }

        .card-stats-data-cells {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
        }

        .card-stats-data-cell {
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            padding: 0.35rem 0.1rem;
            color: #333;
            border-left: 1px solid #d4c4a4;
        }

        /* Fantasy points row */
        .card-points-row {
            background: var(--retro-blue);
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-top: 2px solid #d4af37;
        }

        .card-points-label {
            color: white;
            font-size: 0.85rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .card-points-value {
            background: #d4af37;
            color: var(--retro-blue);
            font-size: 1.1rem;
            font-weight: 900;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
        }

        .card-points-rank {
            color: #d4af37;
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* Draft info row */
        .card-draft-row {
            background: var(--retro-blue);
            padding: 0.4rem 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border-top: 1px solid rgba(212, 175, 55, 0.3);
        }

        .card-draft-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        .card-draft-value {
            color: #d4af37;
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* Acquisition row */
        .card-acquisition-row {
            background: #ebe0c8;
            padding: 0.4rem 0.75rem;
            text-align: center;
            font-size: 0.8rem;
            color: #555;
            border-top: 1px solid #d4c4a4;
        }

        .card-acquisition-row strong {
            color: var(--retro-blue);
        }

        /* History section - FIXED HEIGHT */
        .card-history-wrapper {
            height: 120px;
            max-height: 120px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #1e3c72 #e8d9b8;
        }

        .card-history-wrapper::-webkit-scrollbar {
            width: 6px;
        }

        .card-history-wrapper::-webkit-scrollbar-track {
            background: #e8d9b8;
        }

        .card-history-wrapper::-webkit-scrollbar-thumb {
            background: var(--retro-blue);
            border-radius: 3px;
        }

        .card-history-title {
            background: var(--retro-blue);
            color: #d4af37;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            padding: 0.4rem 0.75rem;
        }

        .card-history-row {
            display: flex;
            align-items: center;
            padding: 0.35rem 0.6rem;
            border-bottom: 1px solid #d4c4a4;
            font-size: 0.8rem;
            background: #f5e6c8;
        }

        .card-history-row:nth-child(even) {
            background: #ebe0c8;
        }

        .card-history-year {
            font-weight: bold;
            color: var(--retro-blue);
            min-width: 40px;
        }

        .card-history-logo {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            margin-right: 0.4rem;
            object-fit: contain;
            background: white;
            padding: 1px;
        }

        .card-history-manager {
            flex: 1;
            color: #555;
            font-size: 0.75rem;
        }

        .card-history-pts {
            font-weight: bold;
            color: var(--retro-blue);
            min-width: 52px;
            text-align: right;
        }

        .card-history-rank {
            background: var(--retro-blue);
            color: #d4af37;
            font-size: 0.7rem;
            font-weight: bold;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            margin-left: 0.4rem;
            min-width: 30px;
            text-align: center;
        }

        /* Manager footer */
        .card-manager-footer {
            background: var(--retro-blue);
            color: white;
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-top: 2px solid #d4af37;
        }

        .card-manager-text {
            font-size: 0.8rem;
        }

        .card-manager-text span {
            text-transform: uppercase;
            font-weight: bold;
        }

        .card-manager-name {
            color: #d4af37;
            font-weight: bold;
        }

        .card-league-info {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .card-league-logo {
            width: 26px;
            height: 26px;
            object-fit: contain;
        }

        .card-league-text {
            color: white;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        /* Close button */
        #player-modal .modal-body-scroll {
            padding: 0;
            max-height: none;
            overflow: visible;
        }

        #player-modal .modal-close {
            position: absolute;
            top: -10px;
            right: -10px;
            background: var(--retro-blue);
            color: #d4af37;
            border: 3px solid #d4af37;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 1.1rem;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.4);
        }

        #player-modal .modal-close:hover {
            background: #d4af37;
            color: var(--retro-blue);
        }

        #player-modal-header {
            display: none;
        }

                /* Projection Modal Styles */
        .projection-modal-content {
            max-width: 900px;
            width: 95vw;
            background: transparent;
            box-shadow: none;
            border-radius: 12px;
            overflow: visible;
        }

        .projection-modal-layout {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }

        .projection-card-container {
            flex: 0 0 420px;
            max-width: 420px;
        }

        /* Projection Baseball Card Styles */
        .projection-card-container .baseball-card {
            background: 
                repeating-linear-gradient(
                    90deg,
                    #c4a574 0px,
                    #d4b584 2px,
                    #c4a574 4px,
                    #b89564 6px,
                    #c4a574 8px
                );
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.35);
        }

        .projection-card-container .card-inner {
            background: #1a1a1a;
            border-radius: 6px;
            overflow: visible;
        }

        .projection-card-container .card-photo-wrapper {
            position: relative;
            padding: 6px;
            background: var(--retro-blue);
        }

        .projection-card-container .card-photo-container {
            position: relative;
            aspect-ratio: 16 / 9;
            width: 100%;
            overflow: hidden;
            clip-path: polygon(
                0 18px,
                18px 0,
                100% 0,
                100% calc(100% - 18px),
                calc(100% - 18px) 100%,
                0 100%
            );
            background: var(--retro-blue-light);
        }

        .projection-card-container .card-action-shot,
        .projection-card-container .card-headshot {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center 25%;
        }

        .projection-card-container .card-mlb-logo {
            position: absolute;
            top: -2px;
            left: -2px;
            width: 48px;
            height: 48px;
            background: white;
            border-radius: 50%;
            padding: 3px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .projection-card-container .card-mlb-logo img {
            width: 85%;
            height: 85%;
            object-fit: contain;
        }

        .projection-card-container .card-mlb-fa {
            width: 48px;
            height: 48px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.85rem;
            color: var(--retro-blue);
            position: absolute;
            top: -2px;
            left: -2px;
            z-index: 10;
        }

        .projection-card-container .card-keeper-logo-wrapper {
            position: absolute;
            bottom: -2px;
            right: -2px;
            z-index: 10;
        }

        .projection-card-container .card-team-logo-corner {
            width: 52px;
            height: 52px;
            background: white;
            border-radius: 50%;
            padding: 2px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            border: 3px solid #d4af37;
            object-fit: contain;
        }

        .projection-card-container .card-keeper-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #d4af37;
            color: var(--retro-blue);
            font-size: 0.6rem;
            font-weight: bold;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .projection-card-container .card-name-banner {
            background: var(--retro-blue);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            position: relative;
        }

        .projection-card-container .card-name-banner::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            height: 3px;
            background: #d4af37;
        }

        .projection-card-container .card-year-badge {
            font-size: 0.85rem;
            font-weight: 900;
            color: white;
            background: #c41e3a;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            margin-right: 0.5rem;
            border: 1px solid rgba(255,255,255,0.3);
            position: relative;
            z-index: 1;
        }

        .projection-card-container .card-player-name {
            color: white;
            font-size: 1.1rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
            background: #c41e3a;
            padding: 0.2rem 0.6rem;
            border-radius: 0 3px 3px 0;
            margin-left: -0.5rem;
            position: relative;
            z-index: 0;
        }

        .projection-card-container .card-position-badge {
            background: #d4af37;
            color: var(--retro-blue);
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-left: auto;
        }

        .projection-card-container .card-back {
            background: linear-gradient(135deg, #f5e6c8 0%, #e8d9b8 100%);
        }

        .projection-card-container .card-back-header {
            background: var(--retro-blue);
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .projection-card-container .card-back-number {
            background: #d4af37;
            color: var(--retro-blue);
            font-weight: 900;
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            clip-path: polygon(0 0, 100% 0, 85% 100%, 0 100%);
            padding-right: 0.8rem;
        }

        .projection-card-container .card-back-info {
            flex: 1;
        }

        .projection-card-container .card-back-name {
            color: white;
            font-weight: bold;
            font-size: 1rem;
            text-transform: uppercase;
        }

        .projection-card-container .card-back-team {
            color: #d4af37;
            font-size: 0.8rem;
        }

        .projection-card-container .card-back-headshot {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: 2px solid #d4af37;
            object-fit: cover;
            background: #e0e0e0;
        }

        .projection-card-container .card-stats-section {
            padding: 0.6rem;
        }

        .projection-card-container .card-stats-header {
            background: var(--retro-blue);
            padding: 0.4rem 0.6rem;
            border-radius: 3px;
            margin-bottom: 0.5rem;
        }

        .projection-card-container .card-stats-title {
            color: #d4af37;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .projection-card-container .card-stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .projection-card-container .card-stats-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.35rem 0.25rem;
            font-weight: bold;
        }

        .projection-card-container .card-stats-table td {
            background: #f5e6c8;
            padding: 0.35rem 0.25rem;
            text-align: center;
            border: 1px solid #d4c4a4;
        }

        .projection-card-container .card-points-row {
            background: var(--retro-blue);
            padding: 0.5rem 0.75rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-top: 2px solid #d4af37;
        }

        .projection-card-container .card-points-label {
            color: white;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .projection-card-container .card-points-value {
            background: #d4af37;
            color: var(--retro-blue);
            font-size: 1.1rem;
            font-weight: 900;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
        }

        .projection-card-container .card-points-rank {
            color: #d4af37;
            font-size: 0.85rem;
            font-weight: bold;
        }

        .projection-card-container .card-info-strip {
            display: none;
        }

        .projection-card-container .card-scrollable {
            max-height: none;
        }

        /* Draft info row for projection card */
        .projection-card-container .card-draft-row {
            background: var(--retro-blue);
            padding: 0.4rem 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border-top: 1px solid rgba(212, 175, 55, 0.3);
        }

        .projection-card-container .card-draft-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .projection-card-container .card-draft-value {
            color: #d4af37;
            font-size: 0.85rem;
            font-weight: bold;
        }

        /* History section for projection card */
        .projection-card-container .card-history-wrapper {
            max-height: 100px;
            overflow-y: auto;
        }

        .projection-card-container .card-history-title {
            background: var(--retro-blue);
            color: #d4af37;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            padding: 0.35rem 0.75rem;
        }

        .projection-card-container .card-history-row {
            display: flex;
            align-items: center;
            padding: 0.3rem 0.5rem;
            border-bottom: 1px solid #d4c4a4;
            font-size: 0.75rem;
            background: #f5e6c8;
        }

        .projection-card-container .card-history-row:nth-child(even) {
            background: #ebe0c8;
        }

        .projection-card-container .card-history-year {
            font-weight: bold;
            color: var(--retro-blue);
            min-width: 36px;
        }

        .projection-card-container .card-history-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 0.3rem;
            object-fit: contain;
            background: white;
            padding: 1px;
        }

        .projection-card-container .card-history-manager {
            flex: 1;
            color: #555;
            font-size: 0.7rem;
        }

        .projection-card-container .card-history-pts {
            font-weight: bold;
            color: var(--retro-blue);
            min-width: 45px;
            text-align: right;
        }

        .projection-card-container .card-history-rank {
            background: var(--retro-blue);
            color: #d4af37;
            font-size: 0.65rem;
            font-weight: bold;
            padding: 0.1rem 0.25rem;
            border-radius: 3px;
            margin-left: 0.3rem;
            min-width: 28px;
            text-align: center;
        }

        .projection-charts-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 350px;
        }

        .projection-chart-box {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 3px solid var(--retro-blue);
        }

        .projection-chart-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--retro-blue);
            text-align: center;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .projection-chart {
            height: 180px;
            position: relative;
        }

        #projection-modal .modal-close {
            position: absolute;
            top: -12px;
            right: -12px;
            background: var(--retro-blue);
            color: white;
            border: 3px solid #f5d742;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #projection-modal .modal-close:hover {
            background: #f5d742;
            color: var(--retro-blue);
        }

        /* Chart dot styles */
        .chart-dot {
            fill: var(--retro-blue);
            opacity: 0.7;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .chart-dot:hover {
            opacity: 0.9;
        }

        .chart-dot.highlighted {
            fill: #f5d742;
            stroke: var(--retro-blue);
            stroke-width: 2;
            opacity: 1;
        }

        /* Keeper dot style for charts */
        .chart-dot.keeper-dot {
            fill: #f5d742;
            /* Gold */
            stroke: #b8860b;
            /* Darker gold border for visibility */
            stroke-width: 1px;
            opacity: 0.5;
        }

        .chart-dot.keeper-dot:hover {
            fill: #ffd700;
            opacity: 0.9;
        }

        .chart-axis {
            stroke: #ccc;
            stroke-width: 1;
        }

        .chart-axis-label {
            font-size: 10px;
            fill: #666;
        }

        .chart-grid {
            stroke: #eee;
            stroke-width: 1;
        }

        /* Mobile styles for projection modal */
        @media (max-width: 900px) {
            .projection-modal-content {
                max-width: 95vw;
            }

            .projection-modal-layout {
                flex-direction: column;
                align-items: center;
            }

            .projection-card-container {
                flex: none;
                max-width: 100%;
                width: 100%;
            }

            .projection-charts-container {
                width: 100%;
                min-width: auto;
            }
        }

        /* Mobile styles for baseball card */
        @media (max-width: 480px) {
            .player-modal-content {
                max-width: 95vw;
                margin: 0.5rem;
            }

            .baseball-card {
                border-width: 3px;
            }

            .card-header {
                padding: 0.5rem 0.75rem;
            }

            .card-mlb-logo {
                width: 30px;
                height: 30px;
            }

            .card-player-name {
                font-size: 1.1rem;
            }

            .card-fantasy-points {
                font-size: 0.9rem;
                padding: 0.15rem 0.35rem;
            }

            .card-fantasy-points .pts-label {
                font-size: 0.5rem;
            }

            .card-photo-section {
                min-height: 160px;
                padding: 0.75rem;
            }

            .card-photo-frame {
                width: 120px;
                height: 120px;
            }

            .card-position-badge {
                font-size: 0.75rem;
            }

            .card-team-badge {
                font-size: 0.65rem;
                padding: 0.2rem 0.4rem;
            }

            .card-team-logo-corner {
                width: 40px;
                height: 40px;
            }

            .card-position-rank {
                font-size: 0.65rem;
                padding: 0.15rem 0.35rem;
            }

            .card-mlb-team {
                font-size: 0.7rem;
            }

            .card-info-strip {
                font-size: 0.7rem;
                padding: 0.4rem 0.75rem;
            }

            .card-stats-table th,
            .card-stats-table td {
                padding: 0.25rem 0.15rem;
                font-size: 0.6rem;
            }

            .card-history-table {
                font-size: 0.6rem;
            }

            .card-scrollable {
                max-height: 220px;
            }
        }

        .player-history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .player-history-table th {
            background: #f0f4f8;
            padding: 0.6rem;
            text-align: left;
            font-weight: 600;
            color: var(--retro-blue);
        }

        .player-history-table td {
            padding: 0.6rem;
            border-bottom: 1px solid #eee;
        }

        .player-history-table tr:hover {
            background: #f8f9fa;
        }

        /* Hall of Champions Styles */
        .champion-header {
            background: var(--retro-blue);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            box-shadow: 0 4px 15px rgba(30, 60, 114, 0.3);
        }

        .champion-header .team-logo {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .champion-header .champion-info h3 {
            font-size: 1.8rem;
            margin: 0 0 0.25rem 0;
            color: #ffd700;
        }

        .champion-header .champion-info .manager-name {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .champion-header .champion-info .season-year {
            font-size: 1rem;
            opacity: 0.7;
            margin-top: 0.5rem;
        }

        .champion-header .trophy-icon {
            font-size: 3rem;
            margin-left: auto;
        }

        .championship-count-banner {
            background: linear-gradient(90deg, #ffd700, #ffec8b, #ffd700);
            color: var(--retro-blue);
            text-align: center;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }

        .champion-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .champion-stat-card {
            background: white;
            border-radius: 10px;
            padding: 1.25rem;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
        }

        .champion-stat-card .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--retro-blue);
        }

        .champion-stat-card .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 0.25rem;
        }

        .champion-section {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .champion-section h3 {
            color: var(--retro-blue);
            margin: 0 0 1rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #eee;
        }

        .champion-schedule-table {
            width: 100%;
            border-collapse: collapse;
        }

        .champion-schedule-table th {
            background: #f0f4f8;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: var(--retro-blue);
        }

        .champion-schedule-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #eee;
        }

        .champion-schedule-table .result-win {
            color: #28a745;
            font-weight: bold;
        }

        .champion-schedule-table .result-loss {
            color: #dc3545;
            font-weight: bold;
        }

        .champion-schedule-table .schedule-row-win {
            background: rgba(40, 167, 69, 0.08);
        }

        .champion-schedule-table .schedule-row-win:hover {
            background: rgba(40, 167, 69, 0.15);
        }

        .champion-schedule-table .schedule-row-loss {
            background: rgba(220, 53, 69, 0.08);
        }

        .champion-schedule-table .schedule-row-loss:hover {
            background: rgba(220, 53, 69, 0.15);
        }

        .champion-schedule-table .playoff-week {
            border-left: 3px solid #ffd700;
        }

        .champion-schedule-table .championship-week {
            border-left: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.15) !important;
        }

        .champion-schedule-table .championship-week:hover {
            background: rgba(255, 215, 0, 0.25) !important;
        }

        .schedule-opponent {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .schedule-team-logo {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
        }

        .roster-grid {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .roster-player-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .roster-player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .roster-player-card .player-headshot {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
        }

        .roster-player-card .player-info {
            flex: 1;
        }

        .roster-player-card .player-name {
            font-weight: 600;
            color: var(--retro-blue);
        }

        .roster-player-card .player-position {
            font-size: 0.8rem;
            color: #666;
        }

        .roster-player-card .player-points {
            text-align: right;
        }

        .roster-player-card .points-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--retro-blue);
        }

        .roster-player-card .points-label {
            font-size: 0.7rem;
            color: #888;
        }

        .roster-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .roster-columns {
                grid-template-columns: 1fr;
            }
        }

        .roster-column {
            min-width: 0;
        }

        .roster-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--retro-blue);
            margin: 0 0 0.75rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--retro-blue);
        }

        .prospects-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 2px dashed #ddd;
        }

        .prospects-section .roster-section-title {
            color: #888;
            border-bottom-color: #ccc;
        }

        .prospects-section .roster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.5rem;
        }

        .roster-player-card.prospect {
            background: #f0f0f0;
            opacity: 0.8;
        }

        .roster-player-card.prospect .points-value {
            color: #999;
        }

        /* Championship Logo Selector Styles */
        .championship-logo-selector {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 0.75rem;
            padding: 1.25rem 0.5rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, rgba(30, 60, 114, 0.05) 0%, rgba(42, 82, 152, 0.1) 100%);
            border-radius: 12px;
            overflow: visible;
            position: relative;
            z-index: 50;
        }

        .championship-logo-item {
            position: relative;
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        box-shadow 0.2s ease;
        }

        .championship-logo-item .logo-wrapper {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            overflow: hidden;
            border: 3px solid #c9d1d9;
            background: white;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .championship-logo-item .logo-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Champion ring badge - positioned on the logo-item, not inside wrapper */
        .championship-logo-item .champion-ring-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 22px;
            height: 22px;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
            z-index: 5;
        }

        .championship-logo-item:hover {
            transform: scale(1.2);
            z-index: 10;
        }

        .championship-logo-item:hover .logo-wrapper {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5), 
                        0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .championship-logo-item.active .logo-wrapper {
            border-color: #ffd700;
            border-width: 4px;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), 
                        0 4px 20px rgba(0, 0, 0, 0.25);
        }

        .championship-logo-item.active {
            transform: scale(1.15);
        }

        /* Tooltip for championship logo */
        .championship-logo-item .logo-tooltip {
            position: absolute;
            bottom: calc(100% + 12px);
            left: 50%;
            transform: translateX(-50%) scale(0.9);
            background: var(--retro-blue);
            color: white;
            padding: 0.6rem 1rem;
            border-radius: 8px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 4px 15px rgba(30, 60, 114, 0.4);
            pointer-events: none;
        }

        .championship-logo-item .logo-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: var(--retro-blue);
        }

        .championship-logo-item:hover .logo-tooltip,
        .championship-logo-item.tooltip-active .logo-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
        }

        .logo-tooltip .tooltip-year {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 0.2rem;
        }

        .logo-tooltip .tooltip-team {
            font-size: 0.85rem;
            opacity: 0.95;
        }

        .logo-tooltip .tooltip-manager {
            font-size: 0.75rem;
            opacity: 0.75;
            margin-top: 0.15rem;
        }

        /* Year indicator below logo */
        .championship-logo-item .year-indicator {
            text-align: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: #666;
            margin-top: 0.35rem;
            transition: color 0.2s ease;
        }

        .championship-logo-item:hover .year-indicator,
        .championship-logo-item.active .year-indicator {
            color: var(--retro-blue);
        }

        /* Mobile styles for championship logo selector */
        @media (max-width: 768px) {
            .championship-logo-selector {
                gap: 0.5rem;
                padding: 1rem 0.75rem;
                padding-top: 1rem;
                justify-content: flex-start;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .championship-logo-item .logo-wrapper {
                width: 48px;
                height: 48px;
                border-width: 2px;
            }

            .championship-logo-item.active .logo-wrapper {
                border-width: 3px;
            }

            .championship-logo-item .year-indicator {
                font-size: 0.65rem;
            }

            /* Hide tooltips on mobile */
            .championship-logo-item .logo-tooltip {
                display: none;
            }

            .championship-logo-item:hover {
                transform: scale(1.1);
            }

            .championship-logo-item.active {
                transform: scale(1.1);
            }
        }

        /* ===== PROJECTED LINEUPS SECTION ===== */
        .projected-lineups-section {
            margin-top: 2rem;
            border-top: 2px solid #e0e0e0;
            padding-top: 1.5rem;
        }

        .projected-lineups-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .projected-lineups-header h3 {
            color: var(--retro-blue);
            margin: 0;
        }

        .projected-lineups-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .lineup-projection-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .lineup-projection-selector label {
            font-size: 0.85rem;
            color: #666;
        }

        .lineup-projection-selector select {
            padding: 0.4rem 0.6rem;
            font-size: 0.85rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }

        .btn-show-lineup-prospects {
            padding: 0.4rem 0.75rem;
            font-size: 0.8rem;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-show-lineup-prospects:hover {
            background: #e0e0e0;
        }

        .btn-show-lineup-prospects.active {
            background: var(--retro-blue);
            color: white;
            border-color: var(--retro-blue);
        }

        /* Lineup Ticker Wrapper */
        .lineup-ticker-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 100%;
        }

        .lineup-ticker-viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            min-width: 0;
        }

        .lineup-ticker-track {
            display: flex;
            transition: transform 0.4s ease;
        }

        .lineup-ticker-card {
            flex: 0 0 100%;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        /* Team Header inside card */
        .lineup-card-header {
            background: var(--retro-blue);
            color: white;
            padding: 0.75rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .lineup-card-header .team-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .lineup-card-header .team-info {
            flex: 1;
        }

        .lineup-card-header .team-name {
            font-weight: 600;
            font-size: 1rem;
        }

        .lineup-card-header .manager-name {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .lineup-card-header .team-stats {
            text-align: right;
            font-size: 0.8rem;
        }

        .lineup-card-header .total-points {
            font-weight: 700;
            font-size: 1.1rem;
            color: #ffd700;
        }

        /* Lineup Content */
        .lineup-card-content {
            padding: 0.75rem;
            display: flex;
            gap: 1rem;
        }

        .lineup-column {
            flex: 1;
            min-width: 0;
        }

        .lineup-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--retro-blue);
            text-transform: uppercase;
            margin: 0.5rem 0 0.35rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .lineup-section-title:first-child {
            margin-top: 0;
        }

        /* Player Row */
        .lineup-player-row {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.25rem;
            gap: 0.5rem;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.85rem;
        }

        .lineup-player-row:last-child {
            border-bottom: none;
        }

        .lineup-player-row.empty-slot {
            opacity: 0.5;
        }

        .lineup-player-row.prospect-row {
            background: rgba(255, 215, 0, 0.08);
        }

        .lineup-pos-badge {
            flex: 0 0 36px;
        }

        .lineup-player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
            flex-shrink: 0;
        }

        .lineup-player-info {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .lineup-player-name {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lineup-player-mlb {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            color: #666;
        }

        .lineup-mlb-logo {
            width: 14px;
            height: 14px;
            object-fit: contain;
        }

        .lineup-player-stats {
            display: flex;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: #555;
            flex-shrink: 0;
        }

        .lineup-stat {
            text-align: center;
            min-width: 32px;
        }

        .lineup-stat-value {
            font-weight: 600;
        }

        .lineup-stat-label {
            font-size: 0.6rem;
            color: #888;
            text-transform: uppercase;
        }

        .lineup-player-points {
            font-weight: 700;
            color: var(--retro-blue);
            min-width: 45px;
            text-align: right;
            flex-shrink: 0;
        }

        /* Navigation */
        .lineup-ticker-nav-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: var(--retro-blue);
            color: white;
            font-size: 1.1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s, transform 0.1s;
            flex-shrink: 0;
        }

        .lineup-ticker-nav-btn:hover {
            background: var(--retro-blue);
            transform: scale(1.05);
        }

        .lineup-ticker-nav-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Logo Dots Navigation */
        .lineup-ticker-dots {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        .lineup-ticker-dot {
            position: relative;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
            border: 2px solid #ddd;
            background: white;
        }

        .lineup-ticker-dot img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .lineup-ticker-dot:hover {
            transform: scale(1.15);
            border-color: var(--retro-blue);
        }

        .lineup-ticker-dot.active {
            border-color: var(--retro-blue);
            box-shadow: 0 0 0 2px var(--retro-blue);
            transform: scale(1.1);
        }

        /* Dot Tooltip */
        .lineup-ticker-dot .dot-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%) scale(0.9);
            background: rgba(30, 60, 114, 0.95);
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 5px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, transform 0.2s, visibility 0.2s;
            z-index: 100;
            font-size: 0.75rem;
            text-align: center;
            pointer-events: none;
        }

        .lineup-ticker-dot .dot-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(30, 60, 114, 0.95);
        }

        .lineup-ticker-dot:hover .dot-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
        }

        /* Prospects Section in Lineup */
        .lineup-prospects-section {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 2px dashed #ddd;
            display: none;
        }

        .lineup-prospects-section.visible {
            display: block;
        }

        .lineup-prospects-section .lineup-section-title {
            color: #888;
        }

        /* Mobile Styles for Projected Lineups */
        @media (max-width: 768px) {
            .projected-lineups-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .projected-lineups-controls {
                width: 100%;
                justify-content: space-between;
            }

            .lineup-ticker-nav-btn {
                width: 28px;
                height: 28px;
                font-size: 0.9rem;
            }

            .lineup-card-header {
                padding: 0.6rem 0.75rem;
            }

            .lineup-card-header .team-logo {
                width: 32px;
                height: 32px;
            }

            .lineup-card-header .team-name {
                font-size: 0.9rem;
            }

            /* Stack columns vertically on mobile */
            .lineup-card-content {
                flex-direction: column;
                gap: 0;
            }

            .lineup-player-row {
                padding: 0.35rem 0.15rem;
                gap: 0.35rem;
            }

            .lineup-pos-badge {
                flex: 0 0 30px;
            }

            .lineup-pos-badge .position-badge {
                font-size: 0.6rem;
                padding: 0.1rem 0.25rem;
                min-width: 22px;
            }

            .lineup-player-headshot {
                width: 26px;
                height: 26px;
            }

            /* Hide stats and MLB team on mobile, show only position, headshot, name, points */
            .lineup-player-info {
                flex-direction: row;
                align-items: center;
                gap: 0.3rem;
            }

            .lineup-player-mlb,
            .lineup-player-stats {
                display: none;
            }

            .lineup-player-name {
                font-size: 0.75rem;
            }

            .lineup-player-points {
                font-size: 0.8rem;
                min-width: 38px;
            }

            .lineup-ticker-dots {
                gap: 0.35rem;
            }

            .lineup-ticker-dot {
                width: 24px;
                height: 24px;
            }

            .lineup-ticker-dot .dot-tooltip {
                display: none;
            }
        }

        /* Mobile styles for Player Scoring */
        @media (max-width: 768px) {
            .player-control-row {
                flex-direction: column;
                gap: 0.75rem;
            }

            .player-control-row .season-selector,
            .player-control-row .position-filter,
            .player-control-row .manager-filter,
            .player-control-row .stat-type-toggle {
                width: 100%;
            }

            .stat-type-toggle .toggle-buttons {
                width: 100%;
            }

            .toggle-btn {
                flex: 1;
                text-align: center;
            }

            .player-control-row select {
                width: 100%;
                min-width: unset;
            }

            .player-search {
                max-width: 100%;
            }

            .player-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .player-table {
                font-size: 0.7rem;
                min-width: 600px;
            }

            .player-table th,
            .player-table td {
                padding: 0.4rem 0.3rem;
            }

            .player-headshot {
                width: 24px;
                height: 24px;
            }

            .player-team-logo {
                width: 18px;
                height: 18px;
            }

            .player-name-cell {
                gap: 0.3rem;
            }

            .player-mlb-team {
                font-size: 0.65rem;
            }

            .player-mlb-logo {
                width: 12px;
                height: 12px;
            }

            .player-fantasy-team {
                max-width: 60px;
                font-size: 0.7rem;
            }

            /* Player Modal Mobile */
            .player-modal-content {
                width: 95%;
                max-height: 90vh;
            }

            #player-modal-header {
                flex-direction: column;
                text-align: center;
                padding: 1rem;
                gap: 0.75rem;
            }

            .player-modal-headshot {
                width: 60px;
                height: 60px;
            }

            .player-modal-info h2 {
                font-size: 1.2rem;
            }

            .player-modal-info .player-details {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
            }

            .player-modal-points {
                margin-left: 0;
                text-align: center;
            }

            .player-modal-points .points-value {
                font-size: 1.5rem;
            }

            .player-stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.5rem;
            }

            .player-stat-box {
                padding: 0.5rem;
            }

            .player-stat-box .stat-value {
                font-size: 1rem;
            }

            .player-stat-box .stat-label {
                font-size: 0.65rem;
            }

            .player-history-table {
                font-size: 0.8rem;
            }

            .player-history-table th,
            .player-history-table td {
                padding: 0.4rem;
            }
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        @media (max-width: 768px) {
            .award-table {
                font-size: 0.6rem;
                width: 100%;
                table-layout: fixed;
            }

            .award-table th,
            .award-table td {
                padding: 0.3rem 0.2rem;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            /* Award table column widths */
            .award-table th:nth-child(1),
            .award-table td:nth-child(1) {
                width: 15%;
            }

            /* Year */

            .award-table th:nth-child(2),
            .award-table td:nth-child(2) {
                width: 25%;
            }

            /* Manager */

            .award-table th:nth-child(3),
            .award-table td:nth-child(3) {
                width: 40%;
            }

            /* Team Name */

            .award-table th:nth-child(4),
            .award-table td:nth-child(4) {
                width: 20%;
            }

            /* Points/Wins */

            .award-section h3 {
                font-size: 1rem;
            }

            .award-icon {
                font-size: 1rem;
            }

            .awards-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .award-table-wrapper {
                overflow-x: visible;
            }
        }

        .error {
            background: #fee;
            border: 1px solid #fcc;
            padding: 1rem;
            border-radius: 5px;
            color: #c33;
            margin: 1rem 0;
        }

        /* Season Chart Styles */
        .chart-svg {
            overflow: visible;
        }

        .chart-line {
            fill: none;
            stroke-width: 2.5;
            transition: opacity 0.3s ease, stroke-width 0.3s ease;
        }

        .chart-line.faded {
            opacity: 0.15;
        }

        .chart-line.highlighted {
            stroke-width: 4;
        }

        .team-logo-marker {
            cursor: pointer;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .team-logo-marker.faded {
            opacity: 0.2;
        }

        .team-logo-marker.highlighted {
            transform-origin: center;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(30, 60, 114, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }

        .chart-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(30, 60, 114, 0.95);
        }

        .chart-axis-label {
            font-size: 0.75rem;
            fill: #666;
        }

        .chart-grid-line {
            stroke: #e0e0e0;
            stroke-width: 1;
        }

        .chart-toggle-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s, color 0.3s;
        }

        .chart-toggle-btn:hover {
            background: #ccc;
        }

        .chart-toggle-btn.active {
            background: var(--retro-blue);
            color: white;
        }

        /* Win Percentage Chart Styles */
        .winpct-chart {
            font-family: inherit;
        }

        .winpct-chart .chart-line {
            transition: opacity 0.2s;
        }

        .winpct-chart .chart-line.faded {
            opacity: 0.15;
        }

        .winpct-chart .chart-line.highlighted path:first-child {
            stroke-width: 4;
        }

        #winpct-chart {
            position: relative;
        }

        #winpct-chart .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
        }

        /* Mobile optimizations for chart */
        @media (max-width: 768px) {
            #season-chart-container>div:first-child {
                flex-direction: column;
                align-items: flex-start;
            }

            #season-chart {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .chart-toggle-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.85rem;
            }

            /* Mobile adjustments for Champion Schedule Table */
            .champion-schedule-table {
                font-size: 0.7rem;
                /* Reduce font size significantly */
                table-layout: fixed;
                /* Enforce column widths */
                width: 100%;
            }

            .champion-schedule-table th,
            .champion-schedule-table td {
                padding: 0.4rem 0.2rem;
                /* Tighten padding */
                white-space: nowrap;
                /* Prevent wrapping */
                overflow: hidden;
                text-overflow: ellipsis;
                /* Add ... if text is too long */
            }

            /* Week Column */
            .champion-schedule-table th:nth-child(1),
            .champion-schedule-table td:nth-child(1) {
                width: 15%;
            }

            /* Opponent Column (Give this the most space) */
            .champion-schedule-table th:nth-child(2),
            .champion-schedule-table td:nth-child(2) {
                width: 40%;
                white-space: normal;
                /* Allow wrapping */
                line-height: 1.2;
                /* Tighter spacing */
                text-overflow: clip;
                /* Remove the "..." */
                overflow: visible;
                /* Show content */
            }

            /* Score Column */
            .champion-schedule-table th:nth-child(3),
            .champion-schedule-table td:nth-child(3) {
                width: 33%;
                text-align: center;
                font-size: 0.65rem;
                /* Make score slightly smaller to fit decimals */
            }

            /* Result Column */
            .champion-schedule-table th:nth-child(4),
            .champion-schedule-table td:nth-child(4) {
                width: 10%;
                text-align: center;
            }

            /* Adjust opponent logo and text gap */
            .schedule-opponent {
                gap: 0.25rem;
            }

            .schedule-team-logo {
                width: 16px;
                /* Smaller logo */
                height: 16px;
            }

            .week-text {
                display: none;
            }
        }

        /* =========================================
           MOBILE PLAYER MODAL - SCROLLABLE CONTENT
           ========================================= */
        @media (max-width: 768px) {
            /* Lock body scroll when modal is open */
            body.modal-open,
            body.keeper-modal-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
            }

            /* Make the modal backdrop scrollable and align content to top */
            #player-modal.active,
            #projection-modal.active {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                align-items: flex-start;
                padding: 1rem 0;
            }

            /* Let content flow naturally */
            #player-modal .modal-content,
            #player-modal .player-modal-content,
            #projection-modal .modal-content,
            #projection-modal .projection-modal-content {
                max-height: none;
                height: auto;
                margin: 0 auto;
                overflow: visible;
                flex-shrink: 0;
            }

            #player-modal .modal-body-scroll,
            #projection-modal .modal-body-scroll {
                overflow: visible;
                max-height: none;
                padding: 0;
            }

            .baseball-card {
                max-height: none;
                overflow: visible;
            }

            .card-scrollable {
                max-height: none !important;
                overflow: visible !important;
            }

            /* Projection modal charts - ensure visible */
            .projection-modal-layout {
                flex-direction: column;
            }

            .projection-charts-panel {
                width: 100%;
                padding: 1rem;
            }

            .projection-chart-container {
                height: 200px;
                margin-bottom: 1rem;
            }
        }

        footer {
            background: rgba(255, 255, 255, 0.9);
            text-align: center;
            padding: 1rem;
            margin-top: 2rem;
            color: #666;
        }

        /* ===== SPORTSBOOK STYLES ===== */
        .sportsbook-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .sportsbook-user-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: var(--retro-blue);
            padding: 0.75rem 1.25rem;
            border-radius: 10px;
            color: white;
        }

        .sportsbook-user-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #d4af37;
        }

        .sportsbook-balance {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .sportsbook-balance-label {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .sportsbook-balance-amount {
            font-size: 1.3rem;
            font-weight: 700;
            color: #d4af37;
        }

        .sportsbook-logout-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .sportsbook-logout-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .sportsbook-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .sportsbook-tab-btn {
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--retro-blue);
            background: white;
            color: var(--retro-blue);
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sportsbook-tab-btn:hover {
            background: #f0f4ff;
        }

        .sportsbook-tab-btn.active {
            background: var(--retro-blue);
            color: white;
            border-color: var(--retro-blue);
        }

        .sportsbook-subtabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .sportsbook-subtab-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #ddd;
            background: #f8f9fa;
            color: #333;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sportsbook-subtab-btn:hover {
            background: #e9ecef;
        }

        .sportsbook-subtab-btn.active {
            background: #d4af37;
            color: white;
            border-color: #d4af37;
        }

        .sportsbook-content {
            display: none;
        }

        .sportsbook-content.active {
            display: block;
        }

        /* Season Bets */
        .season-bet-section {
            margin-bottom: 2rem;
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .season-bet-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--retro-blue);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #d4af37;
        }

        .season-bet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
        }

        .season-bet-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .season-bet-card:hover {
            border-color: var(--retro-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .season-bet-card.selected {
            border-color: #d4af37;
            background: #fffbeb;
        }

        .season-bet-logo {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin: 0 auto 0.75rem;
            border: 2px solid #ddd;
            object-fit: cover;
        }

        .season-bet-team {
            font-size: 0.85rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .season-bet-manager {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .season-bet-card-info {
            /* Wrapper for team name and manager - allows flex layout on mobile */
        }

        .season-bet-odds {
            font-size: 1.1rem;
            font-weight: 700;
            color: #28a745;
            padding: 0.3rem 0.6rem;
            background: rgba(40, 167, 69, 0.1);
            border-radius: 5px;
        }

        .season-bet-odds.underdog {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        /* Team Totals Grid - 2 Column Layout */
        .team-totals-grid {
            width: 100%;
        }

        .team-totals-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .team-totals-column {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 1rem;
        }

        .totals-column-header {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--retro-blue);
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
            border-bottom: 2px solid #e0e0e0;
            text-align: center;
        }

        .team-total-row {
            display: grid;
            grid-template-columns: 1fr 70px auto;
            gap: 0.75rem;
            align-items: center;
            padding: 0.6rem 0.5rem;
            border-radius: 8px;
            transition: background 0.2s;
        }

        .team-total-row:hover {
            background: rgba(30, 60, 114, 0.05);
        }

        .team-total-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 0;
            flex: 1;
        }

        .team-total-logo {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #ddd;
            object-fit: cover;
        }

        .team-total-details {
            display: flex;
            flex-direction: column;
            min-width: 0;
            flex: 1;
        }

        .team-total-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .team-total-manager {
            font-size: 0.7rem;
            color: #666;
        }

        .team-total-line {
            font-size: 1rem;
            font-weight: 700;
            color: var(--retro-blue);
            min-width: 70px;
            text-align: center;
        }

        .team-total-odds {
            display: flex;
            gap: 0.4rem;
        }

        .total-bet-arrow {
            padding: 0.4rem 0.6rem;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
            font-weight: 600;
            min-width: 72px;
            text-align: center;
        }

        .total-bet-arrow.over {
            background: rgba(40, 167, 69, 0.1);
            color: #28a745;
        }

        .total-bet-arrow.over:hover {
            background: rgba(40, 167, 69, 0.25);
        }

        .total-bet-arrow.under {
            background: rgba(220, 53, 69, 0.1);
            color: #dc3545;
        }

        .total-bet-arrow.under:hover {
            background: rgba(220, 53, 69, 0.25);
        }

        .total-bet-arrow.selected {
            border: 2px solid currentColor;
        }

        @media (max-width: 900px) {
            .team-totals-columns {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 500px) {
            .team-total-row {
                grid-template-columns: 1fr;
                gap: 0.5rem;
                text-align: center;
            }
            
            .team-total-info {
                justify-content: center;
            }
            
            .team-total-odds {
                justify-content: center;
            }
        }

        /* Mobile Sportsbook - Compact cards for major bets */
        @media (max-width: 768px) {
            .season-bet-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 0.5rem;
            }
            
            .season-bet-card {
                display: flex;
                flex-direction: row;
                align-items: center;
                padding: 0.5rem;
                text-align: left;
                gap: 0.5rem;
            }
            
            .season-bet-card .season-bet-logo {
                width: 36px;
                height: 36px;
                margin: 0;
                flex-shrink: 0;
            }
            
            .season-bet-card-info {
                flex: 1;
                min-width: 0;
                display: flex;
                flex-direction: column;
            }
            
            .season-bet-card .season-bet-team {
                font-size: 0.75rem;
                margin-bottom: 0;
                line-height: 1.2;
            }
            
            .season-bet-card .season-bet-manager {
                font-size: 0.65rem;
                margin-bottom: 0;
            }
            
            .season-bet-card .season-bet-odds {
                font-size: 0.85rem;
                padding: 0.2rem 0.4rem;
                flex-shrink: 0;
            }
        }

        /* Weekly Matchup Bets */
        .weekly-bet-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
        }

        .weekly-bet-week-selector {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .weekly-bet-week-selector label {
            font-weight: 600;
            color: var(--retro-blue);
        }

        .weekly-bet-week-selector select {
            padding: 0.5rem 1rem;
            border: 2px solid var(--retro-blue);
            border-radius: 6px;
            font-size: 1rem;
        }

        .matchup-bet-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
        }

        .matchup-bet-card {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 2px solid transparent;
        }

        .matchup-bet-card:hover {
            border-color: var(--retro-blue);
        }

        .matchup-bet-vs {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .matchup-bet-team {
            flex: 1;
            text-align: center;
            cursor: pointer;
            padding: 0.75rem;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .matchup-bet-team:hover {
            background: #f0f4ff;
            border-color: var(--retro-blue);
        }

        .matchup-bet-team.selected {
            background: #fffbeb;
            border-color: #d4af37;
        }

        .matchup-bet-team-logo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0 auto 0.5rem;
            border: 2px solid #ddd;
        }

        .matchup-bet-team-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 0.25rem;
        }

        .matchup-bet-projected {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        .matchup-bet-team-odds {
            font-size: 1rem;
            font-weight: 700;
            color: #28a745;
        }

        .matchup-bet-team-odds.underdog {
            color: #dc3545;
        }

        .matchup-bet-vs-label {
            font-weight: 700;
            color: #999;
            font-size: 0.9rem;
        }

        /* Bet Slip */
        .bet-slip {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 320px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 100;
            overflow: hidden;
            display: none;
        }

        .bet-slip.active {
            display: block;
        }

        .bet-slip-header {
            background: var(--retro-blue);
            color: white;
            padding: 1rem;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bet-slip-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.25rem;
            cursor: pointer;
        }

        .bet-slip-content {
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .bet-slip-item {
            padding: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 0.75rem;
        }

        .bet-slip-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .bet-slip-item-team {
            font-weight: 600;
            color: #333;
        }

        .bet-slip-item-odds {
            font-weight: 700;
            color: #28a745;
        }

        .bet-slip-item-type {
            font-size: 0.75rem;
            color: #666;
        }

        .bet-slip-item-wager {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .bet-slip-item-wager label {
            font-size: 0.85rem;
        }

        .bet-slip-wager-stepper {
            display: flex;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            overflow: hidden;
        }

        .bet-slip-wager-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: #f0f0f0;
            color: #333;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .bet-slip-wager-btn:hover {
            background: #e0e0e0;
        }

        .bet-slip-wager-btn:active {
            background: #d0d0d0;
        }

        .bet-slip-wager-btn.minus {
            border-right: 1px solid #ddd;
        }

        .bet-slip-wager-btn.plus {
            border-left: 1px solid #ddd;
        }

        .bet-slip-item-wager input {
            width: 50px;
            padding: 0.4rem;
            border: none;
            text-align: center;
            font-size: 16px; /* Prevents iOS zoom */
            -moz-appearance: textfield; /* Hide spinners in Firefox */
        }

        .bet-slip-item-wager input::-webkit-outer-spin-button,
        .bet-slip-item-wager input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .bet-slip-item-payout {
            font-size: 0.85rem;
            color: #28a745;
            font-weight: 600;
        }

        .bet-slip-item-remove {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            margin-left: auto;
        }

        .bet-slip-footer {
            padding: 1rem;
            border-top: 1px solid #eee;
        }

        .bet-slip-total {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            font-weight: 600;
        }

        .bet-slip-submit {
            width: 100%;
            padding: 0.75rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
        }

        .bet-slip-submit:hover {
            background: #218838;
        }

        .bet-slip-submit:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Bet History */
        .bet-history-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 0 -0.5rem;
            padding: 0 0.5rem;
        }

        .bet-history-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 700px;
        }

        .bet-history-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.75rem;
            text-align: left;
            font-size: 0.85rem;
        }

        .bet-history-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }

        .bet-history-table tr:hover {
            background: #f8f9fa;
        }

        .bet-status {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .bet-status.pending {
            background: #fff3cd;
            color: #856404;
        }

        .bet-status.won {
            background: #d4edda;
            color: #155724;
        }

        .bet-status.lost {
            background: #f8d7da;
            color: #721c24;
        }

        /* Betting Info Button */
        .bet-info-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: rgba(30, 60, 114, 0.1);
            color: var(--retro-blue);
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            margin-left: 0.5rem;
            transition: all 0.2s;
            border: 1px solid rgba(30, 60, 114, 0.3);
            vertical-align: middle;
            text-transform: lowercase;
            font-style: italic;
            font-family: Georgia, serif;
        }

        .bet-info-btn:hover {
            background: var(--retro-blue);
            color: white;
            transform: scale(1.1);
        }

        .season-bet-title {
            display: flex;
            align-items: center;
        }

        /* Betting Stats Modal */
        .bet-stats-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .bet-stats-modal.active {
            display: flex;
        }

        .bet-stats-content {
            background: white;
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .bet-stats-header {
            background: var(--retro-blue);
            color: white;
            padding: 1.25rem;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bet-stats-header h3 {
            margin: 0;
            font-size: 1.1rem;
        }

        .bet-stats-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
        }

        .bet-stats-close:hover {
            opacity: 1;
        }

        .bet-stats-body {
            padding: 1.5rem;
        }

        .bet-stats-summary {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .bet-stats-box {
            flex: 1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
        }

        .bet-stats-box-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--retro-blue);
        }

        .bet-stats-box-label {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.25rem;
        }

        .bet-stats-chart-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            justify-content: center;
        }

        .bet-stats-chart-btn {
            padding: 0.5rem 1rem;
            border: 2px solid var(--retro-blue);
            background: white;
            color: var(--retro-blue);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .bet-stats-chart-btn.active {
            background: var(--retro-blue);
            color: white;
        }

        .bet-stats-chart-container {
            position: relative;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }

        .bet-stats-pie {
            width: 100%;
            height: auto;
        }

        .bet-stats-legend {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }

        .bet-stats-legend-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .bet-stats-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .bet-stats-legend-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            object-fit: cover;
        }

        /* Team Total Info - inline stats */
        .team-total-info-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(30, 60, 114, 0.1);
            color: var(--retro-blue);
            font-size: 0.6rem;
            font-weight: 700;
            cursor: pointer;
            margin-left: 0.35rem;
            transition: all 0.2s;
            border: 1px solid rgba(30, 60, 114, 0.3);
            flex-shrink: 0;
            text-transform: lowercase;
            font-style: italic;
            font-family: Georgia, serif;
        }

        .team-total-info-btn:hover {
            background: var(--retro-blue);
            color: white;
        }

        /* Over/Under stats in modal */
        .ou-stats-bar {
            display: flex;
            height: 30px;
            border-radius: 6px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .ou-stats-over {
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .ou-stats-under {
            background: #dc3545;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
        }

        /* Sportsbook Login Modal */
        .sportsbook-login-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .sportsbook-login-modal.active {
            display: flex;
        }

        .sportsbook-login-content {
            background: white;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 2rem;
        }

        .sportsbook-login-title {
            text-align: center;
            color: var(--retro-blue);
            margin-bottom: 0.5rem;
            font-size: 1.5rem;
        }

        .sportsbook-login-subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 1.5rem;
        }

        .sportsbook-team-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .sportsbook-team-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 0.75rem;
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .sportsbook-team-option:hover {
            background: #f0f4ff;
            border-color: var(--retro-blue);
        }

        .sportsbook-team-option.selected {
            background: #fffbeb;
            border-color: #d4af37;
        }

        .sportsbook-team-option img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #ddd;
            margin-bottom: 0.5rem;
        }

        .sportsbook-team-option .team-name {
            font-size: 0.7rem;
            color: #333;
            text-align: center;
            line-height: 1.2;
        }

        .sportsbook-password-section {
            display: none;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #eee;
        }

        .sportsbook-password-section.active {
            display: block;
        }

        .sportsbook-password-section h4 {
            color: var(--retro-blue);
            margin-bottom: 1rem;
            text-align: center;
        }

        .sportsbook-password-input {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .sportsbook-password-input input {
            padding: 0.75rem 1rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 200px;
            font-size: 16px; /* Prevents iOS zoom on focus */
        }

        .sportsbook-password-input button {
            padding: 0.75rem 1.5rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 16px;
        }

        .sportsbook-back-btn {
            display: block;
            margin: 1rem auto 0;
            padding: 0.5rem 1rem;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            color: #666;
        }

        .sportsbook-login-error {
            color: #dc3545;
            text-align: center;
            margin-top: 0.5rem;
            font-size: 0.9rem;
            display: none;
        }

        .sportsbook-not-logged-in {
            text-align: center;
            padding: 3rem;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .sportsbook-not-logged-in h3 {
            color: var(--retro-blue);
            margin-bottom: 1rem;
        }

        .sportsbook-not-logged-in p {
            color: #666;
            margin-bottom: 1.5rem;
        }

        .sportsbook-login-btn {
            padding: 0.75rem 2rem;
            background: #d4af37;
            color: var(--retro-blue);
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
        }

        .sportsbook-login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }

        /* Prospect Pavilion Styles */
        .prospect-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            flex-wrap: wrap;
            gap: 0.75rem;
        }
        
        .prospect-controls-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .prospect-controls-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .prospect-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.85rem;
        }
        
        .prospect-toggle input {
            display: none;
        }
        
        .toggle-slider {
            width: 40px;
            height: 22px;
            background: #ccc;
            border-radius: 11px;
            position: relative;
            transition: background 0.2s;
        }
        
        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }
        
        .prospect-toggle input:checked + .toggle-slider {
            background: var(--retro-blue);
        }
        
        .prospect-toggle input:checked + .toggle-slider::before {
            transform: translateX(18px);
        }
        
        .prospect-search-container input {
            padding: 0.5rem 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            width: 180px;
        }
        
        .prospect-controls-right select {
            padding: 0.5rem 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            background: white;
        }
        
        .prospect-stats-bar {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.8rem;
            color: #666;
        }
        
        .prospect-table-container {
            overflow-x: auto;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .prospect-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: white;
        }
        
        .prospect-table thead {
            background: var(--retro-blue);
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .prospect-table th {
            padding: 0.75rem 0.5rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .prospect-table td {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }
        
        .prospect-table tbody tr:hover {
            background: #f8f9fa;
        }
        
        .prospect-table tbody tr.owned {
            background: rgba(34, 197, 94, 0.08);
        }
        
        .prospect-table tbody tr.owned:hover {
            background: rgba(34, 197, 94, 0.15);
        }
        
        .prospect-col-rank {
            width: 50px;
            text-align: center !important;
        }
        
        .prospect-col-player {
            min-width: 200px;
        }
        
        .prospect-col-pos {
            width: 50px;
            text-align: center !important;
        }
        
        .prospect-col-details {
            min-width: 180px;
        }
        
        .prospect-col-owner {
            min-width: 140px;
        }
        
        .prospect-rank {
            font-weight: 700;
            font-size: 0.9rem;
            color: var(--retro-blue);
        }
        
        .prospect-rank.top-10 {
            color: #d4af37;
        }
        
        .prospect-rank.top-25 {
            color: #22c55e;
        }
        
        .prospect-player-cell {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }
        
        .prospect-headshot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            background: #f0f0f0;
            flex-shrink: 0;
        }
        
        .prospect-player-info {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .prospect-player-name {
            font-weight: 600;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .prospect-mlb-team {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            color: #666;
            margin-top: 2px;
        }
        
        .prospect-mlb-logo {
            width: 14px;
            height: 14px;
            object-fit: contain;
        }
        
        .prospect-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 0.75rem;
            color: #666;
        }
        
        .prospect-details-row {
            display: flex;
            gap: 0.75rem;
        }
        
        .prospect-detail-item {
            display: flex;
            gap: 0.25rem;
        }
        
        .prospect-detail-label {
            color: #999;
        }
        
        .prospect-detail-value {
            color: #333;
            font-weight: 500;
        }
        
        .prospect-owner-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .prospect-owner-logo {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            object-fit: cover;
        }
        
        .prospect-owner-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: #22c55e;
        }
        
        .prospect-available {
            font-size: 0.75rem;
            color: #999;
            font-style: italic;
        }
        
        .prospect-loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }
        
        .prospect-footer {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.75rem;
            color: #999;
        }
        
        /* Mobile responsive */
        @media (max-width: 768px) {
            .prospect-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .prospect-controls-left,
            .prospect-controls-right {
                width: 100%;
                justify-content: space-between;
            }
            
            .prospect-search-container input {
                width: 100%;
            }
            
            .prospect-col-details {
                display: none;
            }
            
            .prospect-table th,
            .prospect-table td {
                padding: 0.5rem 0.35rem;
            }
            
            .prospect-headshot {
                width: 32px;
                height: 32px;
            }
            
            .prospect-player-name {
                font-size: 0.8rem;
            }
        }

        /* Bylaws Section Styles */
        .bylaws-container {
            max-width: 1000px;
            margin: 0 auto;
            padding-right: 300px;
            position: relative;
        }

        .bylaws-main {
            width: 100%;
        }

        .bylaws-sidebar {
            position: fixed;
            right: calc((100vw - 1200px) / 2 + 20px);
            top: 120px;
            width: 260px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            z-index: 100;
            display: none; /* Hidden by default, shown when bylaws section is active */
        }

        /* Adjust for different screen widths */
        @media (max-width: 1400px) {
            .bylaws-sidebar {
                right: 20px;
            }
            
            .bylaws-container {
                padding-right: 290px;
                max-width: calc(100% - 20px);
            }
        }

        /* Override section overflow to allow sticky to work */
        #bylaws.section {
            overflow: visible;
        }

        #bylaws.section.active {
            overflow: visible;
        }

        .bylaws-toc {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .bylaws-toc h3 {
            color: var(--retro-blue);
            font-size: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #d4af37;
        }

        .bylaws-toc-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .bylaws-toc-list li {
            margin-bottom: 0.5rem;
        }

        .bylaws-toc-list a {
            color: #444;
            text-decoration: none;
            font-size: 0.85rem;
            display: block;
            padding: 0.4rem 0.75rem;
            border-radius: 6px;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .bylaws-toc-list a:hover {
            background: #f0f4ff;
            color: var(--retro-blue);
        }

        .bylaws-toc-list a.active {
            background: #f0f4ff;
            color: var(--retro-blue);
            border-left-color: #d4af37;
            font-weight: 600;
        }

        .bylaws-toc-list .toc-subsection {
            padding-left: 1rem;
            font-size: 0.8rem;
        }

        .bylaws-content {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .bylaws-header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 2px solid #eee;
        }

        .bylaws-header h1 {
            color: var(--retro-blue);
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .bylaws-officers {
            display: flex;
            justify-content: center;
            gap: 2rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .bylaws-officer {
            text-align: center;
        }

        .bylaws-officer-title {
            font-weight: 700;
            color: var(--retro-blue);
            font-size: 0.9rem;
        }

        .bylaws-officer-name {
            color: #666;
            font-size: 0.85rem;
        }

        .bylaws-categories {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 2rem;
        }

        .bylaws-categories h3 {
            color: var(--retro-blue);
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .bylaws-categories ol {
            margin: 0;
            padding-left: 1.5rem;
            columns: 2;
            column-gap: 2rem;
        }

        .bylaws-categories li {
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            break-inside: avoid;
        }

        .bylaws-section {
            margin-bottom: 2.5rem;
            scroll-margin-top: 1rem;
        }

        .bylaws-section-title {
            color: var(--retro-blue);
            font-size: 1.5rem;
            margin-bottom: 1.25rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #d4af37;
        }

        .bylaws-rule {
            margin-bottom: 1.25rem;
            padding-left: 0;
        }

        .bylaws-rule-number {
            font-weight: 700;
            color: var(--retro-blue);
            margin-right: 0.5rem;
        }

        .bylaws-rule-content {
            color: #333;
            line-height: 1.6;
        }

        .bylaws-subrule {
            margin-left: 1.5rem;
            margin-top: 0.5rem;
            padding-left: 0.75rem;
            border-left: 2px solid #eee;
        }

        .bylaws-subrule-number {
            font-weight: 600;
            color: var(--retro-blue);
            margin-right: 0.35rem;
        }

        .bylaws-subsubrule {
            margin-left: 1rem;
            margin-top: 0.35rem;
            font-size: 0.95rem;
            color: #555;
        }

        .bylaws-deprecated {
            text-decoration: line-through;
            color: #999;
        }

        .bylaws-note {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 0.75rem 1rem;
            margin: 1rem 0;
            font-size: 0.9rem;
            color: #856404;
        }

        .bylaws-highlight {
            background: #fff9c4;
            padding: 0 0.25rem;
            border-radius: 3px;
        }

        .bylaws-scoring-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        .bylaws-scoring-table th {
            background: var(--retro-blue);
            color: white;
            padding: 0.5rem 0.75rem;
            text-align: left;
        }

        .bylaws-scoring-table td {
            padding: 0.4rem 0.75rem;
            border-bottom: 1px solid #eee;
        }

        .bylaws-scoring-table tr:hover {
            background: #f8f9fa;
        }

        .bylaws-scoring-section {
            font-weight: 600;
            background: #f0f4ff;
        }

        @media (max-width: 1024px) {
            .bylaws-sidebar {
                display: none;
            }

            .bylaws-container {
                padding-right: 0;
                max-width: 100%;
            }
        }

        @media (max-width: 768px) {
            .bylaws-content {
                padding: 1.25rem;
            }

            .bylaws-header h1 {
                font-size: 1.5rem;
            }

            .bylaws-officers {
                gap: 1rem;
            }

            .bylaws-categories ol {
                columns: 1;
            }

            .bylaws-section-title {
                font-size: 1.25rem;
            }
        }
        /* =================================================================
           HOMEPAGE STYLES
           ================================================================= */
        
        .homepage-layout {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        /* Three Column Layout */
        .homepage-three-columns {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1.5rem;
        }
        
        .homepage-column {
            background: white;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .homepage-column-header {
            margin-bottom: 0.75rem;
        }
        
        .homepage-column-title {
            font-weight: 600;
            color: var(--retro-blue);
            font-size: 1rem;
        }
        
        /* Home Header with Green Monster */
        .home-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }
        
        .home-header h2 {
            margin: 0;
        }
        
        /* Green Monster Top Scoring Day Ticker */
        .green-monster-ticker {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }
        
        .green-monster-label {
            color: #3d6b2a;
            font-size: 0.7rem;
            font-weight: 700;
            line-height: 1.2;
            text-align: right;
        }
        
        .green-monster-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            /* Authentic Green Monster faded green - weathered look */
            background: #4a7c3f;
            border-radius: 6px;
            padding: 0.4rem 0.6rem;
            box-shadow: 
                inset 0 1px 2px rgba(0,0,0,0.2),
                0 2px 6px rgba(0, 0, 0, 0.25);
        }
        
        .green-monster-logo {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(255,255,255,0.4);
            background: #3d6b2a;
        }
        
        .green-monster-scoreboard {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.1rem;
        }
        
        /* Date as individual digits - aligned right to match score */
        .green-monster-date {
            display: flex;
            gap: 2px;
            justify-content: flex-end;
        }
        
        .green-monster-score {
            display: flex;
            gap: 2px;
            align-items: baseline;
        }
        
        /* Individual number tiles - like the interchangeable plates on the Monster */
        .monster-digit {
            font-family: 'Basis33', 'Arial Black', sans-serif;
            font-weight: 900;
            color: #f5f5f0;
            text-align: center;
            /* Recessed plate effect */
            background: linear-gradient(180deg, #3d6b2a 0%, #4a7c3f 50%, #3d6b2a 100%);
            border-radius: 2px;
            box-shadow: 
                inset 1px 1px 2px rgba(0,0,0,0.4),
                inset -1px -1px 1px rgba(255,255,255,0.1);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
        }
        
        /* Date digits - same size as score digits for alignment */
        .monster-digit.date-digit {
            font-size: 0.9rem;
            min-width: 16px;
            padding: 3px 4px;
            line-height: 1;
        }
        
        .monster-digit.date-separator {
            background: transparent;
            box-shadow: none;
            min-width: auto;
            padding: 0 1px;
            font-size: 0.9rem;
            align-self: flex-end;
            margin-bottom: 2px;
        }
        
        .monster-digit.score-digit {
            font-size: 0.9rem;
            min-width: 16px;
            padding: 3px 4px;
            line-height: 1;
        }
        
        .monster-digit.decimal {
            background: transparent;
            box-shadow: none;
            min-width: auto;
            padding: 0 1px;
            font-size: 0.9rem;
            align-self: flex-end;
            margin-bottom: 2px;
        }
        
        @media (max-width: 600px) {
            .home-header {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }
            
            .green-monster-ticker {
                position: static;
                gap: 0.4rem;
            }
            
            .green-monster-label {
                font-size: 0.55rem;
                line-height: 1.1;
            }
            
            .green-monster-display {
                padding: 0.3rem 0.4rem;
                gap: 0.35rem;
            }
            
            .green-monster-logo {
                width: 26px;
                height: 26px;
            }
            
            /* Mobile: same size for date and score digits */
            .monster-digit.date-digit,
            .monster-digit.score-digit {
                font-size: 0.85rem;
                min-width: 14px;
                padding: 2px 3px;
            }
            
            .monster-digit.date-separator,
            .monster-digit.decimal {
                font-size: 0.85rem;
                margin-bottom: 1px;
            }
        }
        
        /* Matchup Ticker */
        .matchup-ticker-container {
            background: var(--retro-blue);
            border-radius: 12px;
            padding: 0.75rem 1rem;
            overflow: hidden;
            margin-bottom: 1rem;
        }
        
        .matchup-ticker-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .matchup-ticker-title {
            color: white;
            font-weight: 700;
            font-size: 1.1rem;
        }
        
        .matchup-ticker-week {
            background: rgba(255,255,255,0.2);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            color: white;
        }
        
        .matchup-ticker-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .matchup-ticker-arrow {
            background: var(--retro-gold);
            border: 2px solid #5d4037;
            border-radius: 4px;
            color: #5d4037;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 
                inset 0 -2px 0 rgba(0,0,0,0.2),
                inset 0 2px 0 rgba(255,255,255,0.3),
                1px 1px 2px rgba(0,0,0,0.2);
            flex-shrink: 0;
            position: relative;
        }
        
        /* CSS triangle arrows - no emoji issues */
        .matchup-ticker-arrow::before {
            content: '';
            display: block;
            width: 0;
            height: 0;
            border-style: solid;
        }
        
        .matchup-ticker-arrow.arrow-left::before {
            border-width: 5px 6px 5px 0;
            border-color: transparent #5d4037 transparent transparent;
        }
        
        .matchup-ticker-arrow.arrow-right::before {
            border-width: 5px 0 5px 6px;
            border-color: transparent transparent transparent #5d4037;
        }
        
        .matchup-ticker-arrow:hover {
            background: var(--retro-gold-light);
            transform: scale(1.1);
        }
        
        .matchup-ticker-arrow:active {
            transform: scale(0.95);
        }
        
        .matchup-ticker-scroll {
            display: flex;
            gap: 1rem;
            overflow-x: auto;
            padding: 0.5rem 0;
            scrollbar-width: none;
            flex: 1;
            scroll-snap-type: x mandatory;
        }
        
        .matchup-ticker-scroll::-webkit-scrollbar {
            display: none;
        }
        
        .matchup-ticker-item {
            flex: 0 0 calc((100% - 2rem) / 3);
            background: white;
            border-radius: 10px;
            padding: 0.75rem 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            min-width: 0;
            scroll-snap-align: start;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        
        .matchup-ticker-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .matchup-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
            flex: 1;
            min-width: 0;
        }
        
        .matchup-team-logo {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 50%;
            background: #f0f0f0;
            border: 2px solid #e0e0e0;
        }
        
        .matchup-team-name {
            color: #333;
            font-size: 0.6rem;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            font-weight: 500;
        }
        
        .matchup-team-manager {
            color: #666;
            font-size: 0.55rem;
        }
        
        .matchup-score-box {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.3rem 0.5rem;
            background: var(--retro-blue);
            border-radius: 6px;
            flex-shrink: 0;
        }
        
        .matchup-score {
            color: white;
            font-weight: 700;
            font-size: 0.85rem;
            min-width: 30px;
            text-align: center;
        }
        
        .matchup-score.winner {
            color: #4ade80;
        }
        
        .matchup-vs {
            color: rgba(255,255,255,0.6);
            font-size: 0.65rem;
        }
        
        /* Matchup Popup Modal */
        .matchup-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        
        .matchup-popup-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .matchup-popup {
            background: white;
            border-radius: 12px;
            width: 95%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.2s ease;
        }
        
        .matchup-popup-overlay.active .matchup-popup {
            transform: scale(1);
        }
        
        .matchup-popup-header {
            background: var(--retro-blue);
            color: white;
            padding: 1rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
        }
        
        .matchup-popup-title {
            font-size: 1.1rem;
            font-weight: 700;
        }
        
        .matchup-popup-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
        }
        
        .matchup-popup-close:hover {
            opacity: 1;
        }
        
        .matchup-popup-scoreboard {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1.5rem;
            padding: 1.25rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .matchup-popup-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            max-width: 200px;
        }
        
        .matchup-popup-team-logo {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid #e0e0e0;
        }
        
        .matchup-popup-team.winner .matchup-popup-team-logo {
            border-color: var(--retro-green);
        }
        
        .matchup-popup-team-name {
            font-weight: 600;
            font-size: 0.9rem;
            text-align: center;
            color: #333;
        }
        
        .matchup-popup-team-manager {
            font-size: 0.75rem;
            color: #666;
        }
        
        .matchup-popup-team-score {
            font-size: 1.8rem;
            font-weight: 700;
            color: #333;
        }
        
        .matchup-popup-team.winner .matchup-popup-team-score {
            color: var(--retro-green);
        }
        
        .matchup-popup-vs {
            font-size: 1rem;
            font-weight: 600;
            color: #999;
        }
        
        .matchup-popup-body {
            padding: 1rem 1.25rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        
        .matchup-popup-team-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        
        .matchup-popup-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--retro-blue);
        }
        
        .matchup-popup-section-title {
            font-weight: 600;
            color: var(--retro-blue);
            font-size: 0.9rem;
        }
        
        /* Add Tracker Dots */
        .add-tracker {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .add-tracker-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .add-tracker-label {
            font-size: 0.6rem;
            color: #666;
            margin-right: 0.15rem;
        }
        
        .add-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 2px solid;
            background: white;
        }
        
        .add-dot.stream {
            border-color: #9333ea;
        }
        
        .add-dot.stream.used {
            background: #9333ea;
        }
        
        .add-dot.regular {
            border-color: var(--retro-blue);
        }
        
        .add-dot.regular.used {
            background: var(--retro-blue);
        }
        
        /* Top Players List */
        .matchup-popup-players-section {
            margin-bottom: 0.75rem;
        }
        
        .matchup-popup-players-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #666;
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .matchup-popup-player {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .matchup-popup-player:last-child {
            border-bottom: none;
        }
        
        .matchup-popup-player-headshot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }
        
        .matchup-popup-player-pos {
            font-size: 0.6rem;
            font-weight: 600;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            color: white;
            min-width: 22px;
            text-align: center;
        }
        
        .matchup-popup-player-pos.C { background: #e74c3c; }
        .matchup-popup-player-pos.1B { background: #3498db; }
        .matchup-popup-player-pos.2B { background: #2ecc71; }
        .matchup-popup-player-pos.3B { background: #9b59b6; }
        .matchup-popup-player-pos.SS { background: #f39c12; }
        .matchup-popup-player-pos.OF { background: #1abc9c; }
        .matchup-popup-player-pos.Util { background: #7f8c8d; }
        .matchup-popup-player-pos.SP { background: #9333ea; }
        .matchup-popup-player-pos.RP { background: #e91e63; }
        .matchup-popup-player-pos.P { background: #9333ea; }
        
        .matchup-popup-player-name {
            flex: 1;
            font-size: 0.75rem;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .matchup-popup-player-pts {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--retro-blue);
            min-width: 35px;
            text-align: right;
        }
        
        /* Adds Section */
        .matchup-popup-adds-section {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px dashed #ddd;
        }
        
        .matchup-popup-adds-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.4rem;
        }
        
        .matchup-popup-adds-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #888;
        }
        
        .matchup-popup-adds-total {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--retro-green);
        }
        
        .matchup-popup-add-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.25rem 0;
            font-size: 0.7rem;
            color: #666;
        }
        
        .matchup-popup-add-item .add-indicator {
            color: var(--retro-green);
            font-weight: 600;
        }
        
        @media (max-width: 600px) {
            .matchup-popup-body {
                grid-template-columns: 1fr;
            }
            
            .matchup-popup-scoreboard {
                gap: 1rem;
            }
            
            .matchup-popup-team-logo {
                width: 50px;
                height: 50px;
            }
            
            .matchup-popup-team-score {
                font-size: 1.4rem;
            }
        }
        
        /* Roster Modal */
        .roster-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        
        .roster-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .roster-modal {
            background: white;
            border-radius: 12px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            transform: scale(0.9);
            transition: transform 0.2s ease;
        }
        
        .roster-modal-overlay.active .roster-modal {
            transform: scale(1);
        }
        
        .roster-modal-header {
            background: var(--retro-blue);
            color: white;
            padding: 1rem 1.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .roster-modal-team-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .roster-modal-team-logo {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .roster-modal-team-details h3 {
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0;
        }
        
        .roster-modal-team-details .manager-name {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 2px;
        }
        
        .roster-modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            opacity: 0.8;
        }
        
        .roster-modal-close:hover {
            opacity: 1;
        }
        
        .roster-modal-body {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
        }
        
        .roster-section {
            padding: 1rem;
        }
        
        .roster-section:first-child {
            border-right: 1px solid #e0e0e0;
        }
        
        .roster-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--retro-blue);
        }
        
        .roster-section-header h4 {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--retro-blue);
            margin: 0;
        }
        
        .roster-section-header .section-icon {
            font-size: 1rem;
        }
        
        .roster-position-group {
            margin-bottom: 0.5rem;
        }
        
        .roster-position-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
            padding-left: 2px;
        }
        
        .roster-player-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 0.25rem;
            transition: background 0.15s;
        }
        
        .roster-player-row:hover {
            background: #e9ecef;
        }
        
        .roster-player-row.empty {
            background: #f0f0f0;
            border: 1px dashed #ccc;
        }
        
        .roster-player-row.empty .roster-player-name {
            color: #999;
            font-style: italic;
        }
        
        .roster-player-row > .position-badge {
            flex-shrink: 0;
            min-width: 28px;
        }
        
        .roster-player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
            flex-shrink: 0;
        }
        
        .roster-player-info {
            flex: 1;
            min-width: 0;
        }
        
        .roster-player-name-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .roster-player-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .roster-player-name-row .keeper-badge {
            margin-left: 0;
        }
        
        .roster-player-mlb-team {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.65rem;
            color: #888;
            margin-top: 1px;
        }
        
        .roster-mlb-logo {
            width: 14px;
            height: 14px;
            object-fit: contain;
        }
        
        .roster-player-stats {
            text-align: right;
            flex-shrink: 0;
        }
        
        .roster-player-points {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--retro-blue);
        }
        
        .roster-player-rank {
            font-size: 0.6rem;
            color: #888;
        }
        
        /* Projected points indicator */
        .roster-player-points.projected {
            color: #666;
            font-style: italic;
        }
        
        /* Prospects section */
        .roster-prospects-group {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dashed #ccc;
        }
        
        .roster-prospects-group .roster-position-label {
            color: #888;
            font-style: italic;
        }
        
        .roster-player-row.prospect {
            opacity: 0.8;
        }
        
        @media (max-width: 700px) {
            .roster-modal-body {
                grid-template-columns: 1fr;
            }
            
            .roster-section:first-child {
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
            }
            
            .roster-modal-team-logo {
                width: 35px;
                height: 35px;
            }
            
            .roster-modal-team-details h3 {
                font-size: 0.95rem;
            }
            
            .roster-player-headshot {
                width: 28px;
                height: 28px;
            }
        }
        
        /* Mini Standings Table */
        .mini-standings-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        
        .mini-standings-table th {
            text-align: left;
            padding: 0.4rem 0.3rem;
            border-bottom: 2px solid var(--retro-blue);
            color: var(--retro-blue);
            font-weight: 600;
            font-size: 0.7rem;
            white-space: nowrap;
        }
        
        .mini-standings-table th:not(:first-child) {
            text-align: center;
        }
        
        .mini-standings-table td {
            padding: 0.35rem 0.3rem;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
        }
        
        .mini-standings-table td:not(:first-child) {
            text-align: center;
        }
        
        .mini-standings-team {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .mini-standings-rank {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--retro-blue);
            color: white;
            border-radius: 50%;
            font-size: 0.6rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .mini-standings-rank.gold { background: #ffd700; color: #000; }
        .mini-standings-rank.silver { background: #c0c0c0; color: #000; }
        .mini-standings-rank.bronze { background: #cd7f32; color: #fff; }
        
        .mini-standings-hat {
            width: 32px;
            height: 32px;
            object-fit: contain;
            flex-shrink: 0;
        }
        
        .mini-standings-manager {
            font-weight: 500;
            color: #333;
            font-size: 0.75rem;
        }
        
        /* Top Teams Table */
        .top-teams-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        
        .top-teams-table th {
            text-align: left;
            padding: 0.4rem 0.3rem;
            border-bottom: 2px solid var(--retro-blue);
            color: var(--retro-blue);
            font-weight: 600;
            font-size: 0.7rem;
        }
        
        .top-teams-table th:last-child {
            text-align: right;
        }
        
        .top-teams-table td {
            padding: 0.35rem 0.3rem;
            border-bottom: 1px solid #eee;
        }
        
        .top-teams-table td:last-child {
            text-align: right;
            font-weight: 600;
        }
        
        .top-teams-team {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .top-teams-rank {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--retro-blue);
            color: white;
            border-radius: 50%;
            font-size: 0.6rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .top-teams-logo {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #f0f0f0;
            flex-shrink: 0;
        }
        
        .top-teams-info {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .top-teams-name {
            font-weight: 500;
            font-size: 0.75rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .top-teams-manager {
            font-size: 0.65rem;
            color: #666;
        }
        
        /* Top Players Table */
        .top-players-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }
        
        .top-players-table th {
            text-align: left;
            padding: 0.4rem 0.3rem;
            border-bottom: 2px solid var(--retro-blue);
            color: var(--retro-blue);
            font-weight: 600;
            font-size: 0.7rem;
        }
        
        .top-players-table th:last-child {
            text-align: right;
        }
        
        .top-players-table td {
            padding: 0.35rem 0.3rem;
            border-bottom: 1px solid #eee;
        }
        
        .top-players-table td:last-child {
            text-align: right;
            font-weight: 600;
            color: #22c55e;
        }
        
        .top-players-player {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .top-players-rank {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--retro-blue);
            color: white;
            border-radius: 50%;
            font-size: 0.6rem;
            font-weight: 600;
            flex-shrink: 0;
        }
        
        .top-players-rank.gold { background: #ffd700; color: #000; }
        .top-players-rank.silver { background: #c0c0c0; color: #000; }
        .top-players-rank.bronze { background: #cd7f32; color: #fff; }
        
        .top-players-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #f0f0f0;
            flex-shrink: 0;
        }
        
        .top-players-info {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }
        
        .top-players-name {
            font-weight: 500;
            font-size: 0.75rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .top-players-team {
            font-size: 0.65rem;
            color: #666;
        }
        
        /* Projected top players (preseason) */
        .top-players-player > .position-badge {
            flex-shrink: 0;
            min-width: 24px;
            font-size: 0.6rem;
        }
        
        .top-players-mlb-team {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.6rem;
            color: #888;
        }
        
        .top-players-mlb-logo {
            width: 14px;
            height: 14px;
            object-fit: contain;
        }
        
        .top-players-table td.projected-pts {
            color: #666;
            font-style: italic;
        }
        
        /* Transactions Ticker - Vertical */
        .transactions-ticker {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .transactions-ticker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.75rem;
        }
        
        .transactions-ticker-title {
            font-weight: 600;
            color: var(--retro-blue);
            font-size: 1rem;
        }
        
        .transactions-ticker-wrapper {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .transactions-ticker-arrow {
            background: var(--retro-gold);
            border: 2px solid #5d4037;
            border-radius: 4px;
            color: #5d4037;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 
                inset 0 -2px 0 rgba(0,0,0,0.2),
                inset 0 2px 0 rgba(255,255,255,0.3),
                1px 1px 2px rgba(0,0,0,0.2);
            flex-shrink: 0;
            position: relative;
        }
        
        /* CSS triangle arrows - no emoji issues */
        .transactions-ticker-arrow::before {
            content: '';
            display: block;
            width: 0;
            height: 0;
            border-style: solid;
        }
        
        .transactions-ticker-arrow.arrow-left::before {
            border-width: 5px 6px 5px 0;
            border-color: transparent #5d4037 transparent transparent;
        }
        
        .transactions-ticker-arrow.arrow-right::before {
            border-width: 5px 0 5px 6px;
            border-color: transparent transparent transparent #5d4037;
        }
        
        .transactions-ticker-arrow:hover {
            background: var(--retro-gold-light);
            transform: scale(1.1);
        }
        
        .transactions-ticker-arrow:active {
            transform: scale(0.95);
        }
        
        .transactions-list {
            display: flex;
            gap: 0.5rem;
            flex: 1;
            overflow: hidden;
        }
        
        .transaction-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: white;
            border-radius: 8px;
            font-size: 0.8rem;
            border-left: 3px solid var(--retro-blue);
            flex-shrink: 0;
            min-width: 280px;
            max-width: 350px;
        }
        
        .transaction-item.trans-add {
            border-left-color: #22c55e;
        }
        
        .transaction-item.trans-drop {
            border-left-color: #ef4444;
        }
        
        .transaction-item.trans-trade {
            border-left-color: #f59e0b;
        }
        
        .transaction-item.trans-add-drop {
            border-left-color: #8b5cf6;
        }
        
        .transaction-icon {
            font-size: 1rem;
            font-weight: 700;
            width: 20px;
            text-align: center;
        }
        
        .transaction-content {
            flex: 1;
            min-width: 0;
        }
        
        .transaction-player {
            font-weight: 600;
            color: var(--retro-blue);
        }
        
        .transaction-details {
            color: #666;
            font-size: 0.75rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .transaction-time {
            color: #999;
            font-size: 0.7rem;
            white-space: nowrap;
        }
        
        /* Homepage placeholder message */
        .homepage-placeholder {
            text-align: center;
            padding: 2rem;
            color: #666;
            font-style: italic;
        }
        
        /* Responsive */
        @media (max-width: 1100px) {
            .homepage-three-columns {
                grid-template-columns: 1fr 1fr;
            }
            
            .homepage-three-columns .homepage-column:nth-child(3) {
                grid-column: 1 / -1;
            }
            
            .matchup-ticker-item {
                flex: 0 0 calc((100% - 1rem) / 2);
            }
        }
        
        @media (max-width: 700px) {
            .homepage-three-columns {
                grid-template-columns: 1fr;
            }
            
            .matchup-ticker-item {
                flex: 0 0 100%;
            }
            
            .transaction-item {
                min-width: 250px;
            }
        }
        
        @media (max-width: 500px) {
            .matchup-ticker-item {
                padding: 0.5rem;
            }
            
            .matchup-team-logo {
                width: 32px;
                height: 32px;
            }
        }
    </style>
</head>

<body>
    <header class="desktop-header">
        <div class="header-container">
            <picture>
                <source srcset="header_long.png" media="(min-width: 1200px)">
                <img src="header_short.png" alt="Fantasy Baseball Civil War - Established 2017 - 12 Team Points League"
                    class="header-banner">
            </picture>
            <a href="https://baseball.fantasysports.yahoo.com/league/fantasybaseballcivilwar/2026" target="_blank"
                class="header-league-link" title="Go to Yahoo Fantasy League"></a>
        </div>
    </header>

    <header class="mobile-header">
        <div class="mobile-header-container">
            <img src="mobile_header.png" alt="Fantasy Baseball Civil War" class="mobile-header-banner">
            <a href="https://baseball.fantasysports.yahoo.com/league/fantasybaseballcivilwar/2026" target="_blank"
                class="mobile-zone zone-logo" title="Go to Yahoo Fantasy League"></a>
            <div class="mobile-zone zone-menu" onclick="toggleMobileMenu()" title="Menu"></div>
        </div>
    </header>

    <!-- Mobile Slide-in Menu -->
    <div class="mobile-menu-overlay" onclick="closeMobileMenu()"></div>
    <aside class="mobile-menu">
        <div class="mobile-menu-header">
            <span>Menu</span>
            <button class="mobile-menu-close" onclick="closeMobileMenu()">&times;</button>
        </div>
        <div class="mobile-menu-items">
            <div class="mobile-menu-item" onclick="showSection('home'); closeMobileMenu();">
                <img src="data/page_logos/home_logo.png" alt="Home">
                <span>Home</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('standings'); closeMobileMenu();">
                <img src="data/page_logos/seasons_logo.png" alt="Seasons">
                <span>Seasons</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('awards'); closeMobileMenu();">
                <img src="data/page_logos/awards_logo.png" alt="Awards">
                <span>Awards</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('champions'); closeMobileMenu();">
                <img src="data/page_logos/hall_of_champions_logo.png" alt="Hall of Champions">
                <span>Hall of Champions</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('scoring'); closeMobileMenu();">
                <img src="data/page_logos/player_scoring_logo.png" alt="Player Scoring">
                <span>Player Scoring</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('managers'); closeMobileMenu();">
                <img src="data/page_logos/manager_profiles_logo.png" alt="Manager Profiles">
                <span>Manager Profiles</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('preseason'); closeMobileMenu();">
                <img src="data/page_logos/preseason_tools_logo.png" alt="Preseason Tools">
                <span>Preseason Tools</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('valuesuite'); closeMobileMenu();">
                <img src="data/page_logos/value_suite_logo.png" alt="Value Suite">
                <span>Value Suite</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('sportsbook'); closeMobileMenu();">
                <img src="data/page_logos/sportsbook_logo.png" alt="Sportsbook">
                <span>Sportsbook</span>
            </div>
            <div class="mobile-menu-item" onclick="showSection('bylaws'); closeMobileMenu();">
                <img src="data/page_logos/bylaws_logo.png" alt="Bylaws">
                <span>Bylaws</span>
            </div>
        </div>
    </aside>

    <!-- Old top nav - hidden -->
    <nav class="top-nav">
        <button onclick="showSection('home')" class="nav-btn active">Home</button>
        <button onclick="showSection('standings')" class="nav-btn">Seasons</button>
        <button onclick="showSection('awards')" class="nav-btn">Awards</button>
        <button onclick="showSection('champions')" class="nav-btn">Hall of Champions</button>
        <button onclick="showSection('scoring')" class="nav-btn">Player Scoring</button>
        <button onclick="showSection('managers')" class="nav-btn">Manager Profiles</button>
        <button onclick="showSection('preseason')" class="nav-btn">Preseason Tools</button>
        <button onclick="showSection('valuesuite')" class="nav-btn">Value Suite</button>
        <button onclick="showSection('sportsbook')" class="nav-btn">Sportsbook</button>
        <button onclick="showSection('bylaws')" class="nav-btn">Bylaws</button>
    </nav>

    <!-- Side Navigation -->
    <aside class="side-nav">
        <div class="side-nav-item active" onclick="showSection('home')">
            <img src="data/page_logos/home_logo.png" alt="Home">
            <span class="side-nav-tooltip">Home</span>
        </div>
        <div class="side-nav-item" onclick="showSection('standings')">
            <img src="data/page_logos/seasons_logo.png" alt="Seasons" loading="eager" decoding="async">
            <span class="side-nav-tooltip">Seasons</span>
        </div>
        <div class="side-nav-item" onclick="showSection('awards')">
            <img src="data/page_logos/awards_logo.png" alt="Awards" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Awards</span>
        </div>
        <div class="side-nav-item" onclick="showSection('champions')">
            <img src="data/page_logos/hall_of_champions_logo.png" alt="Hall of Champions" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Hall of Champions</span>
        </div>
        <div class="side-nav-item" onclick="showSection('scoring')">
            <img src="data/page_logos/player_scoring_logo.png" alt="Player Scoring" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Player Scoring</span>
        </div>
        <div class="side-nav-item" onclick="showSection('managers')">
            <img src="data/page_logos/manager_profiles_logo.png" alt="Manager Profiles" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Manager Profiles</span>
        </div>
        <div class="side-nav-item" onclick="showSection('preseason')">
            <img src="data/page_logos/preseason_tools_logo.png" alt="Preseason Tools" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Preseason Tools</span>
        </div>
        <div class="side-nav-item" onclick="showSection('valuesuite')">
            <img src="data/page_logos/value_suite_logo.png" alt="Value Suite" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Value Suite</span>
        </div>
        <div class="side-nav-item" onclick="showSection('prospects')">
            <img src="data/page_logos/prospect_pavilion_logo.png" alt="Prospect Pavilion" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Prospect Pavilion</span>
        </div>
        <div class="side-nav-item" onclick="showSection('sportsbook')">
            <img src="data/page_logos/sportsbook_logo.png" alt="Sportsbook" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">Sportsbook</span>
        </div>
        <div class="side-nav-item" onclick="showSection('bylaws')">
            <img src="data/page_logos/bylaws_logo.png" alt="Bylaws" loading="lazy" decoding="async">
            <span class="side-nav-tooltip">League Bylaws</span>
        </div>
    </aside>

    <div class="container">
        <!-- Homepage Section -->
        <div id="home" class="section active">
            <div class="home-header">
                <h2>Home</h2>
                <!-- Green Monster Top Scoring Day -->
                <div class="green-monster-ticker" id="green-monster-ticker" style="display: none;">
                    <span class="green-monster-label">2026 Top<br>Scoring Day</span>
                    <div class="green-monster-display">
                        <img class="green-monster-logo" id="green-monster-logo" src="league_logo.png" alt="">
                        <div class="green-monster-scoreboard">
                            <div class="green-monster-date" id="green-monster-date"></div>
                            <div class="green-monster-score" id="green-monster-score"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Matchup Ticker -->
            <div class="matchup-ticker-container">
                <div class="matchup-ticker-header">
                    <div class="matchup-ticker-title">Current Matchups</div>
                    <div class="matchup-ticker-week" id="home-matchup-week">Week 1</div>
                </div>
                <div class="matchup-ticker-wrapper">
                    <button class="matchup-ticker-arrow arrow-left" onclick="scrollMatchupTicker(-1)" title="Previous"></button>
                    <div class="matchup-ticker-scroll" id="home-matchup-ticker">
                        <div class="homepage-placeholder">Loading matchups...</div>
                    </div>
                    <button class="matchup-ticker-arrow arrow-right" onclick="scrollMatchupTicker(1)" title="Next"></button>
                </div>
            </div>
            
            <!-- Matchup Popup Modal -->
            <div class="matchup-popup-overlay" id="matchup-popup-overlay" onclick="closeMatchupPopup(event)">
                <div class="matchup-popup" onclick="event.stopPropagation()">
                    <div class="matchup-popup-header">
                        <div class="matchup-popup-title">Week <span id="matchup-popup-week">1</span> Matchup</div>
                        <button class="matchup-popup-close" onclick="closeMatchupPopup()">&times;</button>
                    </div>
                    <div class="matchup-popup-scoreboard" id="matchup-popup-scoreboard">
                        <!-- Filled dynamically -->
                    </div>
                    <div class="matchup-popup-body" id="matchup-popup-body">
                        <!-- Filled dynamically -->
                    </div>
                </div>
            </div>
            
            <!-- Roster Modal -->
            <div class="roster-modal-overlay" id="roster-modal-overlay" onclick="closeRosterModal(event)">
                <div class="roster-modal" onclick="event.stopPropagation()">
                    <div class="roster-modal-header">
                        <div class="roster-modal-team-info">
                            <img id="roster-modal-logo" class="roster-modal-team-logo" src="" alt="">
                            <div class="roster-modal-team-details">
                                <h3 id="roster-modal-team-name">Team Name</h3>
                                <div class="manager-name" id="roster-modal-manager">Manager</div>
                            </div>
                        </div>
                        <button class="roster-modal-close" onclick="closeRosterModal()">&times;</button>
                    </div>
                    <div class="roster-modal-body" id="roster-modal-body">
                        <!-- Filled dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="homepage-layout">
                <!-- Three Column Layout -->
                <div class="homepage-three-columns">
                    <!-- Column 1: Standings -->
                    <div class="homepage-column">
                        <div class="homepage-column-header">
                            <div class="homepage-column-title">Standings</div>
                        </div>
                        <table class="mini-standings-table">
                            <thead>
                                <tr>
                                    <th>Team</th>
                                    <th>W-L</th>
                                    <th>PF</th>
                                </tr>
                            </thead>
                            <tbody id="home-standings-body">
                                <tr><td colspan="3" class="homepage-placeholder">Loading standings...</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Column 2: Top Teams -->
                    <div class="homepage-column">
                        <div class="homepage-column-header">
                            <div class="homepage-column-title">Top Teams on <span id="home-top-teams-date">1/18</span></div>
                        </div>
                        <table class="top-teams-table">
                            <thead>
                                <tr>
                                    <th>Team</th>
                                    <th>Pts</th>
                                </tr>
                            </thead>
                            <tbody id="home-top-teams-body">
                                <tr><td colspan="2" class="homepage-placeholder">Loading top teams...</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Column 3: Top Players -->
                    <div class="homepage-column">
                        <div class="homepage-column-header">
                            <div class="homepage-column-title">Top Players</div>
                        </div>
                        <table class="top-players-table">
                            <thead>
                                <tr>
                                    <th>Player</th>
                                    <th>Pts</th>
                                </tr>
                            </thead>
                            <tbody id="home-top-players-body">
                                <tr><td colspan="2" class="homepage-placeholder">Loading top players...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Transactions Ticker (horizontal scroll) -->
                <div class="transactions-ticker">
                    <div class="transactions-ticker-header">
                        <div class="transactions-ticker-title">Recent Transactions</div>
                    </div>
                    <div class="transactions-ticker-wrapper">
                        <button class="transactions-ticker-arrow arrow-left" onclick="scrollTransactionsTicker(-1)" title="Previous"></button>
                        <div class="transactions-list" id="home-transactions-list">
                            <div class="homepage-placeholder">Loading transactions...</div>
                        </div>
                        <button class="transactions-ticker-arrow arrow-right" onclick="scrollTransactionsTicker(1)" title="Next"></button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Seasons Section -->
        <div id="standings" class="section">
            <h2>Seasons</h2>

            <div class="season-selector">
                <label for="standings-season">Select Season:</label>
                <select id="standings-season" onchange="loadStandingsBySeason()">
                    <!-- Will be populated dynamically -->
                </select>
                
                <!-- Week Selector (only shown for 2026) -->
                <div id="header-week-selector" class="header-week-selector" style="display: none;">
                    <span class="week-label">Week:</span>
                    <div class="mario-week-control">
                        <button class="mario-arrow mario-up" onclick="changeHeaderWeek(1)" title="Next Week"></button>
                        <span class="week-number" id="header-week-number" onclick="toggleWeekDropdown()" title="Click to select week">1</span>
                        <button class="mario-arrow mario-down" onclick="changeHeaderWeek(-1)" title="Previous Week"></button>
                        <div class="week-dropdown" id="week-dropdown">
                            <div class="week-dropdown-grid" id="week-dropdown-grid">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
                <div class="week-dropdown-overlay" id="week-dropdown-overlay" onclick="closeWeekDropdown()"></div>
            </div>

            <div id="standings-loading" class="loading">Loading standings...</div>
            <div id="standings-error" class="error" style="display: none;"></div>

            <!-- Container for standings and draft side by side -->
            <div class="standings-draft-container">
                <!-- Standings Table -->
                <div class="standings-panel">
                    <h3 class="panel-title" id="standings-panel-title">Final Standings</h3>
                    <div class="table-wrapper">
                        <table class="standings-table" id="standings-table" style="display: none;">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Manager</th>
                                    <th>Team Name</th>
                                    <th>Wins</th>
                                    <th>Losses</th>
                                    <th>Win %</th>
                                    <th>Total Points</th>
                                </tr>
                            </thead>
                            <tbody id="standings-body">
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Draft Results Table -->
                <div class="draft-panel">
                    <h3 class="panel-title">Draft Results</h3>
                    <div class="draft-table-wrapper">
                        <table class="draft-table" id="draft-table" style="display: none;">
                            <thead>
                                <tr>
                                    <th>Rd</th>
                                    <th>Pick</th>
                                    <th>Player</th>
                                    <th>Team</th>
                                    <th>Pts</th>
                                    <th>Rank</th>
                                </tr>
                            </thead>
                            <tbody id="draft-body">
                            </tbody>
                        </table>
                        <div id="draft-loading" class="loading" style="display: none;">Loading draft...</div>
                        <div id="draft-empty" class="draft-empty" style="display: none;">No draft data available</div>
                    </div>
                    
                    <!-- Draft Performance Ticker - placed under draft results -->
                    <div id="draft-performance-ticker" style="display: none; margin-top: 1rem;">
                        <h3 class="panel-title" style="font-size: 1rem;">Draft Grades</h3>
                        <div id="draft-performance-cards" class="draft-performance-grid">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                    
                    <!-- Weekly Matchups Ticker (for 2026 in-season) -->
                    <div id="matchups-ticker" style="display: none; margin-top: 1rem;">
                        <h3 class="panel-title" style="font-size: 1rem; margin-bottom: 0.5rem;">Week <span id="matchups-week-num">1</span> Matchups</h3>
                        <div id="matchups-cards" class="matchups-ticker-grid">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Playoff Bracket (for historical seasons) -->
            <div id="playoff-bracket-container" style="display: none; margin-top: 2rem;">
                <h3 style="color: var(--retro-blue); margin-bottom: 1rem; text-align: center;">Playoff Bracket</h3>
                <div id="playoff-bracket" class="playoff-bracket">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- Season Points Chart -->
            <div id="season-chart-container" style="display: none; margin-top: 2rem;">
                <div
                    style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem;">
                    <h3 style="color: var(--retro-blue); margin: 0;">Summary</h3>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label style="font-weight: bold; color: var(--retro-blue);">Scoring Type:</label>
                        <button id="btn-weekly" class="chart-toggle-btn active"
                            onclick="setChartType('weekly')">Weekly</button>
                        <button id="btn-total" class="chart-toggle-btn" onclick="setChartType('total')">Total</button>
                    </div>
                </div>
                <div id="season-chart"
                    style="position: relative; width: 100%; min-height: 500px; background: #fafafa; border-radius: 8px; overflow: visible;">
                </div>
            </div>
            
            <!-- 2026 In-Season Tools -->
            <div id="inseason-tools-container" style="display: none; margin-top: 2rem;">
                <!-- Top Performers Section -->
                <div class="inseason-section">
                    <h3 class="panel-title"> Top Performers <span id="top-performers-week-label" style="font-size: 0.85em; font-weight: normal;">(Week 1)</span></h3>
                    <div class="top-performers-grid">
                        <div class="performers-column">
                            <h4>Top Hitters</h4>
                            <div id="top-hitters-list" class="performers-list">
                                <div class="no-data">Season has not started</div>
                            </div>
                        </div>
                        <div class="performers-column">
                            <h4>Top Pitchers</h4>
                            <div id="top-pitchers-list" class="performers-list">
                                <div class="no-data">Season has not started</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Weekly Category Leaders -->
                <div class="inseason-section" style="margin-top: 1.5rem;">
                    <h3 class="panel-title"> Category Leaders <span id="category-leaders-week-label" style="font-size: 0.85em; font-weight: normal;">(Week 1)</span></h3>
                    <div class="category-leaders-grid" id="category-leaders-grid">
                        <div class="no-data">Season has not started</div>
                    </div>
                </div>
                
                <!-- Team Stats Heatmap -->
                <div class="inseason-section" style="margin-top: 1.5rem;">
                    <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem; margin-bottom: 1rem;">
                        <h3 class="panel-title" style="margin-bottom: 0;">Team Stats</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <button id="btn-hitting-stats" class="chart-toggle-btn active" onclick="setStatsType('hitting')">Hitting</button>
                            <button id="btn-pitching-stats" class="chart-toggle-btn" onclick="setStatsType('pitching')">Pitching</button>
                        </div>
                    </div>
                    <div id="team-stats-container">
                        <div class="stats-table-wrapper">
                            <table class="stats-heatmap-table" id="hitting-stats-table" style="display: none;">
                                <thead id="hitting-stats-header"></thead>
                                <tbody id="hitting-stats-body"></tbody>
                            </table>
                            <table class="stats-heatmap-table" id="pitching-stats-table" style="display: none;">
                                <thead id="pitching-stats-header"></thead>
                                <tbody id="pitching-stats-body"></tbody>
                            </table>
                        </div>
                        <div id="stats-no-data" class="no-data">Season has not started</div>
                    </div>
                    <div class="week-circles-container" style="margin-top: 1rem;">
                        <div class="week-circles" id="week-circles">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Awards Section -->
        <div id="awards" class="section">
            <h2>League Awards</h2>

            <div id="awards-loading" class="loading">Loading awards...</div>
            <div id="awards-error" class="error" style="display: none;"></div>

            <div id="awards-content" style="display: none;">
                <div class="awards-grid">
                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/reg_season_champion.png" alt="Regular Season Champion" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Regular Season Champion</span><span class="award-description">Most Wins</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Wins</th>
                                    </tr>
                                </thead>
                                <tbody id="regular-season-winners">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/scoring_champion.png" alt="Scoring Champion" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Scoring Champion</span><span class="award-description">Most Points</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="scoring-champions">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/garbage.png" alt="Garbage Award" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Garbage Award</span><span class="award-description">Worst Record</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Record</th>
                                    </tr>
                                </thead>
                                <tbody id="garbage-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/clown.png" alt="Clown Award"
                                    class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Clown Award</span><span class="award-description">Least Points</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="clown-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/hitter.png"
                                    alt="Mike Trout Award" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Mike Trout Award</span><span class="award-description">Highest Scoring Hitter</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="trout-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/pitcher.png"
                                    alt="Jacob deGrom Award" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Jacob deGrom Award</span><span class="award-description">Highest Scoring Pitcher</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="degrom-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/diamond.png" alt="Diamond in the Rough" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Diamond in the Rough Award</span><span class="award-description">Best Draft Value</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Pick</th>
                                        <th>+/-</th>
                                    </tr>
                                </thead>
                                <tbody id="diamond-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="data/awards/bust.png" alt="Bust of the Year" class="award-header-image"></span> <span class="award-title-wrapper"><span class="award-name">Bust of the Year Award</span><span class="award-description">Worst Draft Value</span></span></h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Pick</th>
                                        <th>+/-</th>
                                    </tr>
                                </thead>
                                <tbody id="bust-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hall of Champions Section -->
        <div id="champions" class="section">
            <h2>Hall of Champions</h2>

            <!-- Championship Logo Selector - will be populated dynamically -->
            <div id="championship-logo-selector" class="championship-logo-selector">
                <!-- Logos will be inserted here by JavaScript -->
            </div>

            <!-- Hidden select for maintaining state -->
            <select id="champions-season" style="display: none;" onchange="loadChampionData()">
                <!-- Will be populated dynamically -->
            </select>

            <div id="champions-loading" class="loading">Loading champion data...</div>
            <div id="champions-error" class="error" style="display: none;"></div>

            <div id="champions-content" style="display: none;">
                <!-- Champion Header -->
                <div id="champion-header" class="champion-header">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Championship Count Banner -->
                <div id="championship-count-banner" class="championship-count-banner">
                    <!-- Will show "1st Championship", "2nd Championship", etc. -->
                </div>

                <!-- Champion Stats Grid -->
                <div class="champion-stats-grid">
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-record">-</div>
                        <div class="stat-label">Record</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-points">-</div>
                        <div class="stat-label">Total Points</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-ppg">-</div>
                        <div class="stat-label">Points/Week</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-best-week">-</div>
                        <div class="stat-label">Best Week</div>
                    </div>
                </div>

                <!-- Season Schedule -->
                <div class="champion-section">
                    <h3> Season Schedule</h3>
                    <div class="table-wrapper">
                        <table class="champion-schedule-table">
                            <thead>
                                <tr>
                                    <th>Week</th>
                                    <th>Opponent</th>
                                    <th>Score</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody id="champion-schedule">
                                <!-- Will be populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Championship Roster -->
                <div class="champion-section">
                    <h3> Championship Roster</h3>
                    <div class="roster-grid" id="champion-roster">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Player Scoring Section -->
        <div id="scoring" class="section">
            <h2>Player Scoring</h2>

            <div class="player-controls">
                <div class="player-control-row">
                    <div class="season-selector">
                        <label for="scoring-season">Season:</label>
                        <select id="scoring-season" onchange="loadPlayerScoring()">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>

                    <div class="stat-type-toggle">
                        <label>Stats:</label>
                        <div class="toggle-buttons">
                            <button id="fantasy-season-btn" class="toggle-btn active"
                                onclick="setStatType('fantasy')">Fantasy Season</button>
                            <button id="full-season-btn" class="toggle-btn" onclick="setStatType('full')">Full MLB
                                Season</button>
                        </div>
                    </div>

                    <div class="position-filter">
                        <label for="position-filter">Position:</label>
                        <select id="position-filter" onchange="filterPlayers()">
                            <option value="all">All Players</option>
                            <option value="B">All Batters</option>
                            <option value="P">All Pitchers</option>
                            <optgroup label="Batting Positions">
                                <option value="C">C - Catcher</option>
                                <option value="1B">1B - First Base</option>
                                <option value="2B">2B - Second Base</option>
                                <option value="3B">3B - Third Base</option>
                                <option value="SS">SS - Shortstop</option>
                                <option value="OF">OF - Outfield</option>
                                <option value="Util">Util - Utility</option>
                            </optgroup>
                            <optgroup label="Pitching Positions">
                                <option value="SP">SP - Starting Pitcher</option>
                                <option value="RP">RP - Relief Pitcher</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="manager-filter">
                        <label for="manager-filter">Manager:</label>
                        <select id="manager-filter" onchange="filterPlayers()">
                            <option value="all">All Managers</option>
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                    
                    <div class="player-controls-logo">
                        <img src="league_logo.png" alt="FBCW" class="player-controls-league-logo">
                    </div>
                </div>

                <div class="player-search">
                    <input type="text" id="player-search" placeholder="Search players..." oninput="filterPlayers()">
                </div>
            </div>

            <div id="player-loading" class="loading">Loading player data...</div>
            <div id="player-error" class="error" style="display: none;"></div>

            <div id="player-stats-container" style="display: none;">
                <div class="player-summary">
                    <span id="player-count">0 players</span>
                </div>

                <div class="table-wrapper player-table-wrapper">
                    <table class="player-table" id="player-table">
                        <thead>
                            <tr>
                                <th class="sortable" onclick="sortPlayerTable('rank')">#</th>
                                <th class="sortable" onclick="sortPlayerTable('name')">Player</th>
                                <th>Team</th>
                                <th class="sortable" onclick="sortPlayerTable('position')">Pos</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('PA')">PA</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                            </tr>
                        </thead>
                        <tbody id="player-table-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Player Detail Modal -->
        <div id="player-modal" class="modal">
            <div class="modal-content player-modal-content">
                <span class="modal-close" onclick="closePlayerModal()">&times;</span>
                <div id="player-modal-header">
                    <!-- Header loaded dynamically -->
                </div>
                <div class="modal-body-scroll" id="player-modal-body">
                    <!-- Body content loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- Projection Player Detail Modal -->
        <div id="projection-modal" class="modal">
            <div class="modal-content projection-modal-content">
                <span class="modal-close" onclick="closeProjectionModal()">&times;</span>
                <div class="projection-modal-layout">
                    <div class="projection-card-container" id="projection-card-container">
                        <!-- Baseball card loaded dynamically -->
                    </div>
                    <div class="projection-charts-container">
                        <div class="projection-chart-box">
                            <div class="projection-chart-title">Position Ranking</div>
                            <div class="projection-chart" id="projection-pos-chart">
                                <!-- Position rank chart -->
                            </div>
                        </div>
                        <div class="projection-chart-box">
                            <div class="projection-chart-title" id="projection-scatter-title">Points vs PA</div>
                            <div class="projection-chart" id="projection-scatter-chart">
                                <!-- Scatter plot -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Manager Profiles Section -->
        <div id="managers" class="section">
            <h2>Manager Profiles</h2>

            <div id="managers-loading" class="loading">Loading manager profiles...</div>
            <div id="managers-error" class="error" style="display: none;"></div>

            <div class="manager-grid" id="manager-grid">
            </div>

            <!-- Win Percentage Over Time Chart -->
            <div id="winpct-chart-container" style="display: none; margin-top: 2rem;">
                <h3 style="color: var(--retro-blue); margin-bottom: 1rem;">Win Percentage Over Time</h3>
                <div id="winpct-chart"
                    style="width: 100%; overflow-x: auto; background: white; border-radius: 8px; padding: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                </div>
            </div>
        </div>

        <!-- Preseason Tools Section -->
        <div id="preseason" class="section">
            <h2>Preseason Tools - Projected Points</h2>

            <div class="player-controls">
                <div class="player-control-row">
                    <div class="projection-selector">
                        <label for="projection-type">Projection System:</label>
                        <select id="projection-type" onchange="loadProjections()">
                            <option value="thebat">The BAT</option>
                            <option value="thebatx">The BAT X</option>
                            <option value="steamer">Steamer</option>
                            <option value="zips">ZiPS</option>
                            <option value="atc">ATC</option>
                            <option value="depthcharts">Depth Charts</option>
                            <option value="oopsy">OOPSY</option>
                        </select>
                    </div>

                    <div class="position-filter">
                        <label for="proj-position-filter">Position:</label>
                        <select id="proj-position-filter" onchange="filterProjections()">
                            <option value="all">All Players</option>
                            <option value="B">All Batters</option>
                            <option value="P">All Pitchers</option>
                            <optgroup label="Batting Positions">
                                <option value="C">C - Catcher</option>
                                <option value="1B">1B - First Base</option>
                                <option value="2B">2B - Second Base</option>
                                <option value="3B">3B - Third Base</option>
                                <option value="SS">SS - Shortstop</option>
                                <option value="OF">OF - Outfield</option>
                                <option value="DH">DH - Designated Hitter</option>
                            </optgroup>
                            <optgroup label="Pitching Positions">
                                <option value="SP">SP - Starting Pitcher</option>
                                <option value="RP">RP - Relief Pitcher</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="stat-type-toggle">
                        <label>Player Type:</label>
                        <div class="toggle-buttons">
                            <button id="proj-btn-all" class="toggle-btn active"
                                onclick="setProjectionPlayerType('all')">All</button>
                            <button id="proj-btn-batters" class="toggle-btn"
                                onclick="setProjectionPlayerType('batters')">Batters</button>
                            <button id="proj-btn-pitchers" class="toggle-btn"
                                onclick="setProjectionPlayerType('pitchers')">Pitchers</button>
                        </div>
                    </div>
                </div>

                <div class="player-search">
                    <input type="text" id="proj-player-search" placeholder="Search players..."
                        oninput="filterProjections()">
                </div>
            </div>

            <div id="proj-loading" class="loading" style="display: none;">Loading projections...</div>
            <div id="proj-error" class="error" style="display: none;"></div>
            <div id="proj-batx-notice" style="display: none; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 0.75rem 1rem; margin-bottom: 1rem; color: #856404;">
                <strong> Note:</strong> The BAT X only provides batting projections. Pitcher data is not available for this system.
            </div>
            <div id="proj-no-data" style="text-align: center; padding: 2rem; color: #666;">
                <p style="font-size: 1.1rem; margin-bottom: 1rem;">No projection data available yet.</p>
                <p>Run <code
                        style="background: #f0f0f0; padding: 0.2rem 0.5rem; border-radius: 4px;">python collect_data.py projections</code>
                    to generate projections.</p>
            </div>

            <div id="proj-stats-container" style="display: none;">
                <div class="player-summary" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span id="proj-player-count">0 players</span>
                        <button class="btn-export hide-mobile"
                            style="margin-left: 1rem; padding: 0.3rem 0.8rem; font-size: 0.8rem; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;"
                            onclick="exportProjectionsCSV()">Export CSV</button>
                        <button id="btn-toggle-kept" onclick="toggleKeptPlayers()"
                            style="margin-left: 0.5rem; padding: 0.3rem 0.8rem; font-size: 0.8rem; background: #e9ecef; color: #333; border: 1px solid #ced4da; border-radius: 4px; cursor: pointer;">Hide
                            Kept Players</button>
                    </div>
                    <button class="btn-select-keepers" onclick="openKeeperModal()"> Select Keepers</button>
                </div>

                <div class="proj-table-scrollable">
                    <table class="player-table" id="proj-table">
                        <thead id="proj-table-head">
                            <!-- Headers will be populated dynamically -->
                        </thead>
                        <tbody id="proj-table-body">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- League Keepers Section -->
            <div style="margin-top: 3rem; border-top: 2px solid #e0e0e0; padding-top: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <h3 style="color: var(--retro-blue); margin: 0;">League Keepers</h3>
                        <span id="firebase-status" class="firebase-status disconnected" title="Real-time sync status">
                            <span class="status-dot"></span>
                            <span class="status-text">Offline</span>
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn-adjust-budgets" onclick="openBudgetAdjustmentModal()"
                            title="Manually adjust team budgets">Adjust Budgets</button>
                        <button class="btn-toggle-prospects" id="btn-toggle-prospects"
                            onclick="toggleLeagueProspects()">
                            <span id="toggle-prospects-text">Show Prospects</span>
                        </button>
                    </div>
                </div>
                <div id="keeper-league-loading" class="loading" style="display: none;">Loading keepers...</div>
                <div id="keeper-league-container">
                    <div class="keeper-league-grid" id="keeper-league-grid">
                        <!-- Keeper cards for each team -->
                    </div>
                </div>
            </div>

            <!-- Projected Lineups Section -->
            <div class="projected-lineups-section" id="projected-lineups-section">
                <div class="projected-lineups-header">
                    <h3>Projected Lineups</h3>
                    <div class="projected-lineups-controls">
                        <div class="lineup-projection-selector">
                            <label for="lineup-projection-type">Projections:</label>
                            <select id="lineup-projection-type" onchange="updateLineupProjections()">
                                <option value="thebat">The BAT</option>
                                <option value="thebatx">The BAT X</option>
                                <option value="steamer">Steamer</option>
                                <option value="zips">ZiPS</option>
                                <option value="atc">ATC</option>
                                <option value="depthcharts">Depth Charts</option>
                                <option value="oopsy">OOPSY</option>
                            </select>
                        </div>
                        <button class="btn-show-lineup-prospects" id="btn-show-lineup-prospects" onclick="toggleLineupProspects()">
                            Show Prospects
                        </button>
                    </div>
                </div>
                
                <div id="lineup-batx-notice" style="display: none; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; padding: 0.75rem 1rem; margin-bottom: 1rem; color: #856404;">
                    <strong> Note:</strong> The BAT X only provides batting projections. Pitcher projections shown as "".
                </div>

                <div class="lineup-ticker-wrapper">
                    <button class="lineup-ticker-nav-btn" onclick="navigateLineupTicker(-1)"></button>
                    <div class="lineup-ticker-viewport">
                        <div class="lineup-ticker-track" id="lineup-ticker-track">
                            <!-- Lineup cards will be populated by JavaScript -->
                        </div>
                    </div>
                    <button class="lineup-ticker-nav-btn" onclick="navigateLineupTicker(1)"></button>
                </div>

                <div class="lineup-ticker-dots" id="lineup-ticker-dots">
                    <!-- Team logo dots will be populated by JavaScript -->
                </div>
            </div>

            <!-- Trade Management Section -->
            <div style="margin-top: 3rem; border-top: 2px solid #e0e0e0; padding-top: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="color: var(--retro-blue); margin: 0;">Trade Management</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn-export-trades" onclick="exportTradesForSite()"
                            title="Export JSON for GitHub"> Export for Site</button>
                        <button class="btn-new-trade" onclick="openTradeBuilder()">+ New Trade</button>
                    </div>
                </div>

                <!-- Existing Trades List - Scrollable -->
                <div id="trades-list-container" class="trades-list-scrollable">
                    <div id="trades-list" class="trades-list">
                        <!-- Trade cards will be populated here -->
                        <p class="no-trades" id="no-trades-msg">No trades recorded yet. Click "New Trade" to add one.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Value Suite Section -->
        <div id="valuesuite" class="section">
            <h2>Value Suite</h2>
            
            <div class="keeper-value-section" id="keeper-value-section">
                <div class="keeper-value-header">
                    <h3>Keeper Value Analysis</h3>
                    <div style="font-size: 0.85rem; color: #666;">
                        Comparing keeper projections vs. historical draft pick value (2019-2025)
                    </div>
                </div>

                <div id="keeper-value-loading" class="keeper-value-loading" style="display: none;">
                    Analyzing keeper values...
                </div>

                <div id="keeper-value-content">
                    <!-- Expected Points Chart + Rankings -->
                    <div class="expected-points-container">
                        <div class="expected-points-chart-wrapper">
                            <h4>Expected Points by Draft Round</h4>
                            <div class="expected-points-chart">
                                <canvas id="expected-points-chart"></canvas>
                            </div>
                        </div>
                        <div class="value-rankings-wrapper">
                            <h4>Team Value Rankings</h4>
                            <table class="value-rankings-table" id="value-rankings-table">
                                <thead>
                                    <tr>
                                        <th>Team</th>
                                        <th>Top Value Players</th>
                                        <th class="sortable-header" data-sort="keeperValue" onclick="sortValueRankings('keeperValue')">Keeper<br>Value <span class="sort-icon"></span></th>
                                        <th>Top Picks</th>
                                        <th class="sortable-header" data-sort="draftValue" onclick="sortValueRankings('draftValue')">Draft<br>Value <span class="sort-icon"></span></th>
                                        <th class="sortable-header active" data-sort="total" onclick="sortValueRankings('total')">Total <span class="sort-icon"></span></th>
                                    </tr>
                                </thead>
                                <tbody id="value-rankings-body">
                                    <!-- Populated by JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Position Value Chart -->
                    <div class="position-value-section" style="margin-top: 2rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h4 style="color: var(--retro-blue); margin: 0;">Position Value Analysis</h4>
                            <div class="chart-toggle" style="display: flex; gap: 0.5rem;">
                                <button id="pos-value-bar-btn" class="chart-toggle-btn active" onclick="setPositionValueChartType('bar')">Bar</button>
                                <button id="pos-value-line-btn" class="chart-toggle-btn" onclick="setPositionValueChartType('line')">Line</button>
                            </div>
                        </div>
                        <div style="font-size: 0.85rem; color: #666; margin-bottom: 0.75rem;">
                            Average projections for playable roster spots at each position (using average of all projection systems)
                        </div>
                        <div class="position-value-chart-container" style="position: relative; height: 400px; background: #fafafa; border-radius: 8px; padding: 1rem;">
                            <canvas id="position-value-chart"></canvas>
                        </div>
                    </div>

                    <!-- Team Value Cards -->
                    <h4 style="color: var(--retro-blue); margin: 1.5rem 0 1rem;">Team Keeper Breakdown</h4>
                    <div class="team-value-grid" id="team-value-grid">
                        <!-- Populated by JS -->
                    </div>

                    <!-- Prospects Section -->
                    <div class="prospects-value-section" id="prospects-value-section" style="display: none;">
                        <h4> Prospect Value (Free Keepers)</h4>
                        <p style="font-size: 0.85rem; color: #666; margin: 0 0 1rem;">
                            Prospects cost nothing to keep, so their entire projection is pure value.
                        </p>
                        <div class="prospects-grid" id="prospects-value-grid">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <!-- Scatter Plot - Projected Points -->
                    <div class="value-scatter-wrapper">
                        <h4>All Keepers: Projected Points vs. Keeper Cost</h4>
                        <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.75rem;">
                            Hover over points to see player details. Green = above expected, Red = below expected.
                        </div>
                        <div class="value-scatter-chart">
                            <canvas id="value-scatter-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Prospect Pavilion Section -->
        <div id="prospects" class="section">
            <h2>Prospect Pavilion</h2>
            
            <div class="prospect-controls">
                <div class="prospect-controls-left">
                    <label class="prospect-toggle">
                        <input type="checkbox" id="hide-owned-prospects" onchange="filterProspects()">
                        <span class="toggle-slider"></span>
                        <span class="toggle-label">Hide Owned Players</span>
                    </label>
                </div>
                <div class="prospect-controls-right">
                    <div class="prospect-search-container">
                        <input type="text" id="prospect-search" placeholder="Search prospects..." onkeyup="filterProspects()">
                    </div>
                    <select id="prospect-position-filter" onchange="filterProspects()">
                        <option value="">All Positions</option>
                        <option value="C">C</option>
                        <option value="1B">1B</option>
                        <option value="2B">2B</option>
                        <option value="3B">3B</option>
                        <option value="SS">SS</option>
                        <option value="OF">OF</option>
                        <option value="P">P</option>
                    </select>
                </div>
            </div>
            
            <div class="prospect-stats-bar">
                <span id="prospect-count">Loading...</span>
                <span id="prospect-owned-count"></span>
            </div>
            
            <div class="prospect-table-container">
                <table class="prospect-table" id="prospect-table">
                    <thead>
                        <tr>
                            <th class="prospect-col-rank">Rank</th>
                            <th class="prospect-col-player">Player</th>
                            <th class="prospect-col-pos">Pos</th>
                            <th class="prospect-col-details">Details</th>
                            <th class="prospect-col-owner">Owner</th>
                        </tr>
                    </thead>
                    <tbody id="prospect-table-body">
                        <tr><td colspan="5" class="prospect-loading">Loading prospects...</td></tr>
                    </tbody>
                </table>
            </div>
            
            <div class="prospect-footer">
                <p>Rankings aggregated from multiple industry sources. Headshots from MLB.com.</p>
            </div>
        </div>

        <!-- Sportsbook Section -->
        <div id="sportsbook" class="section">
            <h2>King Dylan's Sportsbook</h2>
            
            <!-- Not Logged In State -->
            <div id="sportsbook-not-logged-in" class="sportsbook-not-logged-in">
                <h3> Welcome to King Dylan's Sportsbook</h3>
                <p>Place bets on season outcomes and weekly matchups using your units!</p>
                <button class="sportsbook-login-btn" onclick="openSportsbookLogin()">
                     Select Your Team to Continue
                </button>
            </div>
            
            <!-- Logged In State -->
            <div id="sportsbook-logged-in" style="display: none;">
                <div class="sportsbook-header">
                    <div class="sportsbook-tabs">
                        <button class="sportsbook-tab-btn active" onclick="switchSportsbookTab('sportsbook')"> Sportsbook</button>
                        <button class="sportsbook-tab-btn" onclick="switchSportsbookTab('history')"> Bet History</button>
                    </div>
                    <div class="sportsbook-user-info">
                        <img id="sportsbook-user-logo" class="sportsbook-user-logo" src="" alt="">
                        <div class="sportsbook-balance">
                            <span class="sportsbook-balance-label">Balance:</span>
                            <span class="sportsbook-balance-amount" id="sportsbook-balance">0</span>
                            <span class="sportsbook-balance-label">units</span>
                        </div>
                        <button class="sportsbook-logout-btn" onclick="logoutSportsbook()">Switch Team</button>
                    </div>
                </div>
                
                <!-- Sportsbook Tab -->
                <div id="sportsbook-tab-sportsbook" class="sportsbook-content active">
                    <div class="sportsbook-subtabs">
                        <button class="sportsbook-subtab-btn active" onclick="switchSportsbookSubtab('season')"> Season</button>
                        <button class="sportsbook-subtab-btn" onclick="switchSportsbookSubtab('weekly')"> Weekly</button>
                    </div>
                    
                    <!-- Season Bets -->
                    <div id="sportsbook-season-bets" class="sportsbook-content active">
                        <div class="season-bet-section">
                            <div class="season-bet-title">Team Totals</div>
                            <div class="team-totals-grid" id="team-totals-grid">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        
                        <div class="season-bet-section">
                            <div class="season-bet-title">FBCW Champion <span class="bet-info-btn" onclick="showBetStats('champion')" title="View betting stats">i</span></div>
                            <div class="season-bet-grid" id="season-bet-champion">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        
                        <div class="season-bet-section">
                            <div class="season-bet-title">Most Wins <span class="bet-info-btn" onclick="showBetStats('wins')" title="View betting stats">i</span></div>
                            <div class="season-bet-grid" id="season-bet-wins">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        
                        <div class="season-bet-section">
                            <div class="season-bet-title">Most Points <span class="bet-info-btn" onclick="showBetStats('points')" title="View betting stats">i</span></div>
                            <div class="season-bet-grid" id="season-bet-points">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                        
                        <div class="season-bet-section">
                            <div class="season-bet-title">Last Place <span class="bet-info-btn" onclick="showBetStats('last')" title="View betting stats">i</span></div>
                            <div class="season-bet-grid" id="season-bet-last">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Weekly Bets -->
                    <div id="sportsbook-weekly-bets" class="sportsbook-content">
                        <div class="weekly-bet-header">
                            <div class="weekly-bet-week-selector">
                                <label>Week:</label>
                                <select id="sportsbook-week-select" onchange="loadWeeklyMatchupBets()">
                                    <!-- Populated by JS -->
                                </select>
                            </div>
                        </div>
                        <div class="matchup-bet-grid" id="weekly-matchup-bets">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
                
                <!-- Bet History Tab -->
                <div id="sportsbook-tab-history" class="sportsbook-content">
                    <h3 style="color: var(--retro-blue); margin-bottom: 1rem;"> Your Bet History</h3>
                    <div class="bet-history-wrapper">
                        <table class="bet-history-table" id="bet-history-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Bet Type</th>
                                    <th>Selection</th>
                                    <th>Against</th>
                                    <th>Odds</th>
                                    <th>Wager</th>
                                    <th>Payout</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody id="bet-history-body">
                                <!-- Populated by JS -->
                            </tbody>
                        </table>
                    </div>
                    <div id="bet-history-empty" style="display: none; text-align: center; padding: 2rem; color: #666;">
                        No bets placed yet. Head to the Sportsbook to place your first wager!
                    </div>
                </div>
            </div>
        </div>

        <!-- Bylaws Section -->
        <div id="bylaws" class="section">
            <h2>League Bylaws</h2>
            
            <div class="bylaws-container">
                <div class="bylaws-main">
                    <div class="bylaws-content">
                        <div class="bylaws-header">
                            <h1>Fantasy Baseball Civil War Bylaws</h1>
                            <div class="bylaws-officers">
                                <div class="bylaws-officer">
                                    <div class="bylaws-officer-title">Commissioner</div>
                                    <div class="bylaws-officer-name">Josh Bookbinder</div>
                                </div>
                                <div class="bylaws-officer">
                                    <div class="bylaws-officer-title">Treasurer</div>
                                    <div class="bylaws-officer-name">Coleman Smith</div>
                                </div>
                                <div class="bylaws-officer">
                                    <div class="bylaws-officer-title">Chief Justice</div>
                                    <div class="bylaws-officer-name">Dylan DeSena</div>
                                </div>
                            </div>
                        </div>

                        <div class="bylaws-categories">
                            <h3>Categories</h3>
                            <ol>
                                <li><a href="#bylaws-league-construction">League Construction</a></li>
                                <li><a href="#bylaws-drafting">Drafting, Roster Construction, In-Season, Trading</a></li>
                                <li><a href="#bylaws-playoffs">Playoffs, Championships, Money Breakdown</a></li>
                                <li><a href="#bylaws-keepers">Keeper Rules</a></li>
                                <li><a href="#bylaws-na">NA Rules and NA Draft</a></li>
                            </ol>
                        </div>

                        <!-- Section I: League Construction -->
                        <div id="bylaws-league-construction" class="bylaws-section">
                            <h2 class="bylaws-section-title">I. League Construction</h2>
                            
                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">1.</span>
                                <span class="bylaws-rule-content"><strong>Size</strong> - There are 12 teams in this league.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">2.</span>
                                <span class="bylaws-rule-content"><strong>Type</strong> - This is a Head-to-Head Points type league. Each week, each team will play another team, and the team scoring more points receives one win for that week.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">3.</span>
                                <span class="bylaws-rule-content"><strong>Ties</strong> - Ties are incredibly rare but can happen. They will count as neither a win nor loss for either team.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">4.</span>
                                <span class="bylaws-rule-content"><strong>Scoring</strong> - Scoring categories are subject to change and can be changed in the offseason by league majority vote. Scoring is as follows:</span>
                                
                                <table class="bylaws-scoring-table">
                                    <tr class="bylaws-scoring-section"><td colspan="3">Batting</td></tr>
                                    <tr><td>Singles (1B)</td><td>1.1</td></tr>
                                    <tr><td>Doubles (2B)</td><td>2.2</td></tr>
                                    <tr><td>Triples (3B)</td><td>3.3</td></tr>
                                    <tr><td>Home Runs (HR)</td><td>4.4</td></tr>
                                    <tr><td>Runs Batted In (RBI)</td><td>1</td></tr>
                                    <tr><td>Stolen Bases (SB)</td><td>2</td></tr>
                                    <tr><td>Caught Stealing (CS)</td><td>-1</td></tr>
                                    <tr><td>Walks (BB)</td><td>1</td></tr>
                                    <tr><td>Hit By Pitch (HBP)</td><td>1</td></tr>
                                    <tr><td>Strikeouts (K)</td><td>-0.5</td></tr>
                                    <tr><td>Hitting for the Cycle (CYC)</td><td>5</td></tr>
                                    <tr><td>Grand Slam Home Runs (SLAM)</td><td>2</td></tr>
                                    <tr class="bylaws-scoring-section"><td colspan="3">Pitching</td></tr>
                                    <tr><td>Innings Pitched (IP)</td><td>2.5</td></tr>
                                    <tr><td>Wins (W)</td><td>2.5</td></tr>
                                    <tr><td>Losses (L)</td><td>-3</td></tr>
                                    <tr><td>Complete Games (CG)</td><td>5</td></tr>
                                    <tr><td>Shutouts (SHO)</td><td>5</td></tr>
                                    <tr><td>Saves (SV)</td><td>5</td></tr>
                                    <tr><td>Hits Allowed (H)</td><td>-0.75</td></tr>
                                    <tr><td>Earned Runs (ER)</td><td>-1.75</td></tr>
                                    <tr><td>Walks Allowed (BB)</td><td>-0.75</td></tr>
                                    <tr><td>Strikeouts (K)</td><td>1.5</td></tr>
                                    <tr><td>Holds (HLD)</td><td>2</td></tr>
                                    <tr><td>Pickoffs (PICK)</td><td>3</td></tr>
                                    <tr><td>No Hitters (NH)</td><td>10</td></tr>
                                    <tr><td>Quality Starts (QS)</td><td>3</td></tr>
                                </table>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">5.</span>
                                <span class="bylaws-rule-content"><strong>Divisions</strong> - Divisions are not consequential to playoff implications. They will realign every year with humorous names and alignments.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">6.</span>
                                <span class="bylaws-rule-content"><strong>Rule-Breaking</strong> - Broken rules can result in any type of punishment or fine that the league sees fit, unless some punishment or fine is specified for a penalty. The final decision goes to the commissioner, but the commissioner must always act with an overwhelming majority should it be present.</span>
                            </div>
                        </div>

                        <!-- Section II: Drafting, Roster Construction, In-Season, Trading -->
                        <div id="bylaws-drafting" class="bylaws-section">
                            <h2 class="bylaws-section-title">II. Drafting, Roster Construction, In-Season, Trading</h2>
                            
                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">7.</span>
                                <span class="bylaws-rule-content"><strong>Sunday</strong> - The Draft will take place whenever the league is available to draft together.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">8.</span>
                                <span class="bylaws-rule-content"><strong>Host</strong> - The draft will be "hosted" by someone every year. This does not mean every member must attend live at the "host"'s residence, but the designated "host" will offer.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">9.</span>
                                <span class="bylaws-rule-content"><strong>Camaraderie</strong> - Every member must make every effort to join the draft in some way beyond simply drafting: live, discord, voice chat, etc. Not a requirement, but strongly encouraged.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">10.</span>
                                <span class="bylaws-rule-content"><strong>Draft</strong> - The draft will be 22 rounds of picks and all players not designated as a keeper or NA keeper will be available to draft.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">10.1</span>
                                    <strong>Draft Order Podium</strong> - Last year's 1st place will pick their draft position, followed by 2nd place, then 3rd place.
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">10.2</span>
                                    <strong>Draft Order Wheel</strong> - The prior year's 4th-12th place finishers will be given their draft positions through "The Wheel".
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">11.</span>
                                <span class="bylaws-rule-content"><strong>Roster</strong> - Roster positions are subject to change and can be changed in the offseason by league majority vote. Roster positions are as follows:</span>
                                <div class="bylaws-subrule">C 1, 1B 1, 2B 1, 3B 1, SS 1, OF 3, Util 4*, SP 3, RP 1, P 2, BN 4*, IL 5, NA 12</div>
                                <div class="bylaws-note">*The BeerClown Provision changed Util from 3 to 4 and BN from 5 to 4 in the 2025-26 offseason.</div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">12.</span>
                                <span class="bylaws-rule-content"><strong>Add/Drop</strong> - Each team has a maximum of 5 adds per week.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">12.1</span>
                                    <strong>Streaming</strong> - A maximum of 3 adds may be used on pitchers starting a game that week. The other 2 adds may be used on hitters or any player that will not be a starting pitcher that week.
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">13.</span>
                                <span class="bylaws-rule-content"><strong>The Tyler Rule</strong> - A team must at all times have 11 healthy hitters on its roster.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">13.1</span>
                                    <strong>TTR Flex</strong> - The Tyler Rule should be enforced with understanding, as it is not always possible to roster 11 healthy hitters immediately. It is intended to fight abuse of the system. The commissioner reserves the right to judge whether there is foul play or bad faith play in a Tyler Rule violation.
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">14.</span>
                                <span class="bylaws-rule-content"><strong>Streaming Violations</strong> - Streaming violations, either of regular streaming rules or TTR (2.7), may be penalized without league vote by the commissioner, and may include forfeiture of draft picks.</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">15.</span>
                                <span class="bylaws-rule-content"><strong>Trading</strong> - Trading is allowed up until the trade deadline. Deadline day will change yearly, but it is usually in the middle of week 16.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">15.1</span>
                                    <strong>Drop Trades</strong> - Drop trades after the deadline are allowed. A drop trade occurs when two players agree on a trade and both drop the player/s at an agreed time.
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">15.1.1</span> Drop trades cannot include draft picks.
                                    </div>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">15.1.2</span> If a player not involved in the drop trade manages to pick up a player while they are a free agent, it is allowed and a risk of using the drop trade loophole.
                                    </div>
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">15.2</span>
                                    <strong>Draft Pick Trading</strong> - Draft picks are allowed to be traded as of the start of Season VI, with limitations.
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">15.2.1</span> At the time of the draft, all players must have at least 6 of their first 10 rounds of picks (pre-keeper declarations). Therefore, trading more than 4 picks in rounds 1-10 is illegal.
                                    </div>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">15.2.2</span> <strong>The Bob-Rich Joint Trade Exception:</strong> Any trade of completely equal draft pick value (example: a 6th round for a 6th round) that exists for no other reason than to annoy the Commissioner will be vetoed.
                                    </div>
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">16.</span>
                                <span class="bylaws-rule-content"><strong>The Rocker Auction Rule</strong> - In the event that there is a contested add that does not clearly fall under a rule, a bid will be held using K. Commissioner will announce it in chat, and all members have 24 hours OR until a time specified by the Commissioner to submit a bid to an approved Google form. Highest bid will receive the player. Commissioner will act on honor system and not look at bids before the 24 hours or time allotted.</span>
                            </div>
                        </div>

                        <!-- Section III: Playoffs, Championships, Money Breakdown -->
                        <div id="bylaws-playoffs" class="bylaws-section">
                            <h2 class="bylaws-section-title">III. Playoffs, Championships, Money Breakdown</h2>
                            
                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">17.</span>
                                <span class="bylaws-rule-content"><strong>Playoff Format</strong> - 6 teams will make the playoffs.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">17.1</span>
                                    The top two records in the league will receive first-round byes.
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">18.</span>
                                <span class="bylaws-rule-content"><strong>Championships</strong> - <em>(Rules to be determined)</em></span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">19.</span>
                                <span class="bylaws-rule-content"><strong>League Dues</strong> - Dues for the league are $50, due by the start of the draft on draft day.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">19.1</span>
                                    <strong>Failure 1</strong> - Failure to submit payment for team entry results in a late penalty of $10 for every month that passes without the player paying; this penalty will go towards a) any larger league expenses, or b) the championship pot.
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">19.2</span>
                                    <strong>Failure 2</strong> - Failure to submit payment by the playoffs of that year will result in a league vote to determine whether the player in question is kicked from the league.
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">20.</span>
                                <span class="bylaws-rule-content"><strong>Payout Breakdown</strong> - The payout breakdowns are listed below:</span>
                                <table class="bylaws-scoring-table">
                                    <tr><td>League Winner (1st place)</td><td>$250</td></tr>
                                    <tr><td>Runner-Up (2nd place)</td><td>$125</td></tr>
                                    <tr><td>Podium (3rd place)</td><td>$80</td></tr>
                                    <tr><td>4th Place</td><td>$50</td></tr>
                                    <tr><td>5th Place</td><td>$30</td></tr>
                                    <tr><td>6th Place</td><td>$25</td></tr>
                                    <tr><td>Regular Season Best Record</td><td>$25</td></tr>
                                    <tr><td>Regular Season High Scorer</td><td>$15</td></tr>
                                </table>
                            </div>
                        </div>

                        <!-- Section IV: Keeper Rules -->
                        <div id="bylaws-keepers" class="bylaws-section">
                            <h2 class="bylaws-section-title">IV. Keeper Rules</h2>
                            
                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">21.</span>
                                <span class="bylaws-rule-content bylaws-deprecated"><strong>Standard Keepers</strong> - (Old rules - Amended in 2024-2025 offseason)</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">22.</span>
                                <span class="bylaws-rule-content"><strong>Standard Keepers</strong> - Members may choose to keep as many players as they would like per new keeper rules, effective the 2025-2026 offseason.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">22.1</span>
                                    Players are assigned a value between 1 and 20 based on the round they were selected in.
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">22.1.1</span> For example, a 20th round pick would cost 1, a 22nd round pick would cost 1, and a first round pick would cost 20, and all picks between 20th and 1st will be a normal counting scale.
                                    </div>
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">22.2</span>
                                    A member can choose to keep as many players as they'd like under the cap of 50, tradeable to go up to 75 and down to 0.
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">22.2.1</span> Keeper  is also used for the NA Draft Mk. II, or FYPD (see 5.6).
                                    </div>
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">22.3</span>
                                    <span class="bylaws-highlight">The players chosen will cost their value in , as well as a draft pick; the draft pick would be 3 picks higher than whatever the previous year was if in rounds 1-10, 4 picks higher than whatever the previous year was if in rounds 11-23.</span>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">22.3.1</span> <span class="bylaws-highlight">For example, a player chosen in the 15th round would be kept in the 11th round and cost 8, the 15th round value.</span>
                                    </div>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">22.3.2</span> Players kept reaching first round pick keeper status may be kept indefinitely at the cost of 22 and a 1st round pick.
                                    </div>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">22.3.3</span> For example, a player kept in the 22nd round would cost a member 1 and a 22nd round pick the first year kept; 3 and an 18th round pick the second year kept; 7 and a 14th round pick the third year kept; 11 and a 10th round pick the fourth year kept; 14 and a 7th round pick the fifth year kept; 17 and a 4th round pick sixth year kept; 20 and a 1st round pick all years after.
                                    </div>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">22.3.4</span> In the case of a keeper miscalculation that cannot be reversed, a member may pay five times (5) their keeper value for the following year in order to correct any mistakes from the year prior.
                                    </div>
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">23.</span>
                                <span class="bylaws-rule-content"><strong>NA Keepers</strong> - See Rule 24 (NA Rules).</span>
                            </div>

                            <div class="bylaws-note">
                                Keepers must be finalized to commissioner by one month before draft day. Keeper designations transfer in trades and mid-season drops, and do NOT reset.
                            </div>
                        </div>

                        <!-- Section V: NA Rules and NA Draft -->
                        <div id="bylaws-na" class="bylaws-section">
                            <h2 class="bylaws-section-title">V. NA Rules and NA Draft</h2>
                            
                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">24.</span>
                                <span class="bylaws-rule-content"><strong>NA Keepers</strong> - Players considered "NA players" may be kept without a draft pick penalty for free. Players are considered an "NA" player if:</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">24.1</span>
                                    ...they have not made their MLB debut yet, they were drafted or signed over 6 months prior, and they in the minor leagues tagged "NA"
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">24.2</span>
                                    ...they have made their MLB debut but are not yet rookie-eligible (do not meet requirements for service time to be considered a rookie)
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">24.2.1</span> These types of players are considered different because they are not used in an NA roster spot. They may not be picked in the NA draft, but the member can choose not to keep the player if the roster spot is deemed more valuable than the player.
                                    </div>
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">24.2.2</span> There is a maximum of 4 of these players per season per team.
                                    </div>
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">24.3</span>
                                    An NA player drafted in the actual draft is not eligible for NA keeper status and must be kept according to normal keeper rules.
                                    <div class="bylaws-subsubrule">
                                        <span class="bylaws-subrule-number">24.3.1</span> If the player was drafted in the actual draft but did not make their debut during the year, that player can be an additional keeper (on top of the normal keeper rules) at the round that they were drafted.
                                    </div>
                                </div>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">25.</span>
                                <span class="bylaws-rule-content"><em>The NA Draft was abolished in its original, traditional format prior to the 2025 season.</em></span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">26.</span>
                                <span class="bylaws-rule-content bylaws-deprecated"><strong>NA Draft</strong> - (Abolished - See Rule 29 for new format)</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">27.</span>
                                <span class="bylaws-rule-content bylaws-deprecated"><strong>In-Season NA Pickups</strong> - (Abolished)</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">28.</span>
                                <span class="bylaws-rule-content bylaws-deprecated"><strong>Double Max</strong> - (Abolished)</span>
                            </div>

                            <div class="bylaws-rule">
                                <span class="bylaws-rule-number">29.</span>
                                <span class="bylaws-rule-content"><strong>NA Draft Mk. II (FYPD)</strong> - Within two weeks after the MLB First Year Player draft, the league will hold an optional NA Draft (henceforth known as the FBCW First Year Player Draft, or FYPD) in order to fairly distribute new additions to the league.</span>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">29.1</span>
                                    The auction draft will be held either in-person or virtually in real-time.
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">29.2</span>
                                    The auction draft will use keeper  in order to bid.
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">29.3</span>
                                    All players in the MLB FYPD will be available to bid on.
                                </div>
                                <div class="bylaws-subrule">
                                    <span class="bylaws-subrule-number">29.4</span>
                                    If a member of the league cannot make the NA Draft, they may contact the commish with targets and max bids, and the commish may auto-bid for them up until that max bid number.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sticky Sidebar TOC -->
                <div class="bylaws-sidebar">
                    <div class="bylaws-toc">
                        <h3>Table of Contents</h3>
                        <ul class="bylaws-toc-list" id="bylaws-toc-list">
                            <li><a href="#bylaws-league-construction" data-section="bylaws-league-construction">I. League Construction</a></li>
                            <li><a href="#bylaws-drafting" data-section="bylaws-drafting">II. Drafting & Roster</a></li>
                            <li><a href="#bylaws-playoffs" data-section="bylaws-playoffs">III. Playoffs & Money</a></li>
                            <li><a href="#bylaws-keepers" data-section="bylaws-keepers">IV. Keeper Rules</a></li>
                            <li><a href="#bylaws-na" data-section="bylaws-na">V. NA Rules</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sportsbook Login Modal -->
    <div id="sportsbook-login-modal" class="sportsbook-login-modal">
        <div class="sportsbook-login-content">
            <h2 class="sportsbook-login-title">King Dylan's Sportsbook</h2>
            <p class="sportsbook-login-subtitle">Select your team logo to continue</p>
            
            <div class="sportsbook-team-grid" id="sportsbook-team-grid">
                <!-- Team logos populated by JS -->
            </div>
            
            <div class="sportsbook-password-section" id="sportsbook-password-section">
                <h4>Enter password for <span id="sportsbook-selected-team-name"></span></h4>
                <div class="sportsbook-password-input">
                    <input type="password" id="sportsbook-password" placeholder="Password" 
                           onkeypress="if(event.key === 'Enter') authenticateSportsbook()">
                    <button onclick="authenticateSportsbook()">Enter</button>
                </div>
                <div class="sportsbook-login-error" id="sportsbook-login-error">
                    Incorrect password. Please try again.
                </div>
                <button class="sportsbook-back-btn" onclick="sportsbookBackToTeamSelect()"> Back to team selection</button>
            </div>
            
            <button class="sportsbook-back-btn" onclick="closeSportsbookLogin()" style="margin-top: 1.5rem;">
                Cancel
            </button>
        </div>
    </div>

    <!-- Betting Stats Modal -->
    <div id="bet-stats-modal" class="bet-stats-modal" onclick="if(event.target === this) closeBetStatsModal()">
        <div class="bet-stats-content">
            <div class="bet-stats-header">
                <h3 id="bet-stats-title">Betting Stats</h3>
                <button class="bet-stats-close" onclick="closeBetStatsModal()">&times;</button>
            </div>
            <div class="bet-stats-body" id="bet-stats-body">
                <!-- Content populated by JS -->
            </div>
        </div>
    </div>

    <!-- Bet Slip -->
    <div id="bet-slip" class="bet-slip">
        <div class="bet-slip-header">
            <span> Bet Slip</span>
            <button class="bet-slip-close" onclick="closeBetSlip()"></button>
        </div>
        <div class="bet-slip-content" id="bet-slip-content">
            <!-- Bet items populated by JS -->
        </div>
        <div class="bet-slip-footer">
            <div class="bet-slip-total">
                <span>Total Wager:</span>
                <span id="bet-slip-total-wager">0 units</span>
            </div>
            <div class="bet-slip-total">
                <span>Potential Payout:</span>
                <span id="bet-slip-potential-payout" style="color: #28a745;">0 units</span>
            </div>
            <button class="bet-slip-submit" id="bet-slip-submit" onclick="submitBets()" disabled>
                Place Bets
            </button>
        </div>
    </div>

    <!-- Export Trades Modal -->
    <div id="export-trades-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="keeper-modal-close" onclick="closeExportModal()">&times;</span>
            <div class="trade-modal-header">
                <h2> Export Trades for Site</h2>
                <p>Copy this JSON and save it to <code>data/keepers/trades_2026.json</code> in your repository.</p>
            </div>
            <div style="padding: 1.5rem;">
                <textarea id="export-json-content" readonly
                    style="width: 100%; height: 300px; font-family: monospace; font-size: 0.85rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa;"></textarea>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button class="keeper-cancel-btn" onclick="closeExportModal()">Close</button>
                    <button class="keeper-submit-btn" onclick="copyExportJson()">Copy to Clipboard</button>
                    <button class="keeper-submit-btn" onclick="downloadExportJson()"
                        style="background: var(--retro-blue);">Download File</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Budget Adjustment Modal -->
    <div id="budget-adjustment-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="keeper-modal-close" onclick="closeBudgetModal()">&times;</span>
            <div class="trade-modal-header">
                <h2>Adjust Team Budgets</h2>
                <p>Manually adjust keeper budgets for each team. Export to share with all managers.</p>
            </div>
            <div style="padding: 1.5rem;">
                <div id="budget-adjustment-list" style="max-height: 350px; overflow-y: auto;">
                    <!-- Team budget rows will be populated here -->
                </div>
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                    <div style="display: flex; gap: 1rem; justify-content: space-between; align-items: center;">
                        <button class="keeper-cancel-btn" onclick="resetAllBudgets()"
                            style="background: #dc3545; color: white;">Reset All</button>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn-export-trades" onclick="exportBudgetsForSite()"> Export for
                                Site</button>
                            <button class="keeper-cancel-btn" onclick="closeBudgetModal()">Cancel</button>
                            <button class="keeper-submit-btn" onclick="saveBudgetAdjustments()">Save</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Budgets Modal -->
    <div id="export-budgets-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="keeper-modal-close" onclick="closeExportBudgetsModal()">&times;</span>
            <div class="trade-modal-header">
                <h2> Export Budget Adjustments</h2>
                <p>Copy this JSON and save it to <code>data/keepers/budget_adjustments_2026.json</code> in your
                    repository.</p>
            </div>
            <div style="padding: 1.5rem;">
                <textarea id="export-budgets-json-content" readonly
                    style="width: 100%; height: 300px; font-family: monospace; font-size: 0.85rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa;"></textarea>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button class="keeper-cancel-btn" onclick="closeExportBudgetsModal()">Close</button>
                    <button class="keeper-submit-btn" onclick="copyExportBudgetsJson()">Copy to Clipboard</button>
                    <button class="keeper-submit-btn" onclick="downloadExportBudgetsJson()"
                        style="background: var(--retro-blue);">Download File</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Trade Builder Modal -->
    <div id="trade-modal" class="modal">
        <div class="modal-content trade-modal-content">
            <span class="keeper-modal-close" onclick="closeTradeModal()">&times;</span>

            <div class="trade-modal-header">
                <h2>Create Trade</h2>
                <p>Select two teams and add assets to each side of the trade.</p>
            </div>

            <div class="trade-builder">
                <!-- Team A Side -->
                <div class="trade-side" id="trade-side-a">
                    <div class="trade-team-selector">
                        <label>Team A:</label>
                        <select id="trade-team-a" onchange="onTradeTeamSelect('a')">
                            <option value="">-- Select Team --</option>
                        </select>
                    </div>

                    <div class="trade-team-info" id="trade-team-a-info" style="display: none;">
                        <div class="trade-budget-display">
                            Budget: <span id="trade-budget-a">$50</span>
                        </div>
                    </div>

                    <div class="trade-assets" id="trade-assets-a">
                        <!-- Assets Team A is giving up -->
                    </div>

                    <div class="trade-add-asset" id="trade-add-asset-a" style="display: none;">
                        <select id="trade-asset-type-a" onchange="onAssetTypeChange('a')">
                            <option value="">+ Add Asset</option>
                            <option value="player">Player</option>
                            <option value="pick">Draft Pick</option>
                            <option value="money">Budget $</option>
                        </select>

                        <div id="trade-asset-selector-a" class="trade-asset-selector" style="display: none;">
                            <!-- Dynamic selector based on asset type -->
                        </div>
                    </div>
                </div>

                <!-- Trade Arrow -->
                <div class="trade-arrow">
                    <span></span>
                </div>

                <!-- Team B Side -->
                <div class="trade-side" id="trade-side-b">
                    <div class="trade-team-selector">
                        <label>Team B:</label>
                        <select id="trade-team-b" onchange="onTradeTeamSelect('b')">
                            <option value="">-- Select Team --</option>
                        </select>
                    </div>

                    <div class="trade-team-info" id="trade-team-b-info" style="display: none;">
                        <div class="trade-budget-display">
                            Budget: <span id="trade-budget-b">$50</span>
                        </div>
                    </div>

                    <div class="trade-assets" id="trade-assets-b">
                        <!-- Assets Team B is giving up -->
                    </div>

                    <div class="trade-add-asset" id="trade-add-asset-b" style="display: none;">
                        <select id="trade-asset-type-b" onchange="onAssetTypeChange('b')">
                            <option value="">+ Add Asset</option>
                            <option value="player">Player</option>
                            <option value="pick">Draft Pick</option>
                            <option value="money">Budget $</option>
                        </select>

                        <div id="trade-asset-selector-b" class="trade-asset-selector" style="display: none;">
                            <!-- Dynamic selector based on asset type -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="trade-modal-footer">
                <div class="trade-notes">
                    <label for="trade-notes">Trade Notes (optional):</label>
                    <input type="text" id="trade-notes"
                        placeholder="e.g., Part of larger deal, future considerations...">
                </div>
                <div class="trade-modal-actions">
                    <button class="keeper-cancel-btn" onclick="closeTradeModal()">Cancel</button>
                    <button class="keeper-submit-btn" onclick="submitTrade()" id="trade-submit-btn" disabled>Record
                        Trade</button>
                </div>
            </div>
        </div>
    </div>
    <div id="keeper-modal" class="modal">
        <div class="modal-content keeper-modal-content">
            <span class="keeper-modal-close" onclick="closeKeeperModal()">&times;</span>

            <!-- Auth Section -->
            <div id="keeper-modal-auth" class="keeper-modal-auth">
                <h2> Select Your Keepers</h2>
                <p style="color: #666; margin-bottom: 1.5rem;">Select your team and enter your password to manage your
                    keepers.</p>

                <div class="keeper-auth-form">
                    <div class="keeper-auth-field">
                        <label for="keeper-team-select">Your Team:</label>
                        <select id="keeper-team-select" onchange="onKeeperTeamSelect()">
                            <option value="">-- Select Team --</option>
                        </select>
                    </div>
                    <div class="keeper-auth-field" id="keeper-password-field" style="display: none;">
                        <label for="keeper-password">Password:</label>
                        <input type="password" id="keeper-password" placeholder="Enter password"
                            onkeypress="if(event.key === 'Enter') authenticateKeeper()">
                        <button class="keeper-auth-btn" onclick="authenticateKeeper()">Unlock</button>
                    </div>
                </div>
                <div id="keeper-auth-error" class="keeper-auth-error" style="display: none;"></div>
            </div>

            <!-- Selection Section (hidden until authenticated) -->
            <div id="keeper-modal-selection" style="display: none;">

                <!-- Fixed Header -->
                <div class="keeper-modal-header">
                    <div class="keeper-header-left">
                        <img id="keeper-team-logo" class="keeper-header-logo" src="" alt="">
                        <div class="keeper-header-info">
                            <h2 id="keeper-current-team"></h2>
                            <div class="keeper-progress-container">
                                <div id="keeper-progress-bar" class="keeper-progress-bar"></div>
                            </div>
                            <span class="keeper-status" id="keeper-status">0 / 5 keepers selected</span>
                        </div>
                    </div>
                    <!-- Switch Team button moved under close button -->
                    <div class="keeper-header-actions">
                        <button class="keeper-switch-btn" onclick="logoutKeeper()">Switch Team</button>
                    </div>
                </div>

                <!-- Two Column Layout: Roster + Draft Picks -->
                <div class="keeper-selection-body">
                    <!-- Left: Scrollable Roster Section -->
                    <div class="keeper-roster-section">
                        <p style="color: #666; margin-bottom: 1rem;">Select players from your 2025 roster to keep.
                            Budget: <strong id="keeper-budget-display">$50</strong>. Player costs are based on draft round.</p>
                        <div id="keeper-roster-loading" class="loading" style="display: none;">Loading roster...</div>
                        <div class="keeper-roster-table-wrapper">
                            <table class="player-table keeper-table" id="keeper-roster-table">
                                <thead>
                                    <tr>
                                        <th style="width: 45px;">Keep</th>
                                        <th class="sortable" data-sort="name" style="width: 230px;">Player</th>
                                        <th class="sortable" data-sort="position" style="width: 55px;">Pos</th>
                                        <th class="sortable" data-sort="pts2025" style="width: 65px;">2025</th>
                                        <th class="sortable" data-sort="pts2026" style="width: 65px;">2026</th>
                                        <th class="sortable" data-sort="drafted" style="width: 65px;">Drafted</th>
                                        <th class="sortable" data-sort="rdcost" style="width: 65px;">Rd Cost</th>
                                        <th class="sortable" data-sort="rdexp" style="width: 60px;">Rd Exp</th>
                                        <th class="sortable" data-sort="value" style="width: 60px;">Value</th>
                                        <th class="sortable" data-sort="cost" style="width: 50px;">Cost</th>
                                    </tr>
                                </thead>
                                <tbody id="keeper-roster-body">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Right: Draft Picks Visualization -->
                    <div class="keeper-picks-section">
                        <div class="keeper-picks-header">
                            <h4>Your 2026 Draft Picks</h4>
                            <button class="keeper-toggle-traded-btn" id="keeper-toggle-traded"
                                onclick="toggleTradedPicks()">
                                <span id="toggle-traded-text">Show Traded</span>
                            </button>
                        </div>
                        <div class="keeper-picks-grid" id="keeper-picks-grid">
                            <!-- Pick boxes will be populated dynamically -->
                        </div>
                    </div>
                </div>

                <!-- Fixed Footer with Submit -->
                <div class="keeper-modal-footer">
                    <div class="keeper-selected-summary" id="keeper-selected-summary">
                        <span class="no-selection">No keepers selected. Check the boxes next to players you want to
                            keep.</span>
                    </div>
                    <div class="keeper-modal-actions">
                        <button class="keeper-cancel-btn" onclick="closeKeeperModal()">Cancel</button>
                        <button class="keeper-submit-btn" onclick="submitKeepers()" id="keeper-submit-btn"
                            disabled>Submit Keepers</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Manager Detail Modal -->
    <div id="manager-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeManagerModal()">&times;</span>
            <div id="modal-header-section">
                <!-- Header loaded dynamically -->
            </div>
            <div class="modal-body-scroll" id="modal-body">
                <!-- Body content loaded dynamically -->
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2024 Yahoo Fantasy Baseball League | Powered by Python & Yahoo Fantasy API</p>
    </footer>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <script>
        // ===== GLOBAL STATE =====
        let availableSeasons = [];
        let allManagersData = [];
        let managerHistoryData = [];
        let managerAwardsData = {}; // Store manager awards globally
        let currentTableMode = 'all'; // 'all', 'batters', or 'pitchers'

        // Player scoring state
        let allPlayersData = [];
        let filteredPlayersData = [];
        let playerHistoryData = {};
        let currentPlayerSort = { column: 'fantasy_points', direction: 'desc' };
        let currentStatType = 'fantasy'; // 'fantasy' for fantasy season, 'full' for full MLB season

        // Chart state
        let currentChartData = null;
        let currentChartType = 'weekly'; // 'weekly' or 'total'

        // Cache for team data to avoid redundant fetches
        const teamDataCache = {};

        // Cache for player stats data to avoid redundant fetches for rank calculations
        const playerStatsCache = {};

        // Helper function to get player stats data with caching
        async function getPlayerStatsData(year) {
            const cacheKey = year === 2026 ? 'current' : year;

            if (playerStatsCache[cacheKey]) {
                return playerStatsCache[cacheKey];
            }

            try {
                let statsPath = year === 2026
                    ? 'data/current_season/player_stats.json'
                    : `data/historical/${year}/player_stats.json`;
                const response = await fetch(statsPath);
                if (response.ok) {
                    const data = await response.json();
                    playerStatsCache[cacheKey] = data;
                    return data;
                }
            } catch (e) {
                console.log(`Could not load player stats for ${year}`);
            }
            return null;
        }

        // Helper function to get team data with caching
        async function getTeamData(year) {
            const cacheKey = year === 2026 ? 'current' : year;

            if (teamDataCache[cacheKey]) {
                return teamDataCache[cacheKey];
            }

            try {
                let teamsResponse;
                if (year === 2026) {
                    teamsResponse = await fetch('data/current_season/teams.json');
                } else {
                    teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                }

                if (teamsResponse.ok) {
                    const teams = await teamsResponse.json();
                    teamDataCache[cacheKey] = teams;
                    return teams;
                }
            } catch (e) {
                console.log(`Could not load team data for ${year}`);
            }

            return null;
        }

        // ===== PLAYER SCORING FUNCTIONS =====

        async function loadPlayerScoring() {
            const seasonSelect = document.getElementById('scoring-season');
            const selectedYear = parseInt(seasonSelect.value);

            const loadingEl = document.getElementById('player-loading');
            const errorEl = document.getElementById('player-error');
            const containerEl = document.getElementById('player-stats-container');

            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            containerEl.style.display = 'none';

            try {
                // Determine the path based on year
                let playerStatsPath;
                if (selectedYear === 2026) {
                    playerStatsPath = 'data/current_season/player_stats.json';
                } else {
                    playerStatsPath = `data/historical/${selectedYear}/player_stats.json`;
                }

                const response = await fetch(playerStatsPath);
                if (!response.ok) {
                    throw new Error(`No player data available for ${selectedYear}`);
                }

                allPlayersData = await response.json();

                // Calculate position ranks for each player
                calculatePositionRanks();

                // Populate manager filter
                populateManagerFilter();

                // Apply filters and render
                filterPlayers();

                loadingEl.style.display = 'none';
                containerEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading player data:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function calculatePositionRanks() {
            // Define all positions to rank
            const positions = ['C', '1B', '2B', '3B', 'SS', 'OF', 'Util', 'SP', 'RP', 'P'];

            // For each position, sort eligible players by fantasy points and assign ranks
            positions.forEach(pos => {
                // Get players eligible for this position
                let eligiblePlayers;
                if (pos === 'P') {
                    // P includes all pitchers
                    eligiblePlayers = allPlayersData.filter(p => p.position_type === 'P');
                } else {
                    eligiblePlayers = allPlayersData.filter(p =>
                        p.eligible_positions && p.eligible_positions.includes(pos)
                    );
                }

                // Sort by fantasy points descending (using current stat type)
                eligiblePlayers.sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));

                // Assign ranks
                eligiblePlayers.forEach((player, index) => {
                    if (!player.position_ranks) {
                        player.position_ranks = {};
                    }
                    player.position_ranks[pos] = index + 1;
                });
            });

            // Also calculate overall batter and pitcher ranks
            const batters = allPlayersData.filter(p => p.position_type === 'B')
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            batters.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['B'] = index + 1;
            });

            const pitchers = allPlayersData.filter(p => p.position_type === 'P')
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            pitchers.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['P'] = index + 1;
            });
        }

        function getPositionWithRank(player) {
            const positionFilter = document.getElementById('position-filter').value;
            const pos = player.primary_position || '-';

            if (!player.position_ranks) return pos;

            // Determine which position rank to show based on filter
            let rankPos;
            let displayPos;

            if (positionFilter === 'all') {
                // Show primary position rank
                rankPos = pos;
                displayPos = pos;
            } else if (positionFilter === 'B') {
                // Show overall batter rank with primary position
                rankPos = 'B';
                displayPos = pos;
            } else if (positionFilter === 'P') {
                // Show overall pitcher rank with primary position
                rankPos = 'P';
                displayPos = pos;
            } else {
                // Specific position filter - show that position's rank
                rankPos = positionFilter;
                displayPos = positionFilter;
            }

            const rank = player.position_ranks[rankPos];
            if (rank) {
                return `${displayPos}${rank}`;
            }
            return pos;
        }

        function populateManagerFilter() {
            const managerFilter = document.getElementById('manager-filter');
            const managers = [...new Set(allPlayersData.map(p => p.manager))].sort();

            // Keep the "All Managers" option and add the rest
            managerFilter.innerHTML = '<option value="all">All Managers</option>';
            managers.forEach(manager => {
                const option = document.createElement('option');
                option.value = manager;
                option.textContent = manager;
                managerFilter.appendChild(option);
            });
        }

        function setStatType(type) {
            currentStatType = type;

            // Update button states
            document.getElementById('fantasy-season-btn').classList.toggle('active', type === 'fantasy');
            document.getElementById('full-season-btn').classList.toggle('active', type === 'full');

            // Re-calculate position ranks and re-render
            calculatePositionRanks();
            filterPlayers();
        }

        function setModalStatType(type) {
            currentStatType = type;

            // Update main page toggle buttons too
            document.getElementById('fantasy-season-btn').classList.toggle('active', type === 'fantasy');
            document.getElementById('full-season-btn').classList.toggle('active', type === 'full');

            // Update modal toggle buttons
            document.querySelectorAll('.card-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(type === 'fantasy' ? 'fantasy' : 'full'));
            });

            // Re-render the modal with the current player
            if (window.currentModalPlayer) {
                updateModalStats(window.currentModalPlayer);
            }

            // Re-calculate position ranks and re-render main table
            calculatePositionRanks();
            filterPlayers();
        }

        function updateModalStats(player) {
            const stats = getPlayerStats(player);
            const fantasyPts = getPlayerFantasyPoints(player);
            const isBatter = player.position_type === 'B';

            // Update points display in the card
            const ptsValueEl = document.querySelector('.card-points-value');
            if (ptsValueEl) {
                ptsValueEl.textContent = fantasyPts.toFixed(1);
            }

            // Update position rank
            const primaryPos = player.primary_position;
            const samePos = allPlayersData
                .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            const posRank = samePos.findIndex(p => p.name === player.name) + 1;
            const posRankDisplay = posRank > 0 ? `${primaryPos}${posRank}` : primaryPos;

            const rankEl = document.querySelector('.card-points-rank');
            if (rankEl) {
                rankEl.textContent = posRankDisplay;
            }

            // Update stats content
            const statsContent = document.getElementById('modal-stats-content');
            if (statsContent) {
                if (isBatter) {
                    statsContent.innerHTML = `
                        <div class="card-stats-row">
                            <div class="card-stats-label">SEASON</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">G</div>
                                <div class="card-stats-header-cell">AB</div>
                                <div class="card-stats-header-cell">H</div>
                                <div class="card-stats-header-cell">HR</div>
                                <div class="card-stats-header-cell">RBI</div>
                                <div class="card-stats-header-cell">SB</div>
                                <div class="card-stats-header-cell">AVG</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label">${window.selectedYear || '2025'}</div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.G || 0}</div>
                                <div class="card-stats-data-cell">${stats.AB || 0}</div>
                                <div class="card-stats-data-cell">${stats.H || 0}</div>
                                <div class="card-stats-data-cell">${stats.HR || 0}</div>
                                <div class="card-stats-data-cell">${stats.RBI || 0}</div>
                                <div class="card-stats-data-cell">${stats.SB || 0}</div>
                                <div class="card-stats-data-cell">${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</div>
                            </div>
                        </div>
                        <div class="card-stats-row">
                            <div class="card-stats-label">MORE</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">R</div>
                                <div class="card-stats-header-cell">BB</div>
                                <div class="card-stats-header-cell">2B</div>
                                <div class="card-stats-header-cell">3B</div>
                                <div class="card-stats-header-cell">OBP</div>
                                <div class="card-stats-header-cell">SLG</div>
                                <div class="card-stats-header-cell">OPS</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label"></div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.R || 0}</div>
                                <div class="card-stats-data-cell">${stats.BB || 0}</div>
                                <div class="card-stats-data-cell">${stats['2B'] || 0}</div>
                                <div class="card-stats-data-cell">${stats['3B'] || 0}</div>
                                <div class="card-stats-data-cell">${stats.OBP ? stats.OBP.toFixed(3) : '.000'}</div>
                                <div class="card-stats-data-cell">${stats.SLG ? stats.SLG.toFixed(3) : '.000'}</div>
                                <div class="card-stats-data-cell">${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</div>
                            </div>
                        </div>`;
                } else {
                    statsContent.innerHTML = `
                        <div class="card-stats-row">
                            <div class="card-stats-label">SEASON</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">W</div>
                                <div class="card-stats-header-cell">L</div>
                                <div class="card-stats-header-cell">SV</div>
                                <div class="card-stats-header-cell">G</div>
                                <div class="card-stats-header-cell">IP</div>
                                <div class="card-stats-header-cell">K</div>
                                <div class="card-stats-header-cell">ERA</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label">${window.selectedYear || '2025'}</div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.W || 0}</div>
                                <div class="card-stats-data-cell">${stats.L || 0}</div>
                                <div class="card-stats-data-cell">${stats.SV || 0}</div>
                                <div class="card-stats-data-cell">${stats.G || 0}</div>
                                <div class="card-stats-data-cell">${stats.IP || 0}</div>
                                <div class="card-stats-data-cell">${stats.SO || 0}</div>
                                <div class="card-stats-data-cell">${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</div>
                            </div>
                        </div>
                        <div class="card-stats-row">
                            <div class="card-stats-label">MORE</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">GS</div>
                                <div class="card-stats-header-cell">HLD</div>
                                <div class="card-stats-header-cell">BB</div>
                                <div class="card-stats-header-cell">WHIP</div>
                                <div class="card-stats-header-cell">K/9</div>
                                <div class="card-stats-header-cell">K%</div>
                                <div class="card-stats-header-cell">BB%</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label"></div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.GS || 0}</div>
                                <div class="card-stats-data-cell">${stats.HLD || 0}</div>
                                <div class="card-stats-data-cell">${stats.BB || 0}</div>
                                <div class="card-stats-data-cell">${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</div>
                                <div class="card-stats-data-cell">${stats['K/9'] ? stats['K/9'].toFixed(1) : '0.0'}</div>
                                <div class="card-stats-data-cell">${stats['K%'] ? stats['K%'].toFixed(0) : '0'}%</div>
                                <div class="card-stats-data-cell">${stats['BB%'] ? stats['BB%'].toFixed(0) : '0'}%</div>
                            </div>
                        </div>`;
                }
            }
        }

        function getPlayerStats(player) {
            // Returns the appropriate stats object based on currentStatType
            if (currentStatType === 'full') {
                return player.full_season_stats || player.stats || {};
            }
            return player.stats || {};
        }

        function getPlayerFantasyPoints(player) {
            // Returns the appropriate fantasy points based on currentStatType
            if (currentStatType === 'full') {
                return player.full_season_fantasy_points || player.fantasy_points || 0;
            }
            return player.fantasy_points || 0;
        }

        function filterPlayers() {
            const positionFilter = document.getElementById('position-filter').value;
            const managerFilter = document.getElementById('manager-filter').value;
            const searchQuery = document.getElementById('player-search').value.toLowerCase().trim();

            // 1. DETERMINE TABLE MODE
            if (positionFilter === 'P' || positionFilter === 'SP' || positionFilter === 'RP') {
                currentTableMode = 'pitchers';
            } else if (positionFilter === 'B' || ['C', '1B', '2B', '3B', 'SS', 'OF', 'Util'].includes(positionFilter)) {
                currentTableMode = 'batters';
            } else {
                currentTableMode = 'all';
            }

            filteredPlayersData = allPlayersData.filter(player => {
                // Position filter
                if (positionFilter !== 'all') {
                    if (positionFilter === 'B' || positionFilter === 'P') {
                        if (player.position_type !== positionFilter) return false;
                    } else {
                        // Specific position
                        if (!player.eligible_positions.includes(positionFilter)) return false;
                    }
                }

                // Manager filter
                if (managerFilter !== 'all' && player.manager !== managerFilter) {
                    return false;
                }

                // Search filter
                if (searchQuery) {
                    const nameMatch = player.name.toLowerCase().includes(searchQuery);
                    const teamMatch = player.team_name.toLowerCase().includes(searchQuery);
                    const mlbMatch = (player.mlb_team || '').toLowerCase().includes(searchQuery);
                    if (!nameMatch && !teamMatch && !mlbMatch) return false;
                }

                return true;
            });

            // Apply current sort
            sortPlayersArray();

            // 2. REBUILD HEADERS BASED ON MODE
            updateTableHeaders();

            // Render the table
            renderPlayerTable();
        }

        function updateTableHeaders() {
            const thead = document.querySelector('#player-table thead');
            let headerHTML = `
                <tr>
                    <th class="sortable" onclick="sortPlayerTable('rank')">#</th>
                    <th class="sortable" onclick="sortPlayerTable('name')">Player</th>
                    <th>Team</th>
                    <th class="sortable" onclick="sortPlayerTable('position')">Pos</th>
            `;

            if (currentTableMode === 'batters') {
                // BATTER SPECIFIC HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('AVG')">AVG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('AB')">AB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('H')">H</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('RBI')">RBI</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SB')">SB</th>
                `;
            } else if (currentTableMode === 'pitchers') {
                // PITCHER SPECIFIC HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('GS')">GS</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('WHIP')">WHIP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('K%')">K%</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB%')">BB%</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SV')">SV</th>
                `;
            } else {
                // ALL PLAYERS (DEFAULT) HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PA')">PA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                `;
            }

            headerHTML += `</tr>`;
            thead.innerHTML = headerHTML;
        }

        function sortPlayerTable(column) {
            // Toggle direction if same column
            if (currentPlayerSort.column === column) {
                currentPlayerSort.direction = currentPlayerSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentPlayerSort.column = column;
                // Default to descending for stats, ascending for name
                currentPlayerSort.direction = (column === 'name' || column === 'position') ? 'asc' : 'desc';
            }

            sortPlayersArray();
            renderPlayerTable();
            updateSortIndicators();
        }

        function sortPlayersArray() {
            const { column, direction } = currentPlayerSort;

            filteredPlayersData.sort((a, b) => {
                let aVal, bVal;
                const aStats = getPlayerStats(a);
                const bStats = getPlayerStats(b);
                const aPoints = getPlayerFantasyPoints(a);
                const bPoints = getPlayerFantasyPoints(b);

                if (column === 'rank') {
                    // Rank is determined by fantasy points
                    aVal = aPoints;
                    bVal = bPoints;
                } else if (column === 'name') {
                    aVal = a.name.toLowerCase();
                    bVal = b.name.toLowerCase();
                } else if (column === 'position') {
                    aVal = a.primary_position || '';
                    bVal = b.primary_position || '';
                } else if (column === 'fantasy_points') {
                    aVal = aPoints;
                    bVal = bPoints;
                } else if (column === 'PPG') {
                    // Points Per Game = fantasy_points / G
                    const aGames = aStats.G || 0;
                    const bGames = bStats.G || 0;
                    aVal = aGames > 0 ? aPoints / aGames : 0;
                    bVal = bGames > 0 ? bPoints / bGames : 0;
                } else {
                    // Stat column
                    aVal = aStats[column] || 0;
                    bVal = bStats[column] || 0;
                }

                if (typeof aVal === 'string') {
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                }

                return direction === 'asc' ? aVal - bVal : bVal - aVal;
            });
        }

        function updateSortIndicators() {
            // Remove all sort indicators
            document.querySelectorAll('.player-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add indicator to current sort column
            const headers = document.querySelectorAll('.player-table th');
            headers.forEach(th => {
                const onclick = th.getAttribute('onclick');
                if (onclick && onclick.includes(`'${currentPlayerSort.column}'`)) {
                    th.classList.add(currentPlayerSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function renderPlayerTable() {
            const tbody = document.getElementById('player-table-body');
            const countEl = document.getElementById('player-count');

            countEl.textContent = `${filteredPlayersData.length} player${filteredPlayersData.length !== 1 ? 's' : ''}`;

            if (filteredPlayersData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; padding: 2rem; color: #666;">No players found matching your criteria</td></tr>';
                return;
            }

            // Base64 encoded placeholder
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            tbody.innerHTML = filteredPlayersData.map((player, index) => {
                const stats = getPlayerStats(player);
                const fantasyPoints = getPlayerFantasyPoints(player);
                const isBatter = player.position_type === 'B';
                const headshot = (player.headshot_url && player.headshot_url.trim()) ? player.headshot_url : placeholderImg;

                // Calculate PPG
                const games = stats.G || 0;
                const ppg = games > 0 ? (fantasyPoints / games).toFixed(2) : '-';

                // Get MLB logo URL and normalize team display
                const mlbLogoUrl = getMLBTeamLogo(player.mlb_team);
                const mlbTeamText = formatMLBTeamDisplay(player.mlb_team);
                const hasMlbLogo = mlbTeamText !== 'FA' && mlbLogoUrl;
                const mlbLogoHtml = hasMlbLogo
                    ? `<img src="${mlbLogoUrl}" alt="" class="player-mlb-logo" onerror="this.style.display='none'">`
                    : '';

                // Check if player is on a fantasy team
                const hasFantasyTeam = player.team_key && player.team_key.trim() && player.team_name && player.team_name !== 'Free Agent' && player.team_name !== 'Drafted (Dropped)' && player.team_name !== 'Previously Rostered';
                const fantasyTeamHtml = hasFantasyTeam
                    ? `<img src="${fixTeamLogo(player.team_logo)}" alt="" class="player-team-logo" onerror="this.style.display='none'">
                       <span class="player-fantasy-team" title="${player.team_name}">${player.manager}</span>`
                    : '<span class="player-fantasy-team">FA</span>';

                // Common cells (Rank, Name, Team, Pos)
                let rowHTML = `
                    <tr>
                        <td>${index + 1}</td>
                        <td>
                            <div class="player-name-cell" onclick="showPlayerDetail('${player.name.replace(/'/g, "\\'")}')">
                                <img src="${headshot}" alt="" class="player-headshot" onerror="this.src='${placeholderImg}'">
                                <div>
                                    <div class="player-name">${player.name}</div>
                                    <div class="player-mlb-team">${mlbLogoHtml}${mlbTeamText}</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="player-team-cell">
                                ${fantasyTeamHtml}
                            </div>
                        </td>
                        <td class="player-position">${getPositionWithRank(player)}</td>
                `;

                // STAT CELLS BASED ON MODE
                if (currentTableMode === 'batters') {
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${stats.AVG ? stats.AVG.toFixed(3) : '-'}</td>
                        <td class="stat-col">${stats.OPS ? stats.OPS.toFixed(3) : '-'}</td>
                        <td class="stat-col">${stats.AB || '-'}</td>
                        <td class="stat-col">${stats.H || '-'}</td>
                        <td class="stat-col">${stats.HR || '-'}</td>
                        <td class="stat-col">${stats.RBI || '-'}</td>
                        <td class="stat-col">${stats.SB || '-'}</td>
                    `;
                } else if (currentTableMode === 'pitchers') {
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${stats.GS || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${stats.IP || '-'}</td>
                        <td class="stat-col">${stats.ERA ? stats.ERA.toFixed(2) : '-'}</td>
                        <td class="stat-col">${stats.WHIP ? stats.WHIP.toFixed(2) : '-'}</td>
                        <td class="stat-col">${stats.SO || '-'}</td>
                        <td class="stat-col">${stats['K%'] ? stats['K%'].toFixed(1) : '-'}</td>
                        <td class="stat-col">${stats.BB || '-'}</td>
                        <td class="stat-col">${stats['BB%'] ? stats['BB%'].toFixed(1) : '-'}</td>
                        <td class="stat-col">${stats.W || '-'}</td>
                        <td class="stat-col">${stats.SV || '-'}</td>
                    `;
                } else {
                    // ALL PLAYERS
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${!isBatter ? (stats.IP || '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.ERA ? stats.ERA.toFixed(2) : '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.W || '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.SO || '-') : '-'}</td>
                        <td class="stat-col">${stats.BB || '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.PA || '-') : '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.HR || '-') : '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.OPS ? stats.OPS.toFixed(3) : '-') : '-'}</td>
                    `;
                }

                rowHTML += `</tr>`;
                return rowHTML;
            }).join('');

            updateSortIndicators();
        }

        // MLB Team abbreviation to ESPN CDN logo mapping
        // Helper function to normalize and format MLB team display
        function formatMLBTeamDisplay(mlbTeam) {
            if (!mlbTeam || !mlbTeam.trim()) return 'FA';

            // Standard abbreviation mapping for display normalization
            const displayMap = {
                // Teams with alternate abbreviations that should be normalized
                'TBR': 'TB', 'TAM': 'TB',
                'CHW': 'CWS',
                'KCR': 'KC',
                'ANA': 'LAA',
                'FLA': 'MIA',
                'WAS': 'WSH', 'WSN': 'WSH',
                'AZ': 'ARI',
                'SDP': 'SD',
                'SFG': 'SF'
            };

            // Split by comma for multi-team players
            const teams = mlbTeam.split(',').map(t => {
                const trimmed = t.trim().toUpperCase();
                return displayMap[trimmed] || trimmed;
            });

            return teams.join(', ');
        }

        function getMLBTeamLogo(mlbTeam, playerPosition) {
            if (!mlbTeam) return null;

            // Normalize input - for multi-team players (e.g., "ARI, SEA"), use the last team
            let team = mlbTeam.trim();
            if (team.includes(',')) {
                const teams = team.split(',').map(t => t.trim());
                team = teams[teams.length - 1]; // Use last/current team
            }

            // Direct abbreviation mappings (most reliable)
            // Covers both Fangraphs and Yahoo abbreviation styles
            const abbreviationMap = {
                // American League East
                'BAL': 'bal', 'BOS': 'bos', 'NYY': 'nyy', 'TB': 'tb', 'TBR': 'tb', 'TAM': 'tb', 'TOR': 'tor',
                // American League Central  
                'CWS': 'chw', 'CHW': 'chw', 'CLE': 'cle', 'DET': 'det', 'KC': 'kc', 'KCR': 'kc', 'MIN': 'min',
                // American League West
                'HOU': 'hou', 'LAA': 'laa', 'ANA': 'laa', 'OAK': 'oak', 'ATH': 'oak', 'SEA': 'sea', 'TEX': 'tex',
                // National League East
                'ATL': 'atl', 'MIA': 'mia', 'FLA': 'mia', 'NYM': 'nym', 'PHI': 'phi', 'WSH': 'wsh', 'WAS': 'wsh', 'WSN': 'wsh',
                // National League Central
                'CHC': 'chc', 'CIN': 'cin', 'MIL': 'mil', 'PIT': 'pit', 'STL': 'stl',
                // National League West
                'ARI': 'ari', 'AZ': 'ari', 'COL': 'col', 'LAD': 'lad', 'SD': 'sd', 'SDP': 'sd', 'SF': 'sf', 'SFG': 'sf'
            };

            // Check abbreviation first
            if (abbreviationMap[team]) {
                return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbreviationMap[team]}.png`;
            }

            // Nickname mappings (unambiguous)
            const nicknameMap = {
                'Orioles': 'bal', 'Red Sox': 'bos', 'Yankees': 'nyy', 'Rays': 'tb', 'Blue Jays': 'tor',
                'White Sox': 'chw', 'Guardians': 'cle', 'Indians': 'cle', 'Tigers': 'det', 'Royals': 'kc', 'Twins': 'min',
                'Astros': 'hou', 'Angels': 'laa', 'Athletics': 'oak', "A's": 'oak', 'Mariners': 'sea', 'Rangers': 'tex',
                'Braves': 'atl', 'Marlins': 'mia', 'Mets': 'nym', 'Phillies': 'phi', 'Nationals': 'wsh',
                'Cubs': 'chc', 'Reds': 'cin', 'Brewers': 'mil', 'Pirates': 'pit', 'Cardinals': 'stl',
                'Diamondbacks': 'ari', 'D-backs': 'ari', 'Rockies': 'col', 'Dodgers': 'lad', 'Padres': 'sd', 'Giants': 'sf'
            };

            // Check if team contains a nickname
            for (const [nickname, abbrev] of Object.entries(nicknameMap)) {
                if (team.includes(nickname)) {
                    return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbrev}.png`;
                }
            }

            // Convert to uppercase for case-insensitive city matching
            const teamUpper = team.toUpperCase();

            // Unambiguous city mappings (uppercase for comparison)
            const cityMap = {
                'BALTIMORE': 'bal', 'BOSTON': 'bos', 'TAMPA BAY': 'tb', 'TORONTO': 'tor',
                'CLEVELAND': 'cle', 'DETROIT': 'det', 'KANSAS CITY': 'kc', 'MINNESOTA': 'min',
                'HOUSTON': 'hou', 'OAKLAND': 'oak', 'SEATTLE': 'sea', 'TEXAS': 'tex',
                'ATLANTA': 'atl', 'MIAMI': 'mia', 'PHILADELPHIA': 'phi', 'WASHINGTON': 'wsh',
                'CINCINNATI': 'cin', 'MILWAUKEE': 'mil', 'PITTSBURGH': 'pit', 'ST. LOUIS': 'stl', 'ST LOUIS': 'stl',
                'ARIZONA': 'ari', 'COLORADO': 'col', 'SAN DIEGO': 'sd', 'SAN FRANCISCO': 'sf'
            };

            // Check unambiguous cities
            for (const [city, abbrev] of Object.entries(cityMap)) {
                if (teamUpper.includes(city)) {
                    return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbrev}.png`;
                }
            }

            // Handle ambiguous cities - use MLB logo as fallback or make best guess
            // New York, Los Angeles, Chicago all have 2 teams
            if (teamUpper === 'NEW YORK' || teamUpper === 'NY') {
                // Default to Yankees (more popular), but this is a guess
                return `https://a.espncdn.com/i/teamlogos/mlb/500/nyy.png`;
            }
            if (teamUpper === 'LOS ANGELES' || teamUpper === 'LA') {
                // Default to Dodgers (more popular)
                return `https://a.espncdn.com/i/teamlogos/mlb/500/lad.png`;
            }
            if (teamUpper === 'CHICAGO' || teamUpper === 'CHI') {
                // Default to Cubs (more popular)
                return `https://a.espncdn.com/i/teamlogos/mlb/500/chc.png`;
            }

            return null;
        }

        async function showPlayerDetail(playerName) {
            const modal = document.getElementById('player-modal');
            const headerEl = document.getElementById('player-modal-header');
            const bodyEl = document.getElementById('player-modal-body');

            // Find player in current data
            const player = allPlayersData.find(p => p.name === playerName);
            if (!player) return;

            // Store current player for modal stat toggle
            window.currentModalPlayer = player;

            const seasonSelect = document.getElementById('scoring-season');
            const selectedYear = parseInt(seasonSelect.value);

            // Load player history if not cached
            if (Object.keys(playerHistoryData).length === 0) {
                try {
                    const historyResponse = await fetch('data/players/player_history.json');
                    if (historyResponse.ok) {
                        playerHistoryData = await historyResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load player history');
                }
            }

            // Placeholders
            const placeholderHeadshot = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFlM2M3MiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZiI+4pqB77iPPC90ZXh0Pjwvc3ZnPg==';

            // Try to get action shot from MLB CDN using player's MLB ID
            let mlbId = null;
            if (player.headshot_url && player.headshot_url.includes('/people/')) {
                const match = player.headshot_url.match(/\/people\/(\d+)\//);
                if (match) mlbId = match[1];
            }
            
            const actionShotUrl = mlbId 
                ? `https://img.mlbstatic.com/mlb-photos/image/upload/d_people:generic:action:hero:current.png/q_auto:best/v1/people/${mlbId}/action/hero/current`
                : null;
            const headshot = (player.headshot_url && player.headshot_url.trim()) ? player.headshot_url : placeholderHeadshot;
            
            const mlbLogoUrl = getMLBTeamLogo(player.mlb_team);
            const mlbTeamText = formatMLBTeamDisplay(player.mlb_team);
            const hasMlbLogo = mlbTeamText !== 'FA' && mlbLogoUrl;

            // Check if player has a fantasy team
            const hasFantasyTeam = player.team_key && player.team_key.trim() && player.team_logo && player.team_name && player.team_name !== 'Free Agent' && player.team_name !== 'Drafted (Dropped)' && player.team_name !== 'Previously Rostered';

            const stats = getPlayerStats(player);
            const isBatter = player.position_type === 'B';
            const fantasyPts = getPlayerFantasyPoints(player).toFixed(1);

            // Calculate position rank for current season (using current stat type)
            const primaryPos = player.primary_position;
            const samePos = allPlayersData
                .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            const posRank = samePos.findIndex(p => p.name === player.name) + 1;
            const posRankDisplay = posRank > 0 ? `${primaryPos}${posRank}` : primaryPos;

            // Load acquisition info (draft data and transactions)
            // Priority: Trade to current team > Waiver pickup > Draft
            let acquisitionHtml = '';
            let draftInfo = null;
            let tradeInfo = null;
            let pickupInfo = null;

            try {
                // Load draft data
                let draftResponse;
                if (selectedYear === 2026) {
                    draftResponse = await fetch('data/current_season/draft.json');
                } else {
                    draftResponse = await fetch(`data/historical/${selectedYear}/draft.json`);
                }

                if (draftResponse.ok) {
                    const draftData = await draftResponse.json();
                    const draftPick = draftData.find(pick =>
                        pick.player_name && pick.player_name.toLowerCase() === player.name.toLowerCase()
                    );
                    if (draftPick) {
                        draftInfo = { round: draftPick.round, pick: draftPick.pick, team_key: draftPick.team_key };
                    }
                }

                // Load transaction data
                let transResponse;
                if (selectedYear === 2026) {
                    transResponse = await fetch('data/current_season/transactions.json');
                } else {
                    transResponse = await fetch(`data/historical/${selectedYear}/transactions.json`);
                }

                if (transResponse && transResponse.ok) {
                    const transData = await transResponse.json();

                    // Find all transactions involving this player where they were added to current team
                    const playerTransactions = transData.filter(t => {
                        if (!t.players) return false;
                        return t.players.some(p =>
                            p.name && p.name.toLowerCase() === player.name.toLowerCase() &&
                            (p.type === 'add' || p.destination_team_key === player.team_key)
                        );
                    }).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Most recent first

                    // Check for trade to current team
                    for (const trans of playerTransactions) {
                        if (trans.type === 'trade') {
                            const transPlayer = trans.players.find(p =>
                                p.name && p.name.toLowerCase() === player.name.toLowerCase()
                            );
                            // Check if player was added to current team in this trade
                            if (transPlayer && (transPlayer.type === 'add' || transPlayer.destination_team_key === player.team_key)) {
                                let dateStr = '';
                                if (trans.timestamp) {
                                    const date = new Date(trans.timestamp * 1000);
                                    dateStr = `${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
                                }
                                tradeInfo = { date: dateStr };
                                break;
                            }
                        }
                    }

                    // If no trade, check for waiver pickup (only if player wasn't drafted by current team)
                    if (!tradeInfo) {
                        const wasDraftedByCurrentTeam = draftInfo && draftInfo.team_key === player.team_key;

                        if (!wasDraftedByCurrentTeam) {
                            for (const trans of playerTransactions) {
                                if (trans.type === 'add' || trans.type === 'add/drop') {
                                    const transPlayer = trans.players.find(p =>
                                        p.name && p.name.toLowerCase() === player.name.toLowerCase() &&
                                        p.type === 'add'
                                    );
                                    if (transPlayer) {
                                        let dateStr = '';
                                        if (trans.timestamp) {
                                            const date = new Date(trans.timestamp * 1000);
                                            dateStr = `${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
                                        }
                                        pickupInfo = { date: dateStr };
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // Build acquisition HTML based on priority: Trade > Pickup > Draft
                if (tradeInfo) {
                    acquisitionHtml = `<div class="card-acquisition-info"><span class="acq-label">Traded</span>${tradeInfo.date}</div>`;
                } else if (pickupInfo) {
                    acquisitionHtml = `<div class="card-acquisition-info"><span class="acq-label">Picked Up</span>${pickupInfo.date}</div>`;
                } else if (draftInfo) {
                    acquisitionHtml = `<div class="card-acquisition-info"><span class="acq-label">Drafted</span>Rd ${draftInfo.round}, #${draftInfo.pick}</div>`;
                }

            } catch (e) {
                console.log('Could not load acquisition info:', e);
            }

            // Clear header (we're using body for the card)
            headerEl.innerHTML = '';

            // Build acquisition text
            let acquisitionText = '';
            if (tradeInfo) {
                acquisitionText = `Acquired via <strong>Trade</strong> on ${tradeInfo.date}`;
            } else if (pickupInfo) {
                acquisitionText = `<strong>Picked up</strong> on ${pickupInfo.date}`;
            } else if (draftInfo) {
                acquisitionText = `<strong>Drafted</strong> Round ${draftInfo.round}, Pick #${draftInfo.pick}`;
            }

            // Build 1987 Topps style horizontal baseball card HTML
            let cardHTML = `
            <div class="baseball-card">
                <div class="card-inner">
                    <!-- CARD FRONT - Photo Section -->
                    <div class="card-front">
                        <div class="card-photo-wrapper">
                            <!-- MLB Logo - top left corner -->
                            <div class="card-mlb-logo ${hasMlbLogo ? '' : 'fa-badge'}">
                                ${hasMlbLogo 
                                    ? `<img src="${mlbLogoUrl}" alt="${mlbTeamText}" onerror="this.parentElement.classList.add('fa-badge'); this.outerHTML='FA';">` 
                                    : 'FA'}
                            </div>
                            
                            <!-- Fantasy Logo - bottom right corner -->
                            <div class="card-fantasy-logo ${hasFantasyTeam ? '' : 'fa-badge'}">
                                ${hasFantasyTeam 
                                    ? `<img src="${fixTeamLogo(player.team_logo)}" alt="" onerror="this.parentElement.classList.add('fa-badge'); this.outerHTML='FA';">` 
                                    : 'FA'}
                            </div>
                            
                            <div class="card-photo-container">
                                ${actionShotUrl 
                                    ? `<img src="${actionShotUrl}" alt="${player.name}" class="card-action-shot" onerror="this.className='card-headshot-fallback'; this.src='${headshot}';">` 
                                    : `<img src="${headshot}" alt="${player.name}" class="card-headshot-fallback" onerror="this.src='${placeholderHeadshot}';">`}
                            </div>
                        </div>
                        
                        <!-- Player Name Banner -->
                        <div class="card-name-banner">
                            <span class="card-year-badge">${selectedYear}</span>
                            <span class="card-player-name">${player.name}</span>
                            <span class="card-position-badge">${player.primary_position}</span>
                        </div>
                    </div>
                    
                    <!-- CARD BACK - Stats Section -->
                    <div class="card-back">
                        <!-- Header with headshot -->
                        <div class="card-back-header">
                            <div class="card-back-number">#${posRank || '??'}</div>
                            <div class="card-back-info">
                                <div class="card-back-name">${player.name}</div>
                                <div class="card-back-team">${mlbTeamText}  ${hasFantasyTeam ? player.team_name : 'Free Agent'}</div>
                            </div>
                            <img src="${headshot}" alt="" class="card-back-headshot" onerror="this.src='${placeholderHeadshot}';">
                        </div>
                        
                        <!-- Stats Toggle -->
                        <div class="card-stats-toggle">
                            <span class="card-stats-title">${selectedYear} Statistics</span>
                            <div class="card-toggle-btns">
                                <button class="card-toggle-btn ${currentStatType === 'fantasy' ? 'active' : ''}" onclick="setModalStatType('fantasy')">Fantasy</button>
                                <button class="card-toggle-btn ${currentStatType === 'full' ? 'active' : ''}" onclick="setModalStatType('full')">Full MLB</button>
                            </div>
                        </div>
                        
                        <div id="modal-stats-content">`;

            if (isBatter) {
                cardHTML += `
                        <div class="card-stats-row">
                            <div class="card-stats-label">SEASON</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">G</div>
                                <div class="card-stats-header-cell">AB</div>
                                <div class="card-stats-header-cell">H</div>
                                <div class="card-stats-header-cell">HR</div>
                                <div class="card-stats-header-cell">RBI</div>
                                <div class="card-stats-header-cell">SB</div>
                                <div class="card-stats-header-cell">AVG</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label">${selectedYear}</div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.G || 0}</div>
                                <div class="card-stats-data-cell">${stats.AB || 0}</div>
                                <div class="card-stats-data-cell">${stats.H || 0}</div>
                                <div class="card-stats-data-cell">${stats.HR || 0}</div>
                                <div class="card-stats-data-cell">${stats.RBI || 0}</div>
                                <div class="card-stats-data-cell">${stats.SB || 0}</div>
                                <div class="card-stats-data-cell">${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</div>
                            </div>
                        </div>
                        <div class="card-stats-row">
                            <div class="card-stats-label">MORE</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">R</div>
                                <div class="card-stats-header-cell">BB</div>
                                <div class="card-stats-header-cell">2B</div>
                                <div class="card-stats-header-cell">3B</div>
                                <div class="card-stats-header-cell">OBP</div>
                                <div class="card-stats-header-cell">SLG</div>
                                <div class="card-stats-header-cell">OPS</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label"></div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.R || 0}</div>
                                <div class="card-stats-data-cell">${stats.BB || 0}</div>
                                <div class="card-stats-data-cell">${stats['2B'] || 0}</div>
                                <div class="card-stats-data-cell">${stats['3B'] || 0}</div>
                                <div class="card-stats-data-cell">${stats.OBP ? stats.OBP.toFixed(3) : '.000'}</div>
                                <div class="card-stats-data-cell">${stats.SLG ? stats.SLG.toFixed(3) : '.000'}</div>
                                <div class="card-stats-data-cell">${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</div>
                            </div>
                        </div>`;
            } else {
                cardHTML += `
                        <div class="card-stats-row">
                            <div class="card-stats-label">SEASON</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">W</div>
                                <div class="card-stats-header-cell">L</div>
                                <div class="card-stats-header-cell">SV</div>
                                <div class="card-stats-header-cell">G</div>
                                <div class="card-stats-header-cell">IP</div>
                                <div class="card-stats-header-cell">K</div>
                                <div class="card-stats-header-cell">ERA</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label">${selectedYear}</div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.W || 0}</div>
                                <div class="card-stats-data-cell">${stats.L || 0}</div>
                                <div class="card-stats-data-cell">${stats.SV || 0}</div>
                                <div class="card-stats-data-cell">${stats.G || 0}</div>
                                <div class="card-stats-data-cell">${stats.IP || 0}</div>
                                <div class="card-stats-data-cell">${stats.SO || 0}</div>
                                <div class="card-stats-data-cell">${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</div>
                            </div>
                        </div>
                        <div class="card-stats-row">
                            <div class="card-stats-label">MORE</div>
                            <div class="card-stats-cells">
                                <div class="card-stats-header-cell">GS</div>
                                <div class="card-stats-header-cell">HLD</div>
                                <div class="card-stats-header-cell">BB</div>
                                <div class="card-stats-header-cell">WHIP</div>
                                <div class="card-stats-header-cell">K/9</div>
                                <div class="card-stats-header-cell">K%</div>
                                <div class="card-stats-header-cell">BB%</div>
                            </div>
                        </div>
                        <div class="card-stats-data-row">
                            <div class="card-stats-data-label"></div>
                            <div class="card-stats-data-cells">
                                <div class="card-stats-data-cell">${stats.GS || 0}</div>
                                <div class="card-stats-data-cell">${stats.HLD || 0}</div>
                                <div class="card-stats-data-cell">${stats.BB || 0}</div>
                                <div class="card-stats-data-cell">${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</div>
                                <div class="card-stats-data-cell">${stats['K/9'] ? stats['K/9'].toFixed(1) : '0.0'}</div>
                                <div class="card-stats-data-cell">${stats['K%'] ? stats['K%'].toFixed(0) : '0'}%</div>
                                <div class="card-stats-data-cell">${stats['BB%'] ? stats['BB%'].toFixed(0) : '0'}%</div>
                            </div>
                        </div>`;
            }

            cardHTML += `</div>`; // Close modal-stats-content

            // Fantasy points row
            cardHTML += `
                        <div class="card-points-row">
                            <span class="card-points-label">Fantasy Points</span>
                            <span class="card-points-value">${fantasyPts}</span>
                            <span class="card-points-rank">${posRankDisplay}</span>
                        </div>`;

            // Draft info row
            let draftDisplayText = 'Undrafted';
            if (draftInfo) {
                draftDisplayText = `Round ${draftInfo.round}, Pick #${draftInfo.pick}`;
            }
            cardHTML += `
                        <div class="card-draft-row">
                            <span class="card-draft-label">${selectedYear} Draft:</span>
                            <span class="card-draft-value">${draftDisplayText}</span>
                        </div>`;

            // Acquisition info (trades/pickups)
            if (acquisitionText && !acquisitionText.includes('Drafted')) {
                cardHTML += `<div class="card-acquisition-row">${acquisitionText}</div>`;
            }

            // Career history section
            const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const playerHistory = playerHistoryData[normalizedName];

            if (playerHistory && playerHistory.seasons && playerHistory.seasons.length > 0) {
                const historyLogos = {};
                const historyRanks = {};

                for (const season of playerHistory.seasons) {
                    const teams = await getTeamData(season.year);
                    if (teams) {
                        const team = teams.find(t => t.team_name === season.team_name);
                        if (team) {
                            historyLogos[`${season.year}_${season.team_name}`] = fixTeamLogo(team.team_logo);
                        }
                    }

                    const yearPlayers = await getPlayerStatsData(season.year);
                    if (yearPlayers) {
                        const sameType = yearPlayers
                            .filter(p => p.position_type === player.position_type)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const overallRank = sameType.findIndex(p => p.name === player.name) + 1;

                        const primaryPos = player.primary_position;
                        const samePos = yearPlayers
                            .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const posRank = samePos.findIndex(p => p.name === player.name) + 1;

                        historyRanks[season.year] = {
                            overall: overallRank > 0 ? overallRank : '-',
                            position: posRank > 0 ? `${primaryPos}${posRank}` : '-'
                        };
                    } else {
                        historyRanks[season.year] = { overall: '-', position: '-' };
                    }
                }

                cardHTML += `
                        <div class="card-history-wrapper">
                            <div class="card-history-title">League History</div>`;

                playerHistory.seasons.sort((a, b) => b.year - a.year).forEach(season => {
                    const logo = historyLogos[`${season.year}_${season.team_name}`] || '';
                    const ranks = historyRanks[season.year] || { overall: '-', position: '-' };
                    cardHTML += `
                            <div class="card-history-row">
                                <span class="card-history-year">${season.year}</span>
                                ${logo ? `<img src="${logo}" class="card-history-logo" alt="">` : ''}
                                <span class="card-history-manager">${season.manager || ''}</span>
                                <span class="card-history-pts">${(season.fantasy_points || 0).toFixed(0)} pts</span>
                                <span class="card-history-rank">${ranks.position}</span>
                            </div>`;
                });

                cardHTML += `</div>`;
            }

            // Manager footer with league info
            cardHTML += `
                        <div class="card-manager-footer">
                            <div class="card-manager-text">
                                <span>Manager:</span> <span class="card-manager-name">${player.manager || 'Free Agent'}</span>
                            </div>
                            <div class="card-league-info">
                                <img src="league_logo.png" alt="FBCW" class="card-league-logo" onerror="this.style.display='none'">
                                <span class="card-league-text">FBCW</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;

            bodyEl.innerHTML = cardHTML;
            modal.classList.add('active');
            document.body.classList.add('modal-open');
        }

        function closePlayerModal() {
            document.getElementById('player-modal').classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Close player modal on outside click
        document.getElementById('player-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closePlayerModal();
            }
        });

        // ===== MANAGER NAME NORMALIZATION =====
        const MANAGER_TEAM_2023 = {
            "Draft Pool": "Logan C",
            "Peanut Butter & Elly": "Logan S"
        };

        // Logan team keys for 2023 disambiguation
        const LOGAN_TEAM_KEYS_2023 = {
            "422.l.6780.t.4": "Logan C",   // Draft Pool
            "422.l.6780.t.12": "Logan S"   // Peanut Butter & Elly
        };

        // Simple helper to capitalize manager names for display
        function capitalizeManagerName(name) {
            if (!name) return '';
            return name.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function normalizeManagerName(managerName, year = null, teamName = null, teamKey = null) {
            // Convert to title case
            let normalized = managerName.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            // Handle Logan disambiguation
            if (normalized === "Logan") {
                if (year === 2023 && teamName && MANAGER_TEAM_2023[teamName]) {
                    return MANAGER_TEAM_2023[teamName];
                }
                if (year && year >= 2020 && year <= 2022) {
                    return "Logan C";
                } else if (year && year >= 2024) {
                    return "Logan S";
                }
            }

            // Handle Josh disambiguation (2019-2022)
            if (normalized === "Josh") {
                if (year && year >= 2019 && year <= 2022) {
                    if (teamKey && teamKey.endsWith('t.1')) {
                        return "Josh B";
                    } else {
                        return "Josh S";
                    }
                } else if (year && year >= 2023) {
                    // After 2022, only Josh B remains
                    if (teamKey && teamKey.endsWith('t.1')) {
                        return "Josh B";
                    }
                }
            }

            return normalized;
        }

        // Helper function to replace Josh B's GIF logo with static PNG
        function fixTeamLogo(logoUrl) {
            if (!logoUrl) return logoUrl;
            // Check if it's Josh B's Charmander GIF and replace with static PNG
            // The actual URL contains: 25231662271_f6454b2bed.gif
            if (logoUrl.includes('25231662271_f6454b2bed.gif') || 
                (logoUrl.includes('.gif') && logoUrl.includes('fantasy-logos'))) {
                return 'data/managers/joshb_logo.png';
            }
            return logoUrl;
        }
        
        // Cache for 2026 team logos by normalized manager name
        let currentTeamLogosCache = null;
        
        async function getCurrentTeamLogo(managerName, teamKey = null) {
            // Build cache if not already built
            if (!currentTeamLogosCache) {
                currentTeamLogosCache = {};
                const currentTeams = await getTeamData(2026);
                if (currentTeams) {
                    currentTeams.forEach(team => {
                        // Use normalized manager name for consistent matching
                        const normalizedManager = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                        const managerLower = normalizedManager.toLowerCase();
                        currentTeamLogosCache[managerLower] = fixTeamLogo(team.team_logo);
                    });
                }
            }
            
            // Normalize the input manager name for lookup
            const normalizedInput = normalizeManagerName(managerName, 2026, null, teamKey);
            const managerLower = normalizedInput.toLowerCase();
            return currentTeamLogosCache[managerLower] || null;
        }

        function normalizeStandingsData(standings, year) {
            return standings.map(team => ({
                ...team,
                manager: normalizeManagerName(team.manager, year, team.team_name, team.team_key)
            }));
        }

        function normalizeAndMergeManagerData(managersData, historyData) {
            const managerMap = {};

            console.log("Processing managers:", managersData.length);

            // Process each manager's data
            managersData.forEach(manager => {
                // Determine normalized name based on season history
                let normalizedName = manager.manager_name.trim()
                    .toLowerCase()
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');

                // Handle Logan based on team keys in 2023 or years active
                if (normalizedName === "Logan") {
                    console.log("Found Logan:", manager.season_history);

                    // Check if they have 2023 season
                    const season2023 = manager.season_history.find(s => s.year === 2023);

                    if (season2023) {
                        console.log("Logan has 2023, team:", season2023.team_name);
                        // Use team name to distinguish
                        if (season2023.team_name.includes("Draft Pool")) {
                            normalizedName = "Logan C";
                            console.log("-> Logan C (Draft Pool)");
                        } else if (season2023.team_name.includes("Peanut Butter") || season2023.team_name.includes("Elly")) {
                            normalizedName = "Logan S";
                            console.log("-> Logan S (Peanut Butter & Elly)");
                        } else {
                            console.log("-> Unknown team in 2023:", season2023.team_name);
                        }
                    } else {
                        // No 2023 season - use years to determine
                        const years = manager.season_history.map(s => s.year);
                        const maxYear = Math.max(...years);
                        const minYear = Math.min(...years);

                        console.log("Logan years:", years, "min:", minYear, "max:", maxYear);

                        if (maxYear <= 2022) {
                            // Only played 2020-2022 = Logan C
                            normalizedName = "Logan C";
                            console.log("-> Logan C (only 2020-2022)");
                        } else if (minYear >= 2024) {
                            // Only played 2024+ = Logan S
                            normalizedName = "Logan S";
                            console.log("-> Logan S (only 2024+)");
                        } else {
                            console.log("-> Logan with unclear years");
                        }
                    }
                }

                // Normalize season history
                const normalizedSeasonHistory = manager.season_history.map(season => ({
                    ...season
                }));

                // DON'T merge different Logans - only merge case variations
                const shouldMerge = managerMap[normalizedName] &&
                    !(normalizedName === "Logan C" || normalizedName === "Logan S");

                if (shouldMerge) {
                    console.log("Merging into existing manager:", normalizedName);
                    // Merge stats
                    managerMap[normalizedName].total_wins += manager.total_wins;
                    managerMap[normalizedName].total_losses += manager.total_losses;
                    managerMap[normalizedName].total_ties += manager.total_ties;
                    managerMap[normalizedName].total_points_for += manager.total_points_for;
                    managerMap[normalizedName].championships += manager.championships;
                    managerMap[normalizedName].runner_ups += manager.runner_ups;
                    managerMap[normalizedName].playoff_appearances += manager.playoff_appearances;
                    managerMap[normalizedName].seasons_played += manager.seasons_played;

                    // Merge season history
                    managerMap[normalizedName].season_history = [
                        ...managerMap[normalizedName].season_history,
                        ...normalizedSeasonHistory
                    ];

                    // Update first season
                    managerMap[normalizedName].first_season = Math.min(
                        managerMap[normalizedName].first_season,
                        manager.first_season
                    );
                } else {
                    console.log("Creating new manager entry:", normalizedName);
                    // New manager entry
                    managerMap[normalizedName] = {
                        ...manager,
                        manager_name: normalizedName,
                        season_history: normalizedSeasonHistory
                    };
                }
            });

            console.log("Final managers:", Object.keys(managerMap));

            // Recalculate derived stats for merged managers
            Object.values(managerMap).forEach(manager => {
                const totalGames = manager.total_wins + manager.total_losses;
                manager.win_pct = totalGames > 0 ? manager.total_wins / totalGames : 0;
                manager.avg_finish = manager.season_history.length > 0
                    ? manager.season_history.reduce((sum, s) => sum + s.rank, 0) / manager.season_history.length
                    : 0;

                // Sort season history by year
                manager.season_history.sort((a, b) => a.year - b.year);
            });

            return Object.values(managerMap);
        }

        // Split Logan's stats for 2023 based on team_key
        async function splitLogan2023Stats() {
            try {
                // Load 2023 standings and scores
                const standingsResponse = await fetch('data/historical/2023/final_standings.json');
                const scoresResponse = await fetch('data/historical/2023/all_scores.json');

                if (!standingsResponse.ok || !scoresResponse.ok) {
                    console.log("Could not load 2023 data for Logan split");
                    return null;
                }

                const standings = await standingsResponse.json();
                const scores = await scoresResponse.json();

                // Find Logan's teams by team_key
                const loganCTeam = standings.find(t => t.team_key === "422.l.6780.t.4");
                const loganSTeam = standings.find(t => t.team_key === "422.l.6780.t.12");

                if (!loganCTeam && !loganSTeam) {
                    console.log("Could not find Logan team keys in 2023 standings");
                    return null;
                }

                // Calculate stats for each Logan based on team_key
                const loganStats = {
                    "Logan C": loganCTeam ? {
                        team_key: loganCTeam.team_key,
                        team_name: loganCTeam.team_name,
                        rank: loganCTeam.rank,
                        wins: loganCTeam.wins,
                        losses: loganCTeam.losses,
                        ties: loganCTeam.ties,
                        points_for: loganCTeam.points_for
                    } : null,
                    "Logan S": loganSTeam ? {
                        team_key: loganSTeam.team_key,
                        team_name: loganSTeam.team_name,
                        rank: loganSTeam.rank,
                        wins: loganSTeam.wins,
                        losses: loganSTeam.losses,
                        ties: loganSTeam.ties,
                        points_for: loganSTeam.points_for
                    } : null
                };

                console.log("Split Logan 2023 stats:", loganStats);
                return loganStats;

            } catch (error) {
                console.error("Error splitting Logan stats:", error);
                return null;
            }
        }

        // Apply Logan split to manager data
        async function applyLogan2023Split(managersData) {
            const logan2023Stats = await splitLogan2023Stats();

            if (!logan2023Stats) {
                console.log("No Logan split needed or data unavailable");
                return managersData;
            }

            // Update each Logan's 2023 season data
            managersData.forEach(manager => {
                if ((manager.manager_name === "Logan C" || manager.manager_name === "Logan S") && logan2023Stats[manager.manager_name]) {
                    const season2023Index = manager.season_history.findIndex(s => s.year === 2023);

                    if (season2023Index >= 0) {
                        // Update with correct stats
                        const stats = logan2023Stats[manager.manager_name];
                        manager.season_history[season2023Index] = {
                            year: 2023,
                            team_name: stats.team_name,
                            rank: stats.rank,
                            wins: stats.wins,
                            losses: stats.losses,
                            points_for: stats.points_for
                        };

                        // Recalculate totals
                        manager.total_wins = manager.season_history.reduce((sum, s) => sum + s.wins, 0);
                        manager.total_losses = manager.season_history.reduce((sum, s) => sum + s.losses, 0);
                        manager.total_points_for = manager.season_history.reduce((sum, s) => sum + s.points_for, 0);
                        manager.win_pct = manager.total_wins / (manager.total_wins + manager.total_losses);
                        manager.avg_finish = manager.season_history.reduce((sum, s) => sum + s.rank, 0) / manager.season_history.length;

                        console.log(`Updated ${manager.manager_name} with 2023 stats`);
                    }
                }
            });

            return managersData;
        }

        // ===== INITIALIZE SEASON SELECTORS =====
        async function initializeSeasonSelectors() {
            const standingsSelect = document.getElementById('standings-season');
            standingsSelect.innerHTML = '<option value="">Loading seasons...</option>';

            // Try to detect available seasons by checking for data files
            const possibleSeasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const availableSeasons = [];

            // Check for 2026 current season (in data/current_season/)
            try {
                const response = await fetch('data/current_season/teams.json');
                if (response.ok) {
                    availableSeasons.push({ year: 2026, isCurrent: true, label: '2026 (In Progress)' });
                }
            } catch (e) { }

            // Check historical seasons (all now use final_standings.json)
            for (const year of possibleSeasons) {
                try {
                    const response = await fetch(`data/historical/${year}/final_standings.json`);
                    if (response.ok) {
                        availableSeasons.push({ year: year, isCurrent: false, label: year.toString() });
                    }
                } catch (e) { }
            }

            // Sort by year descending
            availableSeasons.sort((a, b) => b.year - a.year);

            // Populate dropdown
            standingsSelect.innerHTML = '';
            availableSeasons.forEach(season => {
                const option = document.createElement('option');
                option.value = season.year;
                option.textContent = season.label;
                // Default to 2026 (current season) if available, else most recent
                if (season.year === 2026) {
                    option.selected = true;
                }
                standingsSelect.appendChild(option);
            });

            // Populate scoring dropdown the same way
            const scoringSelect = document.getElementById('scoring-season');
            scoringSelect.innerHTML = standingsSelect.innerHTML;
            // Default scoring to most recent completed season (2025)
            scoringSelect.value = '2025';


            return availableSeasons;
        }

        // ===== LOAD STANDINGS BY SEASON =====
        async function loadStandingsBySeason() {
            const season = document.getElementById('standings-season').value;
            const loadingEl = document.getElementById('standings-loading');
            const errorEl = document.getElementById('standings-error');
            const tableEl = document.getElementById('standings-table');
            const chartContainer = document.getElementById('season-chart-container');
            const inseasonContainer = document.getElementById('inseason-tools-container');
            const draftGradesTicker = document.getElementById('draft-performance-ticker');
            const matchupsTicker = document.getElementById('matchups-ticker');
            const bracketContainer = document.getElementById('playoff-bracket-container');
            const standingsTitle = document.getElementById('standings-panel-title');
            const headerWeekSelector = document.getElementById('header-week-selector');

            if (!season) {
                return; // No season selected yet
            }
            
            const seasonNum = parseInt(season);
            
            // Hide all containers initially
            chartContainer.style.display = 'none';
            inseasonContainer.style.display = 'none';
            if (draftGradesTicker) draftGradesTicker.style.display = 'none';
            if (matchupsTicker) matchupsTicker.style.display = 'none';
            if (bracketContainer) bracketContainer.style.display = 'none';
            
            // Hide week selector and reset title for historical seasons
            if (headerWeekSelector) headerWeekSelector.style.display = 'none';
            if (standingsTitle) standingsTitle.textContent = 'Final Standings';
            
            // Clear matchups ticker interval if switching away from 2026
            if (matchupsTickerInterval) {
                clearInterval(matchupsTickerInterval);
                matchupsTickerInterval = null;
            }

            // Special handling for 2026 (in-season/upcoming)
            if (seasonNum === 2026) {
                await load2026Season();
                return;
            }

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                tableEl.style.display = 'none';

                let response;
                let teamsResponse;
                let isCurrentSeason = seasonNum === 2026;

                if (seasonNum === 2026) {
                    // Current season uses current_season folder
                    response = await fetch('data/current_season/standings.json');
                    teamsResponse = await fetch('data/current_season/teams.json');
                } else {
                    // All historical seasons use final_standings.json
                    response = await fetch(`data/historical/${season}/final_standings.json`);
                    teamsResponse = await fetch(`data/historical/${season}/teams.json`);
                }

                if (!response.ok) {
                    throw new Error(`Data not found for ${season}`);
                }

                let standings = await response.json();

                // Load team logos
                let teamLogos = {};
                let teamData = [];
                if (teamsResponse.ok) {
                    teamData = await teamsResponse.json();
                    teamData.forEach(team => {
                        teamLogos[team.team_key] = fixTeamLogo(team.team_logo);
                    });
                }

                // Normalize manager names
                standings = normalizeStandingsData(standings, seasonNum);

                // Sort by rank to ensure proper ordering
                standings.sort((a, b) => a.rank - b.rank);

                // Populate the table
                const tbody = document.getElementById('standings-body');
                tbody.innerHTML = '';

                standings.forEach(team => {
                    const row = document.createElement('tr');
                    const logo = teamLogos[team.team_key] ? `<img src="${teamLogos[team.team_key]}" class="team-logo" alt="Team Logo">` : '';

                    // Add medals for top 3
                    let medal = '';
                    if (team.rank === 1) medal = '';
                    else if (team.rank === 2) medal = '';
                    else if (team.rank === 3) medal = '';

                    row.innerHTML = `
                        <td>${medal}${team.rank}</td>
                        <td><div class="manager-cell">${team.manager}</div></td>
                        <td><div class="team-cell-content">${logo}<span>${team.team_name}</span></div></td>
                        <td>${team.wins}</td>
                        <td>${team.losses}</td>
                        <td>${team.win_pct.toFixed(3)}</td>
                        <td>${Math.round(team.points_for).toLocaleString()}</td>
                    `;
                    tbody.appendChild(row);
                });

                loadingEl.style.display = 'none';
                tableEl.style.display = 'table';

                // Load draft data for this season
                await loadDraftResults(seasonNum, isCurrentSeason, teamLogos, teamData);

                // Load playoff bracket for historical seasons
                if (!isCurrentSeason && seasonNum < 2026) {
                    await loadPlayoffBracket(seasonNum, standings, teamData);
                }

                // Load and render the season chart
                await loadSeasonChart(seasonNum, isCurrentSeason, standings, teamLogos, teamData);
                
                // Explicitly hide matchups ticker (only for 2026)
                const matchupsTickerEl = document.getElementById('matchups-ticker');
                if (matchupsTickerEl) {
                    matchupsTickerEl.style.display = 'none';
                }
                
                // Clear matchups ticker interval
                if (matchupsTickerInterval) {
                    clearInterval(matchupsTickerInterval);
                    matchupsTickerInterval = null;
                }
                
                // Load draft performance ticker (for completed seasons)
                await loadDraftPerformanceTicker(seasonNum, isCurrentSeason, teamLogos, teamData);

            } catch (error) {
                console.error('Error loading standings:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading ${season} standings: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }
        
        // ===== LOAD 2026 SEASON (IN-SEASON TOOLS) =====
        let current2026StatsType = 'hitting';
        
        async function load2026Season() {
            const loadingEl = document.getElementById('standings-loading');
            const errorEl = document.getElementById('standings-error');
            const tableEl = document.getElementById('standings-table');
            const chartContainer = document.getElementById('season-chart-container');
            const inseasonContainer = document.getElementById('inseason-tools-container');
            const draftGradesTicker = document.getElementById('draft-performance-ticker');
            const standingsTitle = document.getElementById('standings-panel-title');
            const headerWeekSelector = document.getElementById('header-week-selector');
            
            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            tableEl.style.display = 'none';
            chartContainer.style.display = 'none';
            if (draftGradesTicker) draftGradesTicker.style.display = 'none';
            
            // Show week selector and change title for 2026
            if (headerWeekSelector) headerWeekSelector.style.display = 'flex';
            if (standingsTitle) standingsTitle.textContent = 'Standings';
            
            try {
                // Load teams data for 2026
                const teamsResponse = await fetch('data/current_season/teams.json');
                let teamData = [];
                let teamLogos = {};
                
                if (teamsResponse.ok) {
                    teamData = await teamsResponse.json();
                    teamData.forEach(team => {
                        teamLogos[team.team_key] = fixTeamLogo(team.team_logo);
                    });
                }
                
                // Load all_scores for schedule modal - try all_scores.json first, then individual week files
                let allScores = [];
                try {
                    const scoresResponse = await fetch('data/current_season/all_scores.json');
                    if (scoresResponse.ok) {
                        allScores = await scoresResponse.json();
                    }
                } catch (e) {
                    console.log('No all_scores.json yet');
                }
                
                // If all_scores is empty or incomplete, load individual week files
                const weeksInAllScores = new Set(allScores.map(s => s.week));
                if (weeksInAllScores.size < 21) {
                    // Load all 24 week files in parallel
                    const weekPromises = [];
                    for (let week = 1; week <= 24; week++) {
                        if (!weeksInAllScores.has(week)) {
                            weekPromises.push(
                                fetch(`data/current_season/week_${week}_scores.json`)
                                    .then(r => r.ok ? r.json() : [])
                                    .catch(() => [])
                            );
                        }
                    }
                    const weekResults = await Promise.all(weekPromises);
                    weekResults.forEach(weekData => {
                        if (weekData && weekData.length > 0) {
                            allScores = allScores.concat(weekData);
                        }
                    });
                }
                
                // Store globally for schedule modal
                window.cached2026Data = {
                    teamData,
                    teamLogos,
                    allScores
                };
                
                // Try to load standings (may not exist yet)
                let standings = [];
                try {
                    const standingsResponse = await fetch('data/current_season/standings.json');
                    if (standingsResponse.ok) {
                        standings = await standingsResponse.json();
                        standings = normalizeStandingsData(standings, 2026);
                        standings.sort((a, b) => a.rank - b.rank);
                    }
                } catch (e) {
                    console.log('No 2026 standings yet');
                }
                
                // Populate standings table if we have data
                const tbody = document.getElementById('standings-body');
                tbody.innerHTML = '';
                
                if (standings.length > 0) {
                    standings.forEach(team => {
                        const row = document.createElement('tr');
                        const logo = teamLogos[team.team_key] ? `<img src="${teamLogos[team.team_key]}" class="team-logo" alt="Team Logo">` : '';
                        
                        let medal = '';
                        if (team.rank === 1) medal = '';
                        else if (team.rank === 2) medal = '';
                        else if (team.rank === 3) medal = '';
                        
                        row.innerHTML = `
                            <td>${medal}${team.rank}</td>
                            <td><div class="manager-cell">${team.manager}</div></td>
                            <td><div class="team-cell-content team-cell-clickable" onclick="openScheduleModal('${team.team_key}')">${logo}<span>${team.team_name}</span></div></td>
                            <td>${team.wins || 0}</td>
                            <td>${team.losses || 0}</td>
                            <td>${(team.win_pct || 0).toFixed(3)}</td>
                            <td>${Math.round(team.points_for || 0).toLocaleString()}</td>
                        `;
                        tbody.appendChild(row);
                    });
                    tableEl.style.display = 'table';
                } else if (teamData.length > 0) {
                    // Show teams without standings
                    teamData.forEach((team, idx) => {
                        const row = document.createElement('tr');
                        const logo = team.team_logo ? `<img src="${fixTeamLogo(team.team_logo)}" class="team-logo" alt="Team Logo">` : '';
                        const manager = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                        
                        row.innerHTML = `
                            <td>-</td>
                            <td><div class="manager-cell">${manager}</div></td>
                            <td><div class="team-cell-content team-cell-clickable" onclick="openScheduleModal('${team.team_key}')">${logo}<span>${team.team_name}</span></div></td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                        `;
                        tbody.appendChild(row);
                    });
                    tableEl.style.display = 'table';
                }
                
                // Load draft results for 2026
                await loadDraftResults(2026, false, teamLogos, teamData);
                
                // Show in-season tools instead of summary chart
                inseasonContainer.style.display = 'block';
                
                // Load in-season stats (pass standings for matchups ticker)
                await loadInSeasonStats(teamData, teamLogos, standings);
                
                loadingEl.style.display = 'none';
                
            } catch (error) {
                console.error('Error loading 2026 season:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading 2026 season: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }
        
        // ===== IN-SEASON STATS FUNCTIONS =====
        let currentMatchupsWeek = 1;
        let maxAvailableWeek = 1;
        let cachedStandings = null;
        
        async function loadInSeasonStats(teamData, teamLogos, standings) {
            // Cache these for week switching
            cachedTeamData = teamData;
            cachedTeamLogos = teamLogos;
            cachedStandings = standings;
            
            // Try to load weekly stats data
            try {
                const statsResponse = await fetch('data/current_season/weekly_stats.json');
                if (statsResponse.ok) {
                    const weeklyStats = await statsResponse.json();
                    cachedWeeklyStats = weeklyStats;
                    renderWeeklyStats(weeklyStats, teamData, teamLogos);
                    populateWeekSelector(weeklyStats);
                    await loadTopPerformers(weeklyStats);
                    await loadCategoryLeaders(weeklyStats);
                    
                    // Set max week from weekly stats
                    if (weeklyStats.weeks) {
                        const weeks = Object.keys(weeklyStats.weeks).map(Number);
                        maxAvailableWeek = Math.max(...weeks, 1);
                        currentMatchupsWeek = weeklyStats.currentWeek || maxAvailableWeek;
                    }
                    
                    // Load matchups from weekly stats
                    await loadMatchupsTicker(weeklyStats, teamData, teamLogos, standings);
                } else {
                    // No weekly stats yet - try to load matchups from week score files
                    document.getElementById('stats-no-data').style.display = 'block';
                    document.getElementById('hitting-stats-table').style.display = 'none';
                    document.getElementById('pitching-stats-table').style.display = 'none';
                    
                    // Still try to load matchups from week files
                    await loadMatchupsFromWeekFiles(teamData, teamLogos, standings);
                }
            } catch (e) {
                console.log('No weekly stats available yet:', e);
                document.getElementById('stats-no-data').style.display = 'block';
                
                // Still try to load matchups from week files
                await loadMatchupsFromWeekFiles(teamData, teamLogos, standings);
            }
        }
        
        async function loadMatchupsFromWeekFiles(teamData, teamLogos, standings) {
            // Find the highest available week
            let highestWeek = 0;
            for (let week = 1; week <= 24; week++) {
                try {
                    const response = await fetch(`data/current_season/week_${week}_scores.json`);
                    if (response.ok) {
                        highestWeek = week;
                    } else {
                        break; // Stop when we hit a missing week
                    }
                } catch (e) {
                    break;
                }
            }
            
            if (highestWeek > 0) {
                maxAvailableWeek = highestWeek;
                currentMatchupsWeek = 1; // Start at week 1
                
                // Update header week selector
                const headerWeekNum = document.getElementById('header-week-number');
                if (headerWeekNum) headerWeekNum.textContent = currentMatchupsWeek;
                updateHeaderWeekArrows();
                
                await loadMatchupsForWeek(currentMatchupsWeek, teamData, teamLogos, standings);
            }
        }
        
        async function loadMatchupsForWeek(week, teamData, teamLogos, standings) {
            const tickerContainer = document.getElementById('matchups-ticker');
            const cardsContainer = document.getElementById('matchups-cards');
            const weekNumEl = document.getElementById('matchups-week-num');
            
            if (!tickerContainer || !cardsContainer) return;
            
            // Clear existing interval
            if (matchupsTickerInterval) {
                clearInterval(matchupsTickerInterval);
                matchupsTickerInterval = null;
            }
            
            try {
                // First check if we have weekly_stats.json with this week's data
                if (cachedWeeklyStats && cachedWeeklyStats.weeks && cachedWeeklyStats.weeks[week]) {
                    const weekData = cachedWeeklyStats.weeks[week];
                    if (weekData.matchups && weekData.matchups.length > 0) {
                        weekNumEl.textContent = week;
                        renderMatchupsFromWeeklyStats(weekData.matchups, teamData, teamLogos, standings);
                        tickerContainer.style.display = 'block';
                        return;
                    }
                }
                
                // Fall back to week_X_scores.json file
                const response = await fetch(`data/current_season/week_${week}_scores.json`);
                if (!response.ok) {
                    console.log(`No data for week ${week}`);
                    return;
                }
                
                const scoresData = await response.json();
                
                // Convert scores data to matchups format
                const matchups = convertScoresToMatchups(scoresData);
                
                if (matchups.length === 0) {
                    tickerContainer.style.display = 'none';
                    return;
                }
                
                weekNumEl.textContent = week;
                
                // Build team info lookup
                const teamInfoLookup = {};
                teamData.forEach(team => {
                    teamInfoLookup[team.team_key] = {
                        name: team.team_name,
                        manager: normalizeManagerName(team.manager, 2026, team.team_name, team.team_key),
                        logo: teamLogos[team.team_key] || ''
                    };
                });
                
                // Build standings lookup
                const standingsLookup = {};
                if (standings && standings.length > 0) {
                    standings.forEach(team => {
                        standingsLookup[team.team_key] = {
                            rank: team.rank || '-',
                            wins: team.wins || 0,
                            losses: team.losses || 0
                        };
                    });
                }
                
                renderMatchupsTicker(cardsContainer, matchups, teamInfoLookup, standingsLookup);
                tickerContainer.style.display = 'block';
                
                // Start auto-scroll
                currentMatchupIndex = 0;
                matchupsTickerInterval = setInterval(() => {
                    currentMatchupIndex = (currentMatchupIndex + 1) % matchups.length;
                    scrollToMatchupCard(currentMatchupIndex);
                }, 15000);
                
            } catch (e) {
                console.log(`Error loading matchups for week ${week}:`, e);
                tickerContainer.style.display = 'none';
            }
        }
        
        function convertScoresToMatchups(scoresData) {
            // Group scores into matchups (2 teams per matchup)
            const matchupMap = {};
            
            scoresData.forEach(score => {
                // Create a unique matchup key (sorted team keys)
                const keys = [score.team_key, score.opponent_key].sort();
                const matchupKey = keys.join('_');
                
                if (!matchupMap[matchupKey]) {
                    matchupMap[matchupKey] = {
                        team1_key: score.team_key,
                        team1_score: score.team_score,
                        team2_key: score.opponent_key,
                        team2_score: score.opponent_score
                    };
                }
            });
            
            return Object.values(matchupMap);
        }
        
        function renderMatchupsFromWeeklyStats(matchups, teamData, teamLogos, standings) {
            const cardsContainer = document.getElementById('matchups-cards');
            
            // Build team info lookup
            const teamInfoLookup = {};
            teamData.forEach(team => {
                teamInfoLookup[team.team_key] = {
                    name: team.team_name,
                    manager: normalizeManagerName(team.manager, 2026, team.team_name, team.team_key),
                    logo: teamLogos[team.team_key] || ''
                };
            });
            
            // Build standings lookup
            const standingsLookup = {};
            if (standings && standings.length > 0) {
                standings.forEach(team => {
                    standingsLookup[team.team_key] = {
                        rank: team.rank || '-',
                        wins: team.wins || 0,
                        losses: team.losses || 0
                    };
                });
            }
            
            renderMatchupsTicker(cardsContainer, matchups, teamInfoLookup, standingsLookup);
            
            // Start auto-scroll
            currentMatchupIndex = 0;
            if (matchupsTickerInterval) {
                clearInterval(matchupsTickerInterval);
            }
            matchupsTickerInterval = setInterval(() => {
                currentMatchupIndex = (currentMatchupIndex + 1) % matchups.length;
                scrollToMatchupCard(currentMatchupIndex);
            }, 15000);
        }
        
        function changeMatchupsWeek(delta) {
            const newWeek = currentMatchupsWeek + delta;
            
            if (newWeek < 1 || newWeek > maxAvailableWeek) {
                return; // Out of bounds
            }
            
            currentMatchupsWeek = newWeek;
            
            // Update header week number
            const headerWeekNum = document.getElementById('header-week-number');
            if (headerWeekNum) headerWeekNum.textContent = newWeek;
            
            // Update arrow disabled states
            updateHeaderWeekArrows();
            
            // Reload matchups for the new week
            if (cachedTeamData && cachedTeamLogos) {
                loadMatchupsForWeek(newWeek, cachedTeamData, cachedTeamLogos, cachedStandings);
            }
        }
        
        // Header week selector functions
        function changeHeaderWeek(delta) {
            changeMatchupsWeek(delta);
        }
        
        function updateHeaderWeekArrows() {
            const upArrow = document.querySelector('.mario-up');
            const downArrow = document.querySelector('.mario-down');
            
            if (upArrow) upArrow.disabled = currentMatchupsWeek >= maxAvailableWeek;
            if (downArrow) downArrow.disabled = currentMatchupsWeek <= 1;
        }
        
        // ===== SCHEDULE MODAL FUNCTIONS =====
        async function openScheduleModal(teamKey) {
            const data = window.cached2026Data;
            if (!data) {
                console.log('No cached 2026 data');
                return;
            }
            
            const { teamData, teamLogos, allScores } = data;
            
            // Find team info
            const team = teamData.find(t => t.team_key === teamKey);
            if (!team) {
                console.log('Team not found:', teamKey);
                return;
            }
            
            const manager = normalizeManagerName(team.manager, 2026, team.team_name, teamKey);
            const logo = teamLogos[teamKey] || '';
            
            // Update modal header
            document.getElementById('schedule-modal-logo').src = logo;
            document.getElementById('schedule-modal-team-name').textContent = team.team_name;
            document.getElementById('schedule-modal-manager').textContent = manager;
            
            // Build schedule from allScores
            const teamSchedule = allScores.filter(s => s.team_key === teamKey);
            teamSchedule.sort((a, b) => a.week - b.week);
            
            // Load historical H2H records for this manager
            const historicalH2H = await loadHistoricalH2HForManager(manager);
            
            // Render schedule cards with H2H column
            renderScheduleCards(teamSchedule, teamData, teamLogos, historicalH2H);
            
            // Show modal
            document.getElementById('schedule-modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closeScheduleModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('schedule-modal-overlay').classList.remove('active');
            document.body.style.overflow = '';
        }
        
        async function loadHistoricalH2HForManager(managerName) {
            // Similar to calculateHeadToHeadRecords but returns a map for quick lookup
            const h2hMap = {};
            
            try {
                // Load all historical seasons
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                
                for (const season of seasons) {
                    try {
                        const scoresResponse = await fetch(`data/historical/${season}/all_scores.json`);
                        if (!scoresResponse.ok) continue;
                        
                        const scores = await scoresResponse.json();
                        const standingsResponse = await fetch(`data/historical/${season}/final_standings.json`);
                        if (!standingsResponse.ok) continue;
                        
                        let standings = await standingsResponse.json();
                        standings = normalizeStandingsData(standings, season);
                        
                        // Create team_key to manager mapping
                        const teamToManager = {};
                        standings.forEach(team => {
                            teamToManager[team.team_key] = team.manager;
                        });
                        
                        // Find manager's team key for this season
                        const managerTeam = standings.find(team => team.manager === managerName);
                        if (!managerTeam) continue;
                        
                        // Process matchups
                        scores.forEach(matchup => {
                            if (matchup.team_key === managerTeam.team_key) {
                                const opponent = teamToManager[matchup.opponent_key];
                                if (!opponent) return;
                                
                                if (!h2hMap[opponent]) {
                                    h2hMap[opponent] = {
                                        wins: 0,
                                        losses: 0,
                                        games: 0
                                    };
                                }
                                
                                h2hMap[opponent].games++;
                                
                                if (matchup.team_score > matchup.opponent_score) {
                                    h2hMap[opponent].wins++;
                                } else if (matchup.team_score < matchup.opponent_score) {
                                    h2hMap[opponent].losses++;
                                }
                            }
                        });
                    } catch (e) {
                        // Skip this season if error
                    }
                }
            } catch (e) {
                console.log('Error loading historical H2H:', e);
            }
            
            return h2hMap;
        }
        
        function renderScheduleCards(schedule, teamData, teamLogos, historicalH2H) {
            const container = document.getElementById('schedule-cards-grid');
            
            // Build cards for all 24 weeks
            let cardsHTML = '';
            
            for (let week = 1; week <= 24; week++) {
                const game = schedule.find(g => g.week === week);
                
                if (week >= 22) {
                    // Playoff weeks - check if matchup exists
                    if (game && game.opponent_key) {
                        cardsHTML += renderScheduleCard(game, teamData, teamLogos, historicalH2H);
                    } else {
                        // Playoff TBD card with league logo
                        cardsHTML += renderPlayoffTBDCard(week);
                    }
                } else {
                    // Regular season
                    if (game) {
                        cardsHTML += renderScheduleCard(game, teamData, teamLogos, historicalH2H);
                    }
                }
            }
            
            container.innerHTML = cardsHTML;
        }
        
        function renderPlayoffTBDCard(week) {
            return `
                <div class="schedule-card playoff-tbd">
                    <div class="schedule-card-header">
                        <span class="schedule-card-week">Week ${week}</span>
                    </div>
                    <div class="schedule-card-opponent">
                        <img src="data/page_logos/seasons_logo.png" class="team-logo" alt="" style="opacity: 0.5;">
                        <div class="schedule-card-opponent-info">
                            <div class="schedule-card-team-name">Playoffs</div>
                            <div class="schedule-card-manager">TBD</div>
                        </div>
                    </div>
                    <div class="schedule-card-score">0 | 0</div>
                    <div class="schedule-card-h2h">
                        <span class="schedule-card-h2h-label">All-Time:</span>
                        <span class="schedule-card-h2h-record no-history">-</span>
                    </div>
                </div>
            `;
        }
        
        function renderScheduleCard(game, teamData, teamLogos, historicalH2H) {
            const oppTeam = teamData.find(t => t.team_key === game.opponent_key);
            const oppManager = oppTeam ? normalizeManagerName(oppTeam.manager, 2026, oppTeam.team_name, game.opponent_key) : 'Unknown';
            const oppTeamName = oppTeam?.team_name || 'Unknown Team';
            const oppLogo = teamLogos[game.opponent_key] || '';
            
            const played = game.team_score > 0 || game.opponent_score > 0;
            let cardClass = 'upcoming';
            let resultText = '';
            let scoreText = '0 | 0';
            
            if (played) {
                if (game.team_score > game.opponent_score) {
                    cardClass = 'win';
                    resultText = 'W';
                    scoreText = `${game.team_score.toFixed(1)} | ${game.opponent_score.toFixed(1)}`;
                } else if (game.team_score < game.opponent_score) {
                    cardClass = 'loss';
                    resultText = 'L';
                    scoreText = `${game.team_score.toFixed(1)} | ${game.opponent_score.toFixed(1)}`;
                } else {
                    cardClass = 'tie';
                    resultText = 'T';
                    scoreText = `${game.team_score.toFixed(1)} | ${game.opponent_score.toFixed(1)}`;
                }
            }
            
            // Get historical H2H for this opponent
            const h2h = historicalH2H[oppManager] || null;
            let h2hHTML = '';
            
            if (h2h && h2h.games > 0) {
                const winPct = h2h.wins / (h2h.wins + h2h.losses);
                let recordClass = 'neutral';
                if (winPct >= 0.6) recordClass = 'good';
                else if (winPct <= 0.4) recordClass = 'bad';
                
                h2hHTML = `
                    <div class="schedule-card-h2h">
                        <span class="schedule-card-h2h-label">All-Time:</span>
                        <span class="schedule-card-h2h-record ${recordClass}">${h2h.wins}-${h2h.losses} (${(winPct * 100).toFixed(0)}%)</span>
                    </div>
                `;
            } else {
                h2hHTML = `
                    <div class="schedule-card-h2h">
                        <span class="schedule-card-h2h-label">All-Time:</span>
                        <span class="schedule-card-h2h-record no-history">0-0 (New)</span>
                    </div>
                `;
            }
            
            return `
                <div class="schedule-card ${cardClass}">
                    <div class="schedule-card-header">
                        <span class="schedule-card-week">Week ${game.week}</span>
                        ${resultText ? `<span class="schedule-card-result ${cardClass}">${resultText}</span>` : ''}
                    </div>
                    <div class="schedule-card-opponent">
                        <img src="${oppLogo}" class="team-logo" alt="" onerror="this.style.visibility='hidden'">
                        <div class="schedule-card-opponent-info">
                            <div class="schedule-card-team-name">${oppTeamName}</div>
                            <div class="schedule-card-manager">${oppManager}</div>
                        </div>
                    </div>
                    <div class="schedule-card-score">${scoreText}</div>
                    ${h2hHTML}
                </div>
            `;
        }
        
        // Week dropdown functions
        function toggleWeekDropdown() {
            const dropdown = document.getElementById('week-dropdown');
            const overlay = document.getElementById('week-dropdown-overlay');
            const isActive = dropdown.classList.contains('active');
            
            if (isActive) {
                closeWeekDropdown();
            } else {
                // Populate dropdown grid
                populateWeekDropdown();
                dropdown.classList.add('active');
                overlay.classList.add('active');
            }
        }
        
        function closeWeekDropdown() {
            document.getElementById('week-dropdown').classList.remove('active');
            document.getElementById('week-dropdown-overlay').classList.remove('active');
        }
        
        function populateWeekDropdown() {
            const grid = document.getElementById('week-dropdown-grid');
            let html = '';
            
            // 24 weeks total: 21 regular season + 3 playoffs
            for (let week = 1; week <= 24; week++) {
                const isActive = week === currentMatchupsWeek;
                const isUnavailable = week > maxAvailableWeek;
                
                let classes = 'week-dropdown-item';
                if (isActive) classes += ' active';
                if (isUnavailable) classes += ' unavailable';
                
                html += `<div class="${classes}" onclick="selectWeekFromDropdown(${week})">${week}</div>`;
            }
            
            grid.innerHTML = html;
        }
        
        function selectWeekFromDropdown(week) {
            if (week > maxAvailableWeek) return;
            
            closeWeekDropdown();
            
            // Update the current week
            currentMatchupsWeek = week;
            
            // Update header display
            const headerWeekNum = document.getElementById('header-week-number');
            if (headerWeekNum) headerWeekNum.textContent = week;
            updateHeaderWeekArrows();
            
            // Reload matchups for the new week
            if (cachedTeamData && cachedTeamLogos) {
                loadMatchupsForWeek(week, cachedTeamData, cachedTeamLogos, cachedStandings);
            }
        }
        
        // Close modal on escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeScheduleModal();
                closeWeekDropdown();
            }
        });
        
        let currentSelectedWeek = 'cumulative';
        let cachedWeeklyStats = null;
        let cachedTeamData = null;
        let cachedTeamLogos = null;
        
        function populateWeekSelector(weeklyStats) {
            const container = document.getElementById('week-circles');
            if (!container) return;
            
            // Cache the data for week switching
            cachedWeeklyStats = weeklyStats;
            
            let html = '<span class="week-circle cumulative active" onclick="selectWeek(\'cumulative\')">All</span>';
            
            if (weeklyStats && weeklyStats.weeks) {
                const weeks = Object.keys(weeklyStats.weeks).map(Number).sort((a, b) => a - b);
                weeks.forEach(week => {
                    html += `<span class="week-circle" onclick="selectWeek(${week})">${week}</span>`;
                });
            }
            
            container.innerHTML = html;
            currentSelectedWeek = 'cumulative';
        }
        
        function selectWeek(week) {
            currentSelectedWeek = week;
            
            // Update active state on circles
            const circles = document.querySelectorAll('.week-circle');
            circles.forEach(circle => {
                const circleWeek = circle.classList.contains('cumulative') ? 'cumulative' : parseInt(circle.textContent);
                circle.classList.toggle('active', circleWeek === week);
            });
            
            // Reload stats for selected week
            if (cachedWeeklyStats && cachedTeamData && cachedTeamLogos) {
                renderWeeklyStats(cachedWeeklyStats, cachedTeamData, cachedTeamLogos, week);
                
                // Also update matchups, top performers, and category leaders if a specific week is selected
                if (week !== 'cumulative') {
                    currentMatchupsWeek = week;
                    loadMatchupsForWeek(week, cachedTeamData, cachedTeamLogos, cachedStandings);
                    updateTopPerformersForWeek(cachedWeeklyStats, week);
                    updateCategoryLeadersForWeek(cachedWeeklyStats, week);
                } else {
                    // For cumulative, show the latest week's matchups
                    const latestWeek = cachedWeeklyStats.currentWeek || maxAvailableWeek;
                    currentMatchupsWeek = latestWeek;
                    loadMatchupsForWeek(latestWeek, cachedTeamData, cachedTeamLogos, cachedStandings);
                    updateTopPerformersForWeek(cachedWeeklyStats, latestWeek);
                    updateCategoryLeadersForWeek(cachedWeeklyStats, latestWeek);
                }
            }
        }
        
        function updateTopPerformersForWeek(weeklyStats, week) {
            const weekLabel = document.getElementById('top-performers-week-label');
            if (weekLabel) {
                weekLabel.textContent = `(Week ${week})`;
            }
            loadTopPerformers(weeklyStats, week);
        }
        
        function updateCategoryLeadersForWeek(weeklyStats, week) {
            const weekLabel = document.getElementById('category-leaders-week-label');
            if (weekLabel) {
                weekLabel.textContent = `(Week ${week})`;
            }
            loadCategoryLeaders(weeklyStats, week);
        }
        
        function setStatsType(type) {
            current2026StatsType = type;
            
            document.getElementById('btn-hitting-stats').classList.toggle('active', type === 'hitting');
            document.getElementById('btn-pitching-stats').classList.toggle('active', type === 'pitching');
            
            document.getElementById('hitting-stats-table').style.display = type === 'hitting' ? 'table' : 'none';
            document.getElementById('pitching-stats-table').style.display = type === 'pitching' ? 'table' : 'none';
        }
        
        function loadWeeklyStats() {
            // This function is no longer used - replaced by selectWeek
        }
        
        function renderWeeklyStats(weeklyStats, teamData, teamLogos, selectedWeek = 'cumulative') {
            // Cache team data for week switching
            cachedTeamData = teamData;
            cachedTeamLogos = teamLogos;
            
            // Hitting stats columns
            const hittingCols = ['1B', '2B', '3B', 'HR', 'RBI', 'SB', 'CS', 'BB', 'IBB', 'HBP', 'K', 'CYC', 'SLAM', 'Points'];
            const hittingInverse = ['CS', 'K']; // Lower is better
            
            // Pitching stats columns  
            const pitchingCols = ['IP', 'W', 'L', 'CG', 'SHO', 'SV', 'H', 'ER', 'BB', 'K', 'HLD', 'PICK', 'NH', 'QS', 'ERA', 'K/9', 'Points'];
            const pitchingInverse = ['L', 'H', 'ER', 'BB', 'ERA']; // Lower is better
            
            renderStatsTable('hitting', hittingCols, hittingInverse, weeklyStats, teamData, teamLogos, selectedWeek);
            renderStatsTable('pitching', pitchingCols, pitchingInverse, weeklyStats, teamData, teamLogos, selectedWeek);
            
            document.getElementById('stats-no-data').style.display = 'none';
            setStatsType(current2026StatsType);
        }
        
        function renderStatsTable(type, columns, inverseCols, weeklyStats, teamData, teamLogos, selectedWeek = 'cumulative') {
            const headerEl = document.getElementById(`${type}-stats-header`);
            const bodyEl = document.getElementById(`${type}-stats-body`);
            
            // Build header
            headerEl.innerHTML = `
                <tr>
                    <th>#</th>
                    <th>Team</th>
                    ${columns.map(col => `<th>${col}</th>`).join('')}
                </tr>
            `;
            
            // Get stats based on selected week
            let stats;
            if (selectedWeek === 'cumulative') {
                stats = weeklyStats.cumulative?.[type] || [];
            } else {
                const weekData = weeklyStats.weeks?.[selectedWeek] || weeklyStats.weeks?.[String(selectedWeek)];
                stats = weekData?.[type] || [];
            }
            
            if (stats.length === 0) {
                bodyEl.innerHTML = '<tr><td colspan="' + (columns.length + 2) + '" style="text-align:center; padding: 2rem; color: #888;">No data for this week</td></tr>';
                return;
            }
            
            // Calculate column ranks for heatmap
            const colRanks = {};
            columns.forEach(col => {
                const values = stats.map(s => s[col] || 0).sort((a, b) => {
                    return inverseCols.includes(col) ? a - b : b - a;
                });
                colRanks[col] = values;
            });
            
            // Sort stats by Points descending
            const sortedStats = [...stats].sort((a, b) => (b.Points || 0) - (a.Points || 0));
            
            // Build body
            bodyEl.innerHTML = sortedStats.map((team, idx) => {
                const logo = teamLogos[team.team_key] || '';
                const teamName = team.team_name || 'Unknown';
                
                return `
                    <tr>
                        <td>${idx + 1}</td>
                        <td>
                            <div class="stats-team-cell">
                                ${logo ? `<img src="${logo}" class="stats-team-logo" alt="">` : ''}
                                <span class="stats-team-name">${teamName}</span>
                            </div>
                        </td>
                        ${columns.map(col => {
                            const value = team[col] || 0;
                            const rank = colRanks[col].indexOf(value) + 1;
                            const heatClass = inverseCols.includes(col) ? `heat-inv-${rank}` : `heat-${rank}`;
                            const displayValue = typeof value === 'number' && !Number.isInteger(value) ? value.toFixed(2) : value;
                            return `<td class="${heatClass}">${displayValue}</td>`;
                        }).join('')}
                    </tr>
                `;
            }).join('');
        }
        
        async function loadTopPerformers(weeklyStats, week = null) {
            const hittersList = document.getElementById('top-hitters-list');
            const pitchersList = document.getElementById('top-pitchers-list');
            const weekLabel = document.getElementById('top-performers-week-label');
            
            const targetWeek = week || weeklyStats.currentWeek;
            
            if (!targetWeek) {
                hittersList.innerHTML = '<div class="no-data">Season has not started</div>';
                pitchersList.innerHTML = '<div class="no-data">Season has not started</div>';
                return;
            }
            
            if (weekLabel) {
                weekLabel.textContent = `(Week ${targetWeek})`;
            }
            
            const topHitters = weeklyStats.weeks?.[targetWeek]?.topHitters || [];
            const topPitchers = weeklyStats.weeks?.[targetWeek]?.topPitchers || [];
            
            hittersList.innerHTML = topHitters.slice(0, 5).map((player, idx) => `
                <div class="performer-item">
                    <span class="performer-rank">${idx + 1}</span>
                    <img src="${player.headshot || ''}" class="performer-headshot" alt="" onerror="this.style.display='none'">
                    <div class="performer-info">
                        <div class="performer-name">${player.name}</div>
                        <div class="performer-team">${player.team_name}</div>
                    </div>
                    <span class="performer-points">${player.points.toFixed(1)}</span>
                </div>
            `).join('') || '<div class="no-data">No data available</div>';
            
            pitchersList.innerHTML = topPitchers.slice(0, 5).map((player, idx) => `
                <div class="performer-item">
                    <span class="performer-rank">${idx + 1}</span>
                    <img src="${player.headshot || ''}" class="performer-headshot" alt="" onerror="this.style.display='none'">
                    <div class="performer-info">
                        <div class="performer-name">${player.name}</div>
                        <div class="performer-team">${player.team_name}</div>
                    </div>
                    <span class="performer-points">${player.points.toFixed(1)}</span>
                </div>
            `).join('') || '<div class="no-data">No data available</div>';
        }
        
        async function loadCategoryLeaders(weeklyStats, week = null) {
            const leadersGrid = document.getElementById('category-leaders-grid');
            const weekLabel = document.getElementById('category-leaders-week-label');
            
            const targetWeek = week || weeklyStats.currentWeek;
            
            if (!targetWeek) {
                leadersGrid.innerHTML = '<div class="no-data">Season has not started</div>';
                return;
            }
            
            if (weekLabel) {
                weekLabel.textContent = `(Week ${targetWeek})`;
            }
            
            const leaders = weeklyStats.weeks?.[targetWeek]?.categoryLeaders || {};
            
            const categories = [
                { key: 'HR', label: 'HR' },
                { key: 'RBI', label: 'RBI' },
                { key: 'SB', label: 'SB' },
                { key: 'IP', label: 'IP' },
                { key: 'K', label: 'K' },
                { key: 'SV', label: 'SV' }
            ];
            
            leadersGrid.innerHTML = categories.map(cat => {
                const leader = leaders[cat.key];
                if (!leader) return '';
                
                return `
                    <div class="category-leader-card">
                        <div class="category-name">${cat.label}</div>
                        <div class="category-value">${leader.value}</div>
                        <div class="category-leader-name">${leader.player_name}</div>
                        <div class="category-leader-team">${leader.team_name}</div>
                    </div>
                `;
            }).join('') || '<div class="no-data">No data available</div>';
        }
        
        // ===== MATCHUPS TICKER =====
        let matchupsTickerInterval = null;
        let currentMatchupIndex = 0;
        
        async function loadMatchupsTicker(weeklyStats, teamData, teamLogos, standings) {
            const tickerContainer = document.getElementById('matchups-ticker');
            const cardsContainer = document.getElementById('matchups-cards');
            const weekNumEl = document.getElementById('matchups-week-num');
            
            if (!tickerContainer || !cardsContainer) return;
            
            // Clear existing interval
            if (matchupsTickerInterval) {
                clearInterval(matchupsTickerInterval);
                matchupsTickerInterval = null;
            }
            
            // Determine which week to show
            const currentWeek = weeklyStats.currentWeek || 1;
            currentMatchupsWeek = currentWeek;
            
            // Set max available week
            if (weeklyStats.weeks) {
                const weeks = Object.keys(weeklyStats.weeks).map(Number);
                maxAvailableWeek = Math.max(...weeks, 1);
            }
            
            // Update header week selector
            const headerWeekNum = document.getElementById('header-week-number');
            if (headerWeekNum) headerWeekNum.textContent = currentMatchupsWeek;
            updateHeaderWeekArrows();
            
            const weekData = weeklyStats.weeks?.[currentWeek] || weeklyStats.weeks?.[String(currentWeek)];
            
            if (!weekData?.matchups || weekData.matchups.length === 0) {
                // Fall back to loading from week files
                await loadMatchupsForWeek(currentWeek, teamData, teamLogos, standings);
                return;
            }
            
            const matchups = weekData.matchups;
            
            // Build standings lookup
            const standingsLookup = {};
            if (standings && standings.length > 0) {
                standings.forEach(team => {
                    standingsLookup[team.team_key] = {
                        rank: team.rank || '-',
                        wins: team.wins || 0,
                        losses: team.losses || 0
                    };
                });
            }
            
            // Build team info lookup
            const teamInfoLookup = {};
            teamData.forEach(team => {
                teamInfoLookup[team.team_key] = {
                    name: team.team_name,
                    manager: normalizeManagerName(team.manager, 2026, team.team_name, team.team_key),
                    logo: teamLogos[team.team_key] || ''
                };
            });
            
            weekNumEl.textContent = currentWeek;
            
            // Render matchups ticker
            renderMatchupsTicker(cardsContainer, matchups, teamInfoLookup, standingsLookup);
            tickerContainer.style.display = 'block';
            
            // Start auto-scroll
            currentMatchupIndex = 0;
            matchupsTickerInterval = setInterval(() => {
                currentMatchupIndex = (currentMatchupIndex + 1) % matchups.length;
                scrollToMatchupCard(currentMatchupIndex);
            }, 15000);
        }
        
        function renderMatchupsTicker(container, matchups, teamInfo, standings) {
            container.innerHTML = `
                <div class="matchups-ticker-wrapper">
                    <button class="matchup-ticker-nav-btn" onclick="matchupTickerPrev()"></button>
                    <div class="matchups-ticker-viewport">
                        <div class="matchups-ticker-track" id="matchups-ticker-track">
                            ${matchups.map((matchup, idx) => {
                                const team1 = teamInfo[matchup.team1_key] || { name: 'Unknown', manager: 'Unknown', logo: '' };
                                const team2 = teamInfo[matchup.team2_key] || { name: 'Unknown', manager: 'Unknown', logo: '' };
                                const standing1 = standings[matchup.team1_key] || { rank: '-', wins: 0, losses: 0 };
                                const standing2 = standings[matchup.team2_key] || { rank: '-', wins: 0, losses: 0 };
                                
                                const team1Winner = matchup.team1_score > matchup.team2_score;
                                const team2Winner = matchup.team2_score > matchup.team1_score;
                                
                                // Get hat filenames
                                const hat1 = getManagerHatFilename(team1.manager);
                                const hat2 = getManagerHatFilename(team2.manager);
                                
                                return `
                                    <div class="matchup-ticker-card" data-index="${idx}">
                                        <div class="matchup-teams">
                                            <div class="matchup-team ${team1Winner ? 'winner' : (team2Winner ? 'loser' : '')}">
                                                ${team1.logo ? `<img src="${team1.logo}" class="matchup-team-logo" alt="">` : '<div class="matchup-team-logo" style="background:#e0e0e0;"></div>'}
                                                <img src="data/hats/${hat1}" class="matchup-team-hat" alt="" onerror="this.style.display='none'">
                                                <div class="matchup-team-name">${team1.name}</div>
                                                <div class="matchup-manager">${team1.manager}</div>
                                                <div class="matchup-record">(${standing1.wins}-${standing1.losses}) #${standing1.rank}</div>
                                                <div class="matchup-score">${matchup.team1_score.toFixed(1)}</div>
                                            </div>
                                            <div class="matchup-vs">VS</div>
                                            <div class="matchup-team ${team2Winner ? 'winner' : (team1Winner ? 'loser' : '')}">
                                                ${team2.logo ? `<img src="${team2.logo}" class="matchup-team-logo" alt="">` : '<div class="matchup-team-logo" style="background:#e0e0e0;"></div>'}
                                                <img src="data/hats/${hat2}" class="matchup-team-hat" alt="" onerror="this.style.display='none'">
                                                <div class="matchup-team-name">${team2.name}</div>
                                                <div class="matchup-manager">${team2.manager}</div>
                                                <div class="matchup-record">(${standing2.wins}-${standing2.losses}) #${standing2.rank}</div>
                                                <div class="matchup-score">${matchup.team2_score.toFixed(1)}</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <button class="matchup-ticker-nav-btn" onclick="matchupTickerNext()"></button>
                </div>
                <div class="matchup-ticker-dots" id="matchup-ticker-dots">
                    ${matchups.map((_, idx) => `<span class="matchup-ticker-dot ${idx === 0 ? 'active' : ''}" onclick="scrollToMatchupCard(${idx})"></span>`).join('')}
                </div>
            `;
        }
        
        function scrollToMatchupCard(index) {
            const track = document.getElementById('matchups-ticker-track');
            const dots = document.querySelectorAll('.matchup-ticker-dot');
            const cards = document.querySelectorAll('.matchup-ticker-card');
            
            if (!track || cards.length === 0) return;
            
            currentMatchupIndex = index;
            
            const viewport = track.parentElement;
            const viewportWidth = viewport.offsetWidth;
            const gap = 12;
            track.style.transform = `translateX(-${index * (viewportWidth + gap)}px)`;
            
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            
            if (matchupsTickerInterval) {
                clearInterval(matchupsTickerInterval);
                matchupsTickerInterval = setInterval(() => {
                    currentMatchupIndex = (currentMatchupIndex + 1) % cards.length;
                    scrollToMatchupCard(currentMatchupIndex);
                }, 15000);
            }
        }
        
        function matchupTickerPrev() {
            const cards = document.querySelectorAll('.matchup-ticker-card');
            if (cards.length === 0) return;
            currentMatchupIndex = (currentMatchupIndex - 1 + cards.length) % cards.length;
            scrollToMatchupCard(currentMatchupIndex);
        }
        
        function matchupTickerNext() {
            const cards = document.querySelectorAll('.matchup-ticker-card');
            if (cards.length === 0) return;
            currentMatchupIndex = (currentMatchupIndex + 1) % cards.length;
            scrollToMatchupCard(currentMatchupIndex);
        }

        // ===== PLAYOFF BRACKET FUNCTIONS =====
        async function loadPlayoffBracket(seasonNum, standings, teamData) {
            const bracketContainer = document.getElementById('playoff-bracket-container');
            const bracketEl = document.getElementById('playoff-bracket');
            
            try {
                // Load all_scores.json for this season
                let scoresPath = `data/historical/${seasonNum}/all_scores.json`;
                
                const scoresResponse = await fetch(scoresPath);
                if (!scoresResponse.ok) {
                    bracketContainer.style.display = 'none';
                    return;
                }
                
                const allScores = await scoresResponse.json();
                
                // Find max week (finals week)
                const maxWeek = Math.max(...allScores.map(s => s.week));
                
                // Build team info lookup
                const teamInfo = {};
                standings.forEach(t => {
                    teamInfo[t.team_key] = {
                        manager: t.manager,
                        team_name: t.team_name,
                        rank: t.rank
                    };
                });
                
                // Add team logos from teamData
                teamData.forEach(t => {
                    if (teamInfo[t.team_key]) {
                        teamInfo[t.team_key].logo = fixTeamLogo(t.team_logo);
                    }
                });
                
                // Playoff weeks
                const quarterfinalsWeek = maxWeek - 2;
                const semifinalsWeek = maxWeek - 1;
                const finalsWeek = maxWeek;
                
                // Get all playoff teams (top 6 by final rank)
                const playoffTeams = standings.slice(0, 6);
                const playoffKeys = playoffTeams.map(t => t.team_key);
                
                // Find ALL matchups in each playoff week between playoff teams
                function getPlayoffMatchups(week) {
                    const weekScores = allScores.filter(s => s.week === week);
                    const matchups = [];
                    const seen = new Set();
                    
                    for (const score of weekScores) {
                        if (playoffKeys.includes(score.team_key) && playoffKeys.includes(score.opponent_key)) {
                            const key = [score.team_key, score.opponent_key].sort().join('-');
                            if (!seen.has(key)) {
                                seen.add(key);
                                matchups.push({
                                    team1: { key: score.team_key, score: score.team_score },
                                    team2: { key: score.opponent_key, score: score.opponent_score },
                                    winner: score.team_score > score.opponent_score ? score.team_key : score.opponent_key,
                                    loser: score.team_score > score.opponent_score ? score.opponent_key : score.team_key
                                });
                            }
                        }
                    }
                    return matchups;
                }
                
                const qfMatchups = getPlayoffMatchups(quarterfinalsWeek);
                const sfMatchups = getPlayoffMatchups(semifinalsWeek);
                const finalsMatchups = getPlayoffMatchups(finalsWeek);
                
                // Identify bye teams - teams in SF who weren't in QF
                const qfParticipants = new Set();
                qfMatchups.forEach(m => {
                    qfParticipants.add(m.team1.key);
                    qfParticipants.add(m.team2.key);
                });
                
                const byeTeams = playoffKeys.filter(k => !qfParticipants.has(k));
                
                if (qfMatchups.length < 2 || sfMatchups.length < 2 || byeTeams.length < 2) {
                    bracketContainer.style.display = 'none';
                    return;
                }
                
                // Find which SF matchup each bye team is in
                let sf1 = sfMatchups.find(m => m.team1.key === byeTeams[0] || m.team2.key === byeTeams[0]);
                let sf2 = sfMatchups.find(m => m.team1.key === byeTeams[1] || m.team2.key === byeTeams[1]);
                
                if (!sf1 || !sf2) {
                    bracketContainer.style.display = 'none';
                    return;
                }
                
                // Identify the QF that feeds into each SF
                const sf1Opponent = sf1.team1.key === byeTeams[0] ? sf1.team2.key : sf1.team1.key;
                const sf2Opponent = sf2.team1.key === byeTeams[1] ? sf2.team2.key : sf2.team1.key;
                
                const qf1 = qfMatchups.find(m => m.winner === sf1Opponent);
                const qf2 = qfMatchups.find(m => m.winner === sf2Opponent);
                
                if (!qf1 || !qf2) {
                    bracketContainer.style.display = 'none';
                    return;
                }
                
                // Find the championship game between SF winners
                const finalsMatch = finalsMatchups.find(m => 
                    (m.team1.key === sf1.winner && m.team2.key === sf2.winner) ||
                    (m.team1.key === sf2.winner && m.team2.key === sf1.winner)
                );
                
                if (!finalsMatch) {
                    bracketContainer.style.display = 'none';
                    return;
                }
                
                const champion = finalsMatch.winner;
                
                // Determine line colors
                const qf1WinnerIsChamp = qf1.winner === champion;
                const qf2WinnerIsChamp = qf2.winner === champion;
                const sf1WinnerIsChamp = sf1.winner === champion;
                const sf2WinnerIsChamp = sf2.winner === champion;
                
                // Build HTML for bracket team
                function renderTeam(teamKey, score, isWinner, isChampion = false, isChampionPath = false) {
                    const info = teamInfo[teamKey] || {};
                    const manager = info.manager || 'Unknown';
                    const hatFilename = getManagerHatFilename(manager);
                    const hatUrl = `data/hats/${hatFilename}`;
                    const logoUrl = info.logo || '';
                    
                    const classes = ['bracket-team'];
                    if (isChampion) classes.push('champion', 'winner');
                    else if (isWinner && isChampionPath) classes.push('champion-path', 'winner');
                    else if (isWinner) classes.push('winner');
                    else classes.push('loser');
                    
                    return `
                        <div class="${classes.join(' ')}">
                            <img src="${hatUrl}" class="bracket-hat" alt="${manager}" 
                                 onerror="this.src='${logoUrl}'; this.style.borderRadius='50%'; this.style.border='2px solid #1e3c72';">
                            <div class="bracket-team-info">
                                <span class="bracket-manager">${manager}</span>
                                <span class="bracket-score">${score.toFixed(2)}</span>
                            </div>
                            ${isChampion ? `<div class="champion-badge"><img src="champion_ring.png" alt=""><span>Champ</span></div>` : ''}
                        </div>
                    `;
                }
                
                // Determine line colors - champion gets gold throughout their entire path
                const qf1Color = qf1WinnerIsChamp ? '#d4af37' : '#0048ba';
                const qf2Color = qf2WinnerIsChamp ? '#d4af37' : '#0048ba';
                const sf1Color = sf1WinnerIsChamp ? '#d4af37' : '#0048ba';
                const sf2Color = sf2WinnerIsChamp ? '#d4af37' : '#0048ba';
                
                // Build the bracket HTML with simple flex layout - SVG will be added after render
                const bracketHTML = `
                    <div class="bracket-wrapper">
                        <!-- SVG overlay will be inserted here by JavaScript -->
                        <svg class="bracket-lines-svg" id="bracket-svg-${seasonNum}"></svg>
                        
                        <!-- Bracket content -->
                        <div class="bracket-content">
                            <!-- Quarterfinals column -->
                            <div class="bracket-column qf-column">
                                <div class="bracket-round-label">Round 1</div>
                                <div class="bracket-matchup qf1-matchup" data-matchup="qf1">
                                    ${renderTeam(qf1.team1.key, qf1.team1.score, qf1.team1.key === qf1.winner, false, qf1.team1.key === qf1.winner && qf1WinnerIsChamp)}
                                    ${renderTeam(qf1.team2.key, qf1.team2.score, qf1.team2.key === qf1.winner, false, qf1.team2.key === qf1.winner && qf1WinnerIsChamp)}
                                </div>
                                <div class="bracket-spacer"></div>
                                <div class="bracket-matchup qf2-matchup" data-matchup="qf2">
                                    ${renderTeam(qf2.team1.key, qf2.team1.score, qf2.team1.key === qf2.winner, false, qf2.team1.key === qf2.winner && qf2WinnerIsChamp)}
                                    ${renderTeam(qf2.team2.key, qf2.team2.score, qf2.team2.key === qf2.winner, false, qf2.team2.key === qf2.winner && qf2WinnerIsChamp)}
                                </div>
                            </div>
                            
                            <!-- Spacer for connectors -->
                            <div class="bracket-connector-space"></div>
                            
                            <!-- Semifinals column -->
                            <div class="bracket-column sf-column">
                                <div class="bracket-round-label">Semifinals</div>
                                <div class="bracket-matchup sf1-matchup" data-matchup="sf1">
                                    ${renderTeam(byeTeams[0], sf1.team1.key === byeTeams[0] ? sf1.team1.score : sf1.team2.score, sf1.winner === byeTeams[0], false, sf1.winner === byeTeams[0] && sf1WinnerIsChamp)}
                                    ${renderTeam(sf1Opponent, sf1.team1.key === sf1Opponent ? sf1.team1.score : sf1.team2.score, sf1.winner === sf1Opponent, false, sf1.winner === sf1Opponent && sf1WinnerIsChamp)}
                                </div>
                                <div class="bracket-spacer"></div>
                                <div class="bracket-matchup sf2-matchup" data-matchup="sf2">
                                    ${renderTeam(byeTeams[1], sf2.team1.key === byeTeams[1] ? sf2.team1.score : sf2.team2.score, sf2.winner === byeTeams[1], false, sf2.winner === byeTeams[1] && sf2WinnerIsChamp)}
                                    ${renderTeam(sf2Opponent, sf2.team1.key === sf2Opponent ? sf2.team1.score : sf2.team2.score, sf2.winner === sf2Opponent, false, sf2.winner === sf2Opponent && sf2WinnerIsChamp)}
                                </div>
                            </div>
                            
                            <!-- Spacer for connectors -->
                            <div class="bracket-connector-space"></div>
                            
                            <!-- Finals column -->
                            <div class="bracket-column finals-column">
                                <div class="bracket-round-label">Championship</div>
                                <div class="bracket-matchup finals-matchup" data-matchup="finals">
                                    ${renderTeam(sf1.winner, finalsMatch.team1.key === sf1.winner ? finalsMatch.team1.score : finalsMatch.team2.score, sf1.winner === champion, sf1.winner === champion, false)}
                                    ${renderTeam(sf2.winner, finalsMatch.team1.key === sf2.winner ? finalsMatch.team1.score : finalsMatch.team2.score, sf2.winner === champion, sf2.winner === champion, false)}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                bracketEl.innerHTML = bracketHTML;
                bracketContainer.style.display = 'block';
                
                // Draw the SVG lines after a brief delay to let the DOM settle
                setTimeout(() => {
                    drawBracketLines(seasonNum, {
                        qf1: { winner: qf1.winner, team1: qf1.team1.key, team2: qf1.team2.key, winnerIsChamp: qf1WinnerIsChamp },
                        qf2: { winner: qf2.winner, team1: qf2.team1.key, team2: qf2.team2.key, winnerIsChamp: qf2WinnerIsChamp },
                        sf1: { winner: sf1.winner, byeTeam: byeTeams[0], qfWinner: sf1Opponent, winnerIsChamp: sf1WinnerIsChamp },
                        sf2: { winner: sf2.winner, byeTeam: byeTeams[1], qfWinner: sf2Opponent, winnerIsChamp: sf2WinnerIsChamp }
                    });
                }, 50);
                
            } catch (error) {
                console.error('Error loading playoff bracket:', error);
                bracketContainer.style.display = 'none';
            }
        }

        // Function to draw bracket connector lines using actual element positions
        function drawBracketLines(seasonNum, matchupData) {
            const svg = document.getElementById(`bracket-svg-${seasonNum}`);
            if (!svg) return;
            
            const wrapper = svg.closest('.bracket-wrapper');
            if (!wrapper) return;
            
            const wrapperRect = wrapper.getBoundingClientRect();
            
            // Helper to get center Y of a team box relative to wrapper
            function getTeamY(matchupSelector, teamIndex) {
                const matchup = wrapper.querySelector(matchupSelector);
                if (!matchup) return 0;
                const teams = matchup.querySelectorAll('.bracket-team');
                if (!teams[teamIndex]) return 0;
                const rect = teams[teamIndex].getBoundingClientRect();
                return rect.top - wrapperRect.top + rect.height / 2;
            }
            
            // Helper to get right edge of team box
            function getTeamRight(matchupSelector) {
                const matchup = wrapper.querySelector(matchupSelector);
                if (!matchup) return 0;
                const team = matchup.querySelector('.bracket-team');
                if (!team) return 0;
                const rect = team.getBoundingClientRect();
                return rect.right - wrapperRect.left;
            }
            
            // Helper to get left edge of team box
            function getTeamLeft(matchupSelector) {
                const matchup = wrapper.querySelector(matchupSelector);
                if (!matchup) return 0;
                const team = matchup.querySelector('.bracket-team');
                if (!team) return 0;
                const rect = team.getBoundingClientRect();
                return rect.left - wrapperRect.left;
            }
            
            // Get positions
            const qf1Top = getTeamY('.qf1-matchup', 0);
            const qf1Bot = getTeamY('.qf1-matchup', 1);
            const qf1Right = getTeamRight('.qf1-matchup');
            
            const qf2Top = getTeamY('.qf2-matchup', 0);
            const qf2Bot = getTeamY('.qf2-matchup', 1);
            const qf2Right = getTeamRight('.qf2-matchup');
            
            const sf1Top = getTeamY('.sf1-matchup', 0);
            const sf1Bot = getTeamY('.sf1-matchup', 1);
            const sf1Right = getTeamRight('.sf1-matchup');
            const sf1Left = getTeamLeft('.sf1-matchup');
            
            const sf2Top = getTeamY('.sf2-matchup', 0);
            const sf2Bot = getTeamY('.sf2-matchup', 1);
            const sf2Right = getTeamRight('.sf2-matchup');
            const sf2Left = getTeamLeft('.sf2-matchup');
            
            const finalsTop = getTeamY('.finals-matchup', 0);
            const finalsBot = getTeamY('.finals-matchup', 1);
            const finalsLeft = getTeamLeft('.finals-matchup');
            
            // Calculate connector X positions
            const qfConnX = qf1Right + 30; // 30px to the right of QF boxes
            const sfConnX = sf1Right + 30; // First vertical connector after SF
            const sfConnX2 = sfConnX + 50; // Second vertical connector (halfway point for finals)
            
            // Colors
            const gold = '#d4af37';
            const navy = '#0048ba';
            const gray = '#ccc';
            
            // Build SVG content
            let svgContent = '';
            
            // QF1 connector - horizontal line goes to sf1Bot Y position (bottom team of SF1)
            const qf1TopColor = matchupData.qf1.team1 === matchupData.qf1.winner ? (matchupData.qf1.winnerIsChamp ? gold : navy) : gray;
            const qf1BotColor = matchupData.qf1.team2 === matchupData.qf1.winner ? (matchupData.qf1.winnerIsChamp ? gold : navy) : gray;
            const qf1WinnerColor = matchupData.qf1.winnerIsChamp ? gold : navy;
            const qf1MidY = (qf1Top + qf1Bot) / 2;
            
            svgContent += `<line x1="${qf1Right}" y1="${qf1Top}" x2="${qfConnX}" y2="${qf1Top}" stroke="${qf1TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${qf1Right}" y1="${qf1Bot}" x2="${qfConnX}" y2="${qf1Bot}" stroke="${qf1BotColor}" stroke-width="3"/>`;
            // Split vertical connector: top to mid, bottom to mid (each with own color)
            svgContent += `<line x1="${qfConnX}" y1="${qf1Top}" x2="${qfConnX}" y2="${qf1MidY}" stroke="${qf1TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${qfConnX}" y1="${qf1Bot}" x2="${qfConnX}" y2="${qf1MidY}" stroke="${qf1BotColor}" stroke-width="3"/>`;
            // Line from midpoint to SF1 bottom team
            svgContent += `<line x1="${qfConnX}" y1="${qf1MidY}" x2="${qfConnX}" y2="${sf1Bot}" stroke="${qf1WinnerColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${qfConnX}" y1="${sf1Bot}" x2="${sf1Left}" y2="${sf1Bot}" stroke="${qf1WinnerColor}" stroke-width="3"/>`;
            
            // QF2 connector - horizontal line goes to sf2Bot Y position (bottom team of SF2)
            const qf2TopColor = matchupData.qf2.team1 === matchupData.qf2.winner ? (matchupData.qf2.winnerIsChamp ? gold : navy) : gray;
            const qf2BotColor = matchupData.qf2.team2 === matchupData.qf2.winner ? (matchupData.qf2.winnerIsChamp ? gold : navy) : gray;
            const qf2WinnerColor = matchupData.qf2.winnerIsChamp ? gold : navy;
            const qf2MidY = (qf2Top + qf2Bot) / 2;
            
            svgContent += `<line x1="${qf2Right}" y1="${qf2Top}" x2="${qfConnX}" y2="${qf2Top}" stroke="${qf2TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${qf2Right}" y1="${qf2Bot}" x2="${qfConnX}" y2="${qf2Bot}" stroke="${qf2BotColor}" stroke-width="3"/>`;
            // Split vertical connector: top to mid, bottom to mid (each with own color)
            svgContent += `<line x1="${qfConnX}" y1="${qf2Top}" x2="${qfConnX}" y2="${qf2MidY}" stroke="${qf2TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${qfConnX}" y1="${qf2Bot}" x2="${qfConnX}" y2="${qf2MidY}" stroke="${qf2BotColor}" stroke-width="3"/>`;
            // Line from midpoint to SF2 bottom team
            svgContent += `<line x1="${qfConnX}" y1="${qf2MidY}" x2="${qfConnX}" y2="${sf2Bot}" stroke="${qf2WinnerColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${qfConnX}" y1="${sf2Bot}" x2="${sf2Left}" y2="${sf2Bot}" stroke="${qf2WinnerColor}" stroke-width="3"/>`;
            
            // SF1 connector
            const sf1TopColor = matchupData.sf1.winner === matchupData.sf1.byeTeam ? (matchupData.sf1.winnerIsChamp ? gold : navy) : gray;
            const sf1BotColor = matchupData.sf1.winner === matchupData.sf1.qfWinner ? (matchupData.sf1.winnerIsChamp ? gold : navy) : gray;
            const sf1WinnerColor = matchupData.sf1.winnerIsChamp ? gold : navy;
            const sf1MidY = (sf1Top + sf1Bot) / 2;
            
            svgContent += `<line x1="${sf1Right}" y1="${sf1Top}" x2="${sfConnX}" y2="${sf1Top}" stroke="${sf1TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${sf1Right}" y1="${sf1Bot}" x2="${sfConnX}" y2="${sf1Bot}" stroke="${sf1BotColor}" stroke-width="3"/>`;
            // Split vertical connector: top to mid, bottom to mid (each with own color)
            svgContent += `<line x1="${sfConnX}" y1="${sf1Top}" x2="${sfConnX}" y2="${sf1MidY}" stroke="${sf1TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${sfConnX}" y1="${sf1Bot}" x2="${sfConnX}" y2="${sf1MidY}" stroke="${sf1BotColor}" stroke-width="3"/>`;
            // Horizontal from SF1 midpoint to second connector X
            svgContent += `<line x1="${sfConnX}" y1="${sf1MidY}" x2="${sfConnX2}" y2="${sf1MidY}" stroke="${sf1WinnerColor}" stroke-width="3"/>`;
            // Vertical from SF1 midpoint Y to finals top team Y
            svgContent += `<line x1="${sfConnX2}" y1="${sf1MidY}" x2="${sfConnX2}" y2="${finalsTop}" stroke="${sf1WinnerColor}" stroke-width="3"/>`;
            // Horizontal into finals top team
            svgContent += `<line x1="${sfConnX2}" y1="${finalsTop}" x2="${finalsLeft}" y2="${finalsTop}" stroke="${sf1WinnerColor}" stroke-width="3"/>`;
            
            // SF2 connector
            const sf2TopColor = matchupData.sf2.winner === matchupData.sf2.byeTeam ? (matchupData.sf2.winnerIsChamp ? gold : navy) : gray;
            const sf2BotColor = matchupData.sf2.winner === matchupData.sf2.qfWinner ? (matchupData.sf2.winnerIsChamp ? gold : navy) : gray;
            const sf2WinnerColor = matchupData.sf2.winnerIsChamp ? gold : navy;
            const sf2MidY = (sf2Top + sf2Bot) / 2;
            
            svgContent += `<line x1="${sf2Right}" y1="${sf2Top}" x2="${sfConnX}" y2="${sf2Top}" stroke="${sf2TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${sf2Right}" y1="${sf2Bot}" x2="${sfConnX}" y2="${sf2Bot}" stroke="${sf2BotColor}" stroke-width="3"/>`;
            // Split vertical connector: top to mid, bottom to mid (each with own color)
            svgContent += `<line x1="${sfConnX}" y1="${sf2Top}" x2="${sfConnX}" y2="${sf2MidY}" stroke="${sf2TopColor}" stroke-width="3"/>`;
            svgContent += `<line x1="${sfConnX}" y1="${sf2Bot}" x2="${sfConnX}" y2="${sf2MidY}" stroke="${sf2BotColor}" stroke-width="3"/>`;
            // Horizontal from SF2 midpoint to second connector X
            svgContent += `<line x1="${sfConnX}" y1="${sf2MidY}" x2="${sfConnX2}" y2="${sf2MidY}" stroke="${sf2WinnerColor}" stroke-width="3"/>`;
            // Vertical from SF2 midpoint Y to finals bottom team Y
            svgContent += `<line x1="${sfConnX2}" y1="${sf2MidY}" x2="${sfConnX2}" y2="${finalsBot}" stroke="${sf2WinnerColor}" stroke-width="3"/>`;
            // Horizontal into finals bottom team
            svgContent += `<line x1="${sfConnX2}" y1="${finalsBot}" x2="${finalsLeft}" y2="${finalsBot}" stroke="${sf2WinnerColor}" stroke-width="3"/>`;
            
            svg.innerHTML = svgContent;
        }

        // ===== DRAFT RESULTS FUNCTIONS =====
        async function loadDraftResults(seasonNum, isCurrentSeason, teamLogos, teamData) {
            const draftTable = document.getElementById('draft-table');
            const draftBody = document.getElementById('draft-body');
            const draftLoading = document.getElementById('draft-loading');
            const draftEmpty = document.getElementById('draft-empty');

            // Build team info lookup by team_key
            const teamInfo = {};
            if (teamData && teamData.length > 0) {
                teamData.forEach(team => {
                    teamInfo[team.team_key] = {
                        name: team.team_name || team.name || 'Unknown Team',
                        manager: team.manager || 'Unknown'
                    };
                });
            }

            // Reset state
            draftTable.style.display = 'none';
            draftLoading.style.display = 'block';
            draftEmpty.style.display = 'none';
            draftBody.innerHTML = '';

            try {
                // Load draft data
                let draftResponse;
                if (seasonNum === 2026) {
                    draftResponse = await fetch('data/current_season/draft.json');
                } else {
                    draftResponse = await fetch(`data/historical/${seasonNum}/draft.json`);
                }

                if (!draftResponse.ok) {
                    throw new Error('Draft data not available');
                }

                const draftData = await draftResponse.json();

                if (!draftData || draftData.length === 0) {
                    draftLoading.style.display = 'none';
                    draftEmpty.style.display = 'block';
                    return;
                }

                // Load keepers data
                let keepersForYear = {};
                try {
                    const keepersResponse = await fetch('data/keepers.json');
                    if (keepersResponse.ok) {
                        const allKeepers = await keepersResponse.json();
                        keepersForYear = allKeepers[seasonNum.toString()] || {};
                        console.log(`Loaded ${Object.keys(keepersForYear).length} keepers for ${seasonNum}`);
                    } else {
                        console.log('Keepers response not ok:', keepersResponse.status);
                    }
                } catch (e) {
                    console.log('No keepers data available:', e);
                }

                // Create lowercase keeper lookup for flexible matching
                const keepersLowercase = {};
                for (const [name, info] of Object.entries(keepersForYear)) {
                    keepersLowercase[name.toLowerCase().trim()] = info;
                }

                // Load player stats to get fantasy points and position ranks
                let playerStatsResponse;
                if (seasonNum === 2026) {
                    playerStatsResponse = await fetch('data/current_season/player_stats.json');
                } else {
                    playerStatsResponse = await fetch(`data/historical/${seasonNum}/player_stats.json`);
                }

                let playerStatsByKey = {};
                let playerStatsByName = {};
                let positionRanks = {};
                if (playerStatsResponse.ok) {
                    const statsData = await playerStatsResponse.json();
                    // Create lookups by player_key and by name
                    statsData.forEach(player => {
                        if (player.player_key) {
                            playerStatsByKey[player.player_key] = player;
                        }
                        if (player.name) {
                            playerStatsByName[player.name.toLowerCase()] = player;
                        }
                    });
                    // Calculate position ranks
                    positionRanks = calculateDraftPositionRanks(statsData);
                }

                // Render draft table with round separators
                let currentRound = 0;
                draftData.forEach((pick, index) => {
                    const pickRound = pick.round || 0;

                    // Add round separator when round changes
                    if (pickRound !== currentRound) {
                        currentRound = pickRound;
                        const separatorRow = document.createElement('tr');
                        separatorRow.className = 'draft-round-separator';
                        separatorRow.innerHTML = `<td colspan="6">Round ${currentRound}</td>`;
                        draftBody.appendChild(separatorRow);
                    }

                    const row = document.createElement('tr');

                    // Get player stats - try player_key first, then fall back to name match
                    const playerKey = pick.player_key;
                    let playerData = playerStatsByKey[playerKey];

                    // If not found by key, try matching by name
                    if (!playerData && pick.player_name) {
                        playerData = playerStatsByName[pick.player_name.toLowerCase()];
                    }

                    playerData = playerData || {};

                    const fantasyPoints = playerData.fantasy_points || 0;
                    const position = pick.position || playerData.position || '';
                    const primaryPos = position.split(',')[0].trim();

                    // Get position rank - try by player_key first, then by matched player's key
                    let posRank = positionRanks[playerKey];
                    if (!posRank && playerData.player_key) {
                        posRank = positionRanks[playerData.player_key];
                    }
                    posRank = posRank || '-';
                    const posRankClass = getRankClass(posRank, primaryPos);

                    // Team logo from draft
                    const teamLogo = teamLogos[pick.team_key] || '';
                    const teamDetails = teamInfo[pick.team_key] || { name: 'Unknown Team', manager: 'Unknown' };
                    const teamTooltip = `${teamDetails.name} (${teamDetails.manager})`;

                    // Player headshot
                    const headshot = pick.headshot_url || playerData.headshot_url || '';
                    const headshotImg = headshot
                        ? `<img src="${headshot}" class="draft-headshot" alt="" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23e0e0e0%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2250%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 font-size=%2230%22 fill=%22%23999%22>?</text></svg>'">`
                        : '<div class="draft-headshot" style="display:flex;align-items:center;justify-content:center;font-size:14px;color:#999;">?</div>';

                    // Check if player was a keeper - try multiple name variations
                    const playerName = pick.player_name || '';
                    let isKeeper = false;
                    if (playerName) {
                        // Try exact match first
                        if (keepersForYear[playerName]) {
                            isKeeper = true;
                        } else {
                            // Try case-insensitive match
                            const lowerName = playerName.toLowerCase();
                            for (const keeperName of Object.keys(keepersForYear)) {
                                if (keeperName.toLowerCase() === lowerName) {
                                    isKeeper = true;
                                    break;
                                }
                            }
                        }
                    }
                    const keeperBadge = isKeeper ? '<span class="keeper-badge">K</span>' : '';
                    const posClass = getDraftPosClass(primaryPos);

                    row.innerHTML = `
                        <td>${pick.round || '-'}</td>
                        <td>${pick.pick || '-'}</td>
                        <td>
                            <div class="draft-player-cell">
                                ${headshotImg}
                                <div class="draft-player-info">
                                    <span class="draft-player-name">${pick.player_name || 'Unknown'}${keeperBadge}</span>
                                    <span class="draft-player-pos ${posClass}">${primaryPos}</span>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="draft-team-cell">
                                ${teamLogo ? `<img src="${teamLogo}" class="draft-team-logo" alt="${teamDetails.name}"><span class="draft-team-tooltip">${teamTooltip}</span>` : ''}
                            </div>
                        </td>
                        <td class="draft-pts">${fantasyPoints > 0 ? Math.round(fantasyPoints).toLocaleString() : '-'}</td>
                        <td><span class="draft-rank ${posRankClass}">${primaryPos}${posRank !== '-' ? posRank : ''}</span></td>
                    `;
                    draftBody.appendChild(row);
                });

                draftLoading.style.display = 'none';
                draftTable.style.display = 'table';

            } catch (error) {
                console.error('Error loading draft:', error);
                draftLoading.style.display = 'none';
                draftEmpty.textContent = 'Draft data not available for this season';
                draftEmpty.style.display = 'block';
            }
        }

        function calculateDraftPositionRanks(players) {
            // Group players by primary position
            const positionGroups = {};

            players.forEach(player => {
                const pos = (player.position || '').split(',')[0].trim();
                if (!pos) return;

                if (!positionGroups[pos]) {
                    positionGroups[pos] = [];
                }
                positionGroups[pos].push({
                    player_key: player.player_key,
                    fantasy_points: player.fantasy_points || 0
                });
            });

            // Sort each position group by fantasy points and assign ranks
            const ranks = {};
            Object.keys(positionGroups).forEach(pos => {
                positionGroups[pos].sort((a, b) => b.fantasy_points - a.fantasy_points);
                positionGroups[pos].forEach((player, index) => {
                    ranks[player.player_key] = index + 1;
                });
            });

            return ranks;
        }

        function getRankClass(rank, position) {
            if (rank === '-' || !rank) return '';
            const numRank = parseInt(rank);
            const pos = (position || '').toUpperCase();

            // Outfield positions
            const isOutfield = ['OF', 'LF', 'CF', 'RF'].includes(pos);

            if (pos === 'SP') {
                // Starting Pitchers: Green = top 12, Yellow = top 60, Red = below
                if (numRank <= 12) return 'top-10';
                if (numRank <= 60) return 'top-25';
                return 'top-50';
            } else if (pos === 'RP' || pos === 'P') {
                // Relief Pitchers: Green = top 3, Yellow = top 10, Red = below
                if (numRank <= 3) return 'top-10';
                if (numRank <= 10) return 'top-25';
                return 'top-50';
            } else if (isOutfield) {
                // Outfielders: Green = top 9, Yellow = top 25, Red = below
                if (numRank <= 9) return 'top-10';
                if (numRank <= 25) return 'top-25';
                return 'top-50';
            } else {
                // All other hitters: Green = top 3, Yellow = top 10, Red = below
                if (numRank <= 3) return 'top-10';
                if (numRank <= 10) return 'top-25';
                return 'top-50';
            }
        }

        function getDraftPosClass(position) {
            const pos = (position || '').toUpperCase();
            
            // Infield
            if (pos === 'C') return 'pos-c';
            if (pos === '1B') return 'pos-1b';
            if (pos === '2B') return 'pos-2b';
            if (pos === '3B') return 'pos-3b';
            if (pos === 'SS') return 'pos-ss';
            
            // Outfield
            if (['OF', 'LF', 'CF', 'RF'].includes(pos)) return 'pos-of';
            
            // Designated Hitter / Utility
            if (pos === 'DH') return 'pos-dh';
            if (pos === 'UTIL') return 'pos-util';
            
            // Pitchers (Now distinct)
            if (pos === 'SP') return 'pos-sp';
            if (pos === 'RP') return 'pos-rp';
            if (pos === 'P') return 'pos-p';
            
            return 'pos-util'; // Fallback
        }

        // ===== SEASON CHART FUNCTIONS =====
        async function loadSeasonChart(seasonNum, isCurrentSeason, standings, teamLogos, teamData) {
            const chartContainer = document.getElementById('season-chart-container');
            const chartEl = document.getElementById('season-chart');

            try {
                // Load weekly scores data
                let scoresResponse;
                if (seasonNum === 2026) {
                    scoresResponse = await fetch('data/current_season/all_scores.json');
                } else {
                    scoresResponse = await fetch(`data/historical/${seasonNum}/all_scores.json`);
                }

                if (!scoresResponse.ok) {
                    console.log('No scores data available for chart');
                    chartContainer.style.display = 'none';
                    return;
                }

                const scoresData = await scoresResponse.json();
                console.log('Loaded scores data:', scoresData.length, 'entries');

                // Process scores into both weekly and cumulative rankings
                currentChartData = processScoresForChart(scoresData, standings, teamLogos, teamData);
                console.log('Processed chart data:', currentChartData.weeklyTeams.length, 'teams');

                if (currentChartData.weeklyTeams.length === 0) {
                    console.log('No team data to display');
                    chartContainer.style.display = 'none';
                    return;
                }

                // Reset to total view (default)
                currentChartType = 'total';
                document.getElementById('btn-weekly').classList.remove('active');
                document.getElementById('btn-total').classList.add('active');

                // Show container first so it has dimensions
                chartContainer.style.display = 'block';

                // Use requestAnimationFrame to ensure DOM is updated before rendering
                requestAnimationFrame(() => {
                    renderSeasonChart(chartEl, currentChartData, currentChartType);
                });

            } catch (error) {
                console.error('Error loading season chart:', error);
                chartContainer.style.display = 'none';
            }
        }

        function setChartType(type) {
            if (type === currentChartType || !currentChartData) return;

            currentChartType = type;

            // Update button states
            document.getElementById('btn-weekly').classList.toggle('active', type === 'weekly');
            document.getElementById('btn-total').classList.toggle('active', type === 'total');

            // Re-render chart
            const chartEl = document.getElementById('season-chart');
            renderSeasonChart(chartEl, currentChartData, currentChartType);
        }

        function processScoresForChart(scoresData, standings, teamLogos, teamData) {
            // Group scores by week first
            const weeklyScores = {};
            const teamInfo = {};

            // Collect all scores by week and team info
            scoresData.forEach(entry => {
                const teamKey = entry.team_key;
                const week = entry.week;
                const score = entry.team_score;

                // Store team info
                if (!teamInfo[teamKey]) {
                    const standingTeam = standings.find(t => t.team_key === teamKey);
                    const teamDataEntry = teamData.find(t => t.team_key === teamKey);

                    teamInfo[teamKey] = {
                        team_key: teamKey,
                        team_name: standingTeam?.team_name || teamDataEntry?.team_name || 'Unknown Team',
                        manager: standingTeam?.manager || teamDataEntry?.manager || 'Unknown',
                        logo: teamLogos[teamKey] || teamDataEntry?.team_logo || ''
                    };
                }

                // Store weekly score
                if (!weeklyScores[week]) {
                    weeklyScores[week] = [];
                }
                weeklyScores[week].push({
                    team_key: teamKey,
                    score: score
                });
            });

            const weeks = Object.keys(weeklyScores).map(Number).sort((a, b) => a - b);
            const numTeams = Object.keys(teamInfo).length;

            // Calculate WEEKLY rankings
            const teamWeeklyRankings = {};
            weeks.forEach(week => {
                const weekScores = [...weeklyScores[week]].sort((a, b) => b.score - a.score);
                weekScores.forEach((entry, index) => {
                    const rank = index + 1;
                    if (!teamWeeklyRankings[entry.team_key]) {
                        teamWeeklyRankings[entry.team_key] = [];
                    }
                    teamWeeklyRankings[entry.team_key].push({
                        week: week,
                        rank: rank,
                        score: entry.score
                    });
                });
            });

            // Calculate CUMULATIVE rankings
            const teamCumulativeScores = {}; // team_key -> running total
            const teamCumulativeRankings = {};

            weeks.forEach(week => {
                // Update cumulative scores
                weeklyScores[week].forEach(entry => {
                    if (!teamCumulativeScores[entry.team_key]) {
                        teamCumulativeScores[entry.team_key] = 0;
                    }
                    teamCumulativeScores[entry.team_key] += entry.score;
                });

                // Sort teams by cumulative score descending
                const cumulativeRanking = Object.entries(teamCumulativeScores)
                    .map(([teamKey, total]) => ({ team_key: teamKey, cumulative: total }))
                    .sort((a, b) => b.cumulative - a.cumulative);

                // Assign cumulative ranks
                cumulativeRanking.forEach((entry, index) => {
                    const rank = index + 1;
                    if (!teamCumulativeRankings[entry.team_key]) {
                        teamCumulativeRankings[entry.team_key] = [];
                    }
                    teamCumulativeRankings[entry.team_key].push({
                        week: week,
                        rank: rank,
                        cumulative: entry.cumulative
                    });
                });
            });

            // Build result arrays for both types
            const weeklyTeams = [];
            const cumulativeTeams = [];

            Object.keys(teamInfo).forEach(teamKey => {
                const info = teamInfo[teamKey];

                // Weekly data
                const weeklyData = (teamWeeklyRankings[teamKey] || []).sort((a, b) => a.week - b.week);
                const avgWeeklyRank = weeklyData.length > 0
                    ? weeklyData.reduce((sum, r) => sum + r.rank, 0) / weeklyData.length
                    : numTeams;

                weeklyTeams.push({
                    team_key: teamKey,
                    team_name: info.team_name,
                    manager: info.manager,
                    logo: info.logo,
                    data: weeklyData,
                    avgRank: avgWeeklyRank
                });

                // Cumulative data
                const cumulativeData = (teamCumulativeRankings[teamKey] || []).sort((a, b) => a.week - b.week);
                const finalRank = cumulativeData.length > 0
                    ? cumulativeData[cumulativeData.length - 1].rank
                    : numTeams;

                cumulativeTeams.push({
                    team_key: teamKey,
                    team_name: info.team_name,
                    manager: info.manager,
                    logo: info.logo,
                    data: cumulativeData,
                    finalRank: finalRank
                });
            });

            // Sort weekly by average rank, cumulative by final rank
            weeklyTeams.sort((a, b) => a.avgRank - b.avgRank);
            cumulativeTeams.sort((a, b) => a.finalRank - b.finalRank);

            console.log('Teams with ranking data:', weeklyTeams.length);
            console.log('Weeks:', weeks.length);

            return {
                weeklyTeams: weeklyTeams,
                cumulativeTeams: cumulativeTeams,
                numTeams: numTeams,
                weeks: weeks
            };
        }

        function renderSeasonChart(container, chartData, chartType) {
            // Clear previous chart
            container.innerHTML = '';

            const { weeklyTeams, cumulativeTeams, numTeams, weeks } = chartData;
            const teams = chartType === 'weekly' ? weeklyTeams : cumulativeTeams;
            const isWeekly = chartType === 'weekly';

            // Detect mobile
            const isMobile = window.innerWidth <= 768;

            // Chart dimensions - adjusted for mobile
            const containerWidth = container.clientWidth || container.offsetWidth || 900;
            const logoRadius = isMobile ? 10 : 14;
            const logoImageSize = isMobile ? 14 : 20;
            const rowHeight = isMobile ? 28 : 40;

            // On mobile, ensure minimum width for scrolling
            const minChartWidth = isMobile ? Math.max(weeks.length * 25, 600) : 600;

            const margin = { top: 30, right: 30, bottom: 50, left: isMobile ? 40 : 70 };
            const width = Math.max(minChartWidth, containerWidth - margin.left - margin.right);
            const height = Math.max(400, numTeams * rowHeight + 60);

            const minWeek = Math.min(...weeks);
            const maxWeek = Math.max(...weeks);
            const weekRange = maxWeek - minWeek || 1;

            // Scale functions
            const xScale = (week) => margin.left + ((week - minWeek) / weekRange) * width;
            const yScale = (rank) => margin.top + ((rank - 1) / (numTeams - 1)) * (height - margin.top - margin.bottom);

            // Generate colors for teams
            const colors = generateTeamColors(teams.length);
            const teamColorMap = {};
            teams.forEach((team, index) => {
                teamColorMap[team.team_key] = colors[index];
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            svg.setAttribute('class', 'chart-svg');
            svg.style.display = 'block';
            // Don't limit width on mobile to allow scrolling
            if (!isMobile) {
                svg.style.maxWidth = '100%';
            }

            // Draw horizontal grid lines for each rank
            for (let rank = 1; rank <= numTeams; rank++) {
                const y = yScale(rank);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);
                line.setAttribute('class', 'chart-grid-line');
                line.setAttribute('stroke-dasharray', '3,3');
                svg.appendChild(line);

                // Y-axis rank label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - (isMobile ? 15 : 25));
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('class', 'chart-axis-label');
                label.setAttribute('font-size', isMobile ? '10px' : '12px');
                label.textContent = rank;
                svg.appendChild(label);
            }

            // Draw X-axis labels - show fewer on mobile
            const numWeeksTotal = weeks.length;
            const weekStep = Math.max(1, Math.ceil(numWeeksTotal / (isMobile ? 8 : 12)));
            for (let i = 0; i < weeks.length; i += weekStep) {
                const week = weeks[i];
                const x = xScale(week);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - 10);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'chart-axis-label');
                label.setAttribute('font-size', isMobile ? '10px' : '12px');
                label.textContent = `${week}`;
                svg.appendChild(label);
            }

            // X-axis title
            const xTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xTitle.setAttribute('x', margin.left + width / 2);
            xTitle.setAttribute('y', height - 0);
            xTitle.setAttribute('text-anchor', 'middle');
            xTitle.setAttribute('class', 'chart-axis-label');
            xTitle.setAttribute('font-weight', 'bold');
            xTitle.setAttribute('font-size', isMobile ? '11px' : '12px');
            xTitle.textContent = 'Week';
            svg.appendChild(xTitle);

            // Y-axis title
            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('transform', `rotate(-90)`);
            yTitle.setAttribute('x', -(margin.top + (height - margin.top - margin.bottom) / 2));
            yTitle.setAttribute('y', isMobile ? 12 : 15);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('class', 'chart-axis-label');
            yTitle.setAttribute('font-weight', 'bold');
            yTitle.setAttribute('font-size', isMobile ? '11px' : '12px');
            yTitle.textContent = isWeekly ? 'Weekly Rank' : 'Cumulative Rank';
            svg.appendChild(yTitle);

            // Draw lines for each team (draw lines first, then logos on top)
            teams.forEach((team, index) => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Build path
                let d = '';
                team.data.forEach((point, i) => {
                    const x = xScale(point.week);
                    const y = yScale(point.rank);
                    d += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
                });

                path.setAttribute('d', d);
                path.setAttribute('class', 'chart-line');
                path.setAttribute('stroke', colors[index]);
                path.setAttribute('stroke-width', isMobile ? '2' : '2.5');
                path.setAttribute('data-team-key', team.team_key);
                svg.appendChild(path);
            });

            // Add team logo markers at EVERY week for each team
            teams.forEach((team, teamIndex) => {
                team.data.forEach((point) => {
                    const x = xScale(point.week);
                    const y = yScale(point.rank);

                    // Create group for logo marker
                    const logoGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    logoGroup.setAttribute('class', 'team-logo-marker');
                    logoGroup.setAttribute('data-team-key', team.team_key);
                    logoGroup.setAttribute('data-week', point.week);
                    // Store either weekly score or cumulative total
                    logoGroup.setAttribute('data-score', isWeekly ? point.score : point.cumulative);
                    logoGroup.setAttribute('data-is-weekly', isWeekly);
                    logoGroup.setAttribute('transform', `translate(${x}, ${y})`);

                    // Circle background
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', logoRadius);
                    circle.setAttribute('fill', 'white');
                    circle.setAttribute('stroke', colors[teamIndex]);
                    circle.setAttribute('stroke-width', isMobile ? '1.5' : '2');
                    logoGroup.appendChild(circle);

                    // Team logo image
                    if (team.logo) {
                        const imageOffset = logoImageSize / 2;
                        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        image.setAttribute('href', team.logo);
                        image.setAttribute('x', -imageOffset);
                        image.setAttribute('y', -imageOffset);
                        image.setAttribute('width', logoImageSize);
                        image.setAttribute('height', logoImageSize);
                        image.setAttribute('style', `clip-path: circle(${imageOffset}px at center)`);
                        logoGroup.appendChild(image);
                    }

                    // Add hover/touch events
                    const scoreValue = isWeekly ? point.score : point.cumulative;
                    const handleInteraction = (e) => {
                        e.preventDefault();
                        handleTeamHover(team.team_key, team.team_name, scoreValue, point.week, point.rank, isWeekly, e.currentTarget);
                    };

                    logoGroup.addEventListener('mouseenter', handleInteraction);
                    logoGroup.addEventListener('touchstart', handleInteraction, { passive: false });
                    logoGroup.addEventListener('mouseleave', () => handleTeamHoverEnd());
                    logoGroup.addEventListener('touchend', () => setTimeout(handleTeamHoverEnd, 1500));

                    svg.appendChild(logoGroup);
                });
            });

            container.appendChild(svg);

            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.style.display = 'none';
            tooltip.id = 'chart-tooltip';
            container.appendChild(tooltip);

            // Add scroll hint for mobile
            if (isMobile && weeks.length > 10) {
                const scrollHint = document.createElement('div');
                scrollHint.style.cssText = 'text-align: center; color: #666; font-size: 0.8rem; margin-top: 0.5rem;';
                scrollHint.textContent = 'Scroll to see all weeks';
                container.appendChild(scrollHint);
            }
        }

        function generateTeamColors(count) {
            const baseColors = [
                '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
                '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
                '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
                '#aaffc3'
            ];

            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(baseColors[i % baseColors.length]);
            }
            return colors;
        }

        function handleTeamHover(teamKey, teamName, score, week, rank, isWeekly, markerElement) {
            // Fade all lines and markers except the hovered team
            document.querySelectorAll('.chart-line').forEach(line => {
                if (line.getAttribute('data-team-key') === teamKey) {
                    line.classList.add('highlighted');
                    line.classList.remove('faded');
                } else {
                    line.classList.add('faded');
                    line.classList.remove('highlighted');
                }
            });

            document.querySelectorAll('.team-logo-marker').forEach(marker => {
                if (marker.getAttribute('data-team-key') === teamKey) {
                    marker.classList.add('highlighted');
                    marker.classList.remove('faded');
                } else {
                    marker.classList.add('faded');
                    marker.classList.remove('highlighted');
                }
            });

            // Show tooltip with appropriate label
            const tooltip = document.getElementById('chart-tooltip');

            if (tooltip && markerElement) {
                const containerRect = document.getElementById('season-chart').getBoundingClientRect();
                const markerRect = markerElement.getBoundingClientRect();

                const scoreLabel = isWeekly ? `Week ${week}: ${score.toLocaleString()} pts` : `Total: ${score.toLocaleString()} pts`;
                tooltip.innerHTML = `<strong>${teamName}</strong><br>${scoreLabel}<br>Rank: #${rank}`;
                tooltip.style.display = 'block';
                tooltip.style.left = (markerRect.left - containerRect.left + markerRect.width / 2) + 'px';
                tooltip.style.top = (markerRect.top - containerRect.top - 5) + 'px';
            }
        }

        function handleTeamHoverEnd() {
            // Remove all faded/highlighted classes
            document.querySelectorAll('.chart-line').forEach(line => {
                line.classList.remove('faded', 'highlighted');
            });

            document.querySelectorAll('.team-logo-marker').forEach(marker => {
                marker.classList.remove('faded', 'highlighted');
            });

            // Hide tooltip
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // ===== DRAFT PERFORMANCE TICKER =====
        let draftTickerInterval = null;
        let currentTickerIndex = 0;
        
        async function loadDraftPerformanceTicker(seasonNum, isCurrentSeason, teamLogos, teamData) {
            const tickerContainer = document.getElementById('draft-performance-ticker');
            const cardsContainer = document.getElementById('draft-performance-cards');
            
            if (!tickerContainer || !cardsContainer) return;
            
            // Clear any existing interval
            if (draftTickerInterval) {
                clearInterval(draftTickerInterval);
                draftTickerInterval = null;
            }
            
            try {
                // Ensure expectedPointsByRound is calculated
                if (Object.keys(expectedPointsByRound).length === 0) {
                    await calculateExpectedPoints();
                }
                
                // Load keepers data
                let allKeepersData = {};
                try {
                    const keepersResponse = await fetch('data/keepers.json');
                    if (keepersResponse.ok) {
                        allKeepersData = await keepersResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load keepers data');
                }
                
                // Load draft data
                const draftPath = isCurrentSeason 
                    ? 'data/historical/2025/draft.json'
                    : `data/historical/${seasonNum}/draft.json`;
                const draftResponse = await fetch(draftPath);
                if (!draftResponse.ok) {
                    tickerContainer.style.display = 'none';
                    return;
                }
                const draftData = await draftResponse.json();
                
                // Load player stats
                const statsPath = isCurrentSeason
                    ? 'data/historical/2025/player_stats.json'
                    : `data/historical/${seasonNum}/player_stats.json`;
                const statsResponse = await fetch(statsPath);
                if (!statsResponse.ok) {
                    tickerContainer.style.display = 'none';
                    return;
                }
                const statsData = await statsResponse.json();
                
                const playerStatsByName = {};
                statsData.forEach(p => {
                    if (p.name) {
                        playerStatsByName[p.name.toLowerCase().trim()] = p;
                    }
                });
                
                // Build team info lookup
                const teamInfoByKey = {};
                teamData.forEach(team => {
                    teamInfoByKey[team.team_key] = {
                        team_name: team.team_name || team.name,
                        manager: normalizeManagerName(team.manager, seasonNum, team.team_name, team.team_key),
                        logo: teamLogos[team.team_key] || ''
                    };
                });
                
                // Get keepers for this year
                const yearKeepers = allKeepersData[seasonNum.toString()] || {};
                const keeperNamesLower = Object.keys(yearKeepers).map(n => n.toLowerCase().trim());
                
                // Group picks by team and calculate performance
                const teamPerformance = {};
                
                draftData.forEach(pick => {
                    const teamKey = pick.team_key;
                    const playerName = pick.player_name || '';
                    const round = pick.round || 0;
                    
                    // Skip keepers
                    if (keeperNamesLower.includes(playerName.toLowerCase().trim())) {
                        return;
                    }
                    
                    if (!teamPerformance[teamKey]) {
                        teamPerformance[teamKey] = {
                            expected: 0,
                            actual: 0,
                            picks: []
                        };
                    }
                    
                    const playerStats = playerStatsByName[playerName.toLowerCase().trim()];
                    const actualPoints = playerStats?.fantasy_points || 0;
                    const expectedPoints = getExpectedPointsForRound(round);
                    
                    teamPerformance[teamKey].expected += expectedPoints;
                    teamPerformance[teamKey].actual += actualPoints;
                    teamPerformance[teamKey].picks.push({ playerName, round, actualPoints, expectedPoints });
                });
                
                // Calculate scores and collect for percentile ranking
                const allScores = [];
                const teamResults = [];
                
                for (const [teamKey, perf] of Object.entries(teamPerformance)) {
                    const score = perf.expected > 0 ? ((perf.actual - perf.expected) / perf.expected) * 100 : 0;
                    const teamInfo = teamInfoByKey[teamKey] || { team_name: 'Unknown', manager: 'Unknown', logo: '' };
                    
                    teamResults.push({
                        teamKey,
                        teamName: teamInfo.team_name,
                        manager: teamInfo.manager,
                        logo: teamInfo.logo,
                        expected: perf.expected,
                        actual: perf.actual,
                        score: score,
                        picks: perf.picks.length
                    });
                    
                    allScores.push(score);
                }
                
                allScores.sort((a, b) => a - b);
                
                // Add percentile and grade to each team
                teamResults.forEach(team => {
                    team.percentile = calculatePercentile(team.score, allScores);
                    team.grade = percentileToGrade(team.percentile);
                });
                
                // Sort by score descending (best drafters first)
                teamResults.sort((a, b) => b.score - a.score);
                
                if (teamResults.length === 0) {
                    tickerContainer.style.display = 'none';
                    return;
                }
                
                // Render ticker
                renderDraftTicker(cardsContainer, teamResults);
                tickerContainer.style.display = 'block';
                
                // Start auto-scroll
                currentTickerIndex = 0;
                draftTickerInterval = setInterval(() => {
                    currentTickerIndex = (currentTickerIndex + 1) % teamResults.length;
                    scrollToTickerCard(currentTickerIndex);
                }, 15000);
                
            } catch (e) {
                console.error('Error loading draft performance ticker:', e);
                tickerContainer.style.display = 'none';
            }
        }
        
        function renderDraftTicker(container, teamResults) {
            container.innerHTML = `
                <div class="draft-ticker-wrapper">
                    <button class="ticker-nav-btn ticker-prev" onclick="tickerPrev()"></button>
                    <div class="draft-ticker-viewport">
                        <div class="draft-ticker-track" id="draft-ticker-track">
                            ${teamResults.map((team, idx) => {
                                const gradeColor = getGradeColor(team.grade);
                                const bgColor = getGradeBackgroundColor(team.grade);
                                const diff = team.actual - team.expected;
                                const diffSign = diff >= 0 ? '+' : '';
                                const diffClass = diff >= 0 ? 'draft-perf-diff-positive' : 'draft-perf-diff-negative';
                                
                                return `
                                    <div class="draft-ticker-card" data-index="${idx}" onclick="scrollToTickerCard(${idx})" style="border-left-color: ${gradeColor};">
                                        <div class="draft-perf-header">
                                            ${team.logo ? `<img src="${team.logo}" class="draft-perf-logo" alt="">` : '<div class="draft-perf-logo-placeholder"></div>'}
                                            <div class="draft-perf-team-info">
                                                <div class="draft-perf-team-name">${team.teamName}</div>
                                                <div class="draft-perf-manager">${team.manager}</div>
                                            </div>
                                            <div class="draft-perf-grade" style="background: ${bgColor}; color: ${gradeColor};">${team.grade}</div>
                                        </div>
                                        <div class="draft-perf-stats">
                                            <div class="draft-perf-stat">
                                                <div class="draft-perf-stat-value">${Math.round(team.expected).toLocaleString()}</div>
                                                <div class="draft-perf-stat-label">Expected</div>
                                            </div>
                                            <div class="draft-perf-stat">
                                                <div class="draft-perf-stat-value">${Math.round(team.actual).toLocaleString()}</div>
                                                <div class="draft-perf-stat-label">Actual</div>
                                            </div>
                                            <div class="draft-perf-stat">
                                                <div class="draft-perf-stat-value ${diffClass}">${diffSign}${Math.round(diff).toLocaleString()}</div>
                                                <div class="draft-perf-stat-label">Diff</div>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    <button class="ticker-nav-btn ticker-next" onclick="tickerNext()"></button>
                </div>
                <div class="ticker-dots" id="ticker-dots">
                    ${teamResults.map((_, idx) => `<span class="ticker-dot ${idx === 0 ? 'active' : ''}" onclick="scrollToTickerCard(${idx})"></span>`).join('')}
                </div>
            `;
        }
        
        function scrollToTickerCard(index) {
            const track = document.getElementById('draft-ticker-track');
            const dots = document.querySelectorAll('.ticker-dot');
            const cards = document.querySelectorAll('.draft-ticker-card');
            
            if (!track || cards.length === 0) return;
            
            currentTickerIndex = index;
            
            // Use percentage-based translation (100% per card + gap)
            const viewport = track.parentElement;
            const viewportWidth = viewport.offsetWidth;
            const gap = 12; // 0.75rem gap
            track.style.transform = `translateX(-${index * (viewportWidth + gap)}px)`;
            
            // Update dots
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            
            // Reset interval on manual navigation
            if (draftTickerInterval) {
                clearInterval(draftTickerInterval);
                draftTickerInterval = setInterval(() => {
                    currentTickerIndex = (currentTickerIndex + 1) % cards.length;
                    scrollToTickerCard(currentTickerIndex);
                }, 15000);
            }
        }
        
        function tickerPrev() {
            const cards = document.querySelectorAll('.draft-ticker-card');
            if (cards.length === 0) return;
            currentTickerIndex = (currentTickerIndex - 1 + cards.length) % cards.length;
            scrollToTickerCard(currentTickerIndex);
        }
        
        function tickerNext() {
            const cards = document.querySelectorAll('.draft-ticker-card');
            if (cards.length === 0) return;
            currentTickerIndex = (currentTickerIndex + 1) % cards.length;
            scrollToTickerCard(currentTickerIndex);
        }

        // ===== CALCULATE MANAGER AWARDS =====
        async function calculateManagerAwards() {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const seasonData = {};

            // Load keepers data
            let allKeepers = {};
            try {
                const keepersResponse = await fetch('data/keepers.json');
                if (keepersResponse.ok) {
                    allKeepers = await keepersResponse.json();
                }
            } catch (e) {
                console.log('No keepers data available');
            }

            // Load all seasons data including player stats and draft
            for (const year of seasons) {
                try {
                    let standingsResponse, playerStatsResponse, draftResponse, teamsResponse;

                    if (year === 2025) {
                        standingsResponse = await fetch('data/historical/2025/standings.json');
                        playerStatsResponse = await fetch('data/historical/2025/player_stats.json');
                        draftResponse = await fetch('data/historical/2025/draft.json');
                        teamsResponse = await fetch('data/historical/2025/teams.json');
                    } else {
                        standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                        playerStatsResponse = await fetch(`data/historical/${year}/player_stats.json`);
                        draftResponse = await fetch(`data/historical/${year}/draft.json`);
                        teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                    }

                    if (standingsResponse.ok) {
                        const standings = await standingsResponse.json();
                        const normalizedStandings = normalizeStandingsData(standings, year);
                        const playerStats = playerStatsResponse.ok ? await playerStatsResponse.json() : [];
                        const draftData = draftResponse && draftResponse.ok ? await draftResponse.json() : [];
                        const teams = teamsResponse && teamsResponse.ok ? await teamsResponse.json() : [];

                        // Create team info map
                        const teamInfoMap = {};
                        teams.forEach(team => {
                            teamInfoMap[team.team_key] = {
                                name: team.team_name,
                                manager: team.manager,
                                logo: fixTeamLogo(team.team_logo)
                            };
                        });

                        seasonData[year] = {
                            standings: normalizedStandings,
                            playerStats: playerStats,
                            draftData: draftData,
                            teamInfo: teamInfoMap
                        };
                    }
                } catch (e) {
                    console.error(`Error loading ${year}:`, e);
                }
            }

            // Calculate awards by manager
            const managerAwards = {};

            for (const [year, data] of Object.entries(seasonData)) {
                const standings = data.standings;
                const playerStats = data.playerStats || [];

                // Find winners for each award category
                const mostWins = standings.reduce((max, team) =>
                    team.wins > max.wins ? team : max
                );
                const mostPoints = standings.reduce((max, team) =>
                    team.points_for > max.points_for ? team : max
                );
                const fewestWins = standings.reduce((min, team) =>
                    team.wins < min.wins ? team : min
                );
                const leastPoints = standings.reduce((min, team) =>
                    team.points_for < min.points_for ? team : min
                );
                const champion = standings.find(team => team.rank === 1);

                // Track awards
                if (champion) {
                    if (!managerAwards[champion.manager]) managerAwards[champion.manager] = {};
                    managerAwards[champion.manager].championships = (managerAwards[champion.manager].championships || 0) + 1;
                    if (!managerAwards[champion.manager].championshipYears) managerAwards[champion.manager].championshipYears = [];
                    managerAwards[champion.manager].championshipYears.push(year);
                }

                if (!managerAwards[mostWins.manager]) managerAwards[mostWins.manager] = {};
                managerAwards[mostWins.manager].regularSeason = (managerAwards[mostWins.manager].regularSeason || 0) + 1;
                if (!managerAwards[mostWins.manager].regularSeasonYears) managerAwards[mostWins.manager].regularSeasonYears = [];
                managerAwards[mostWins.manager].regularSeasonYears.push(year);

                if (!managerAwards[mostPoints.manager]) managerAwards[mostPoints.manager] = {};
                managerAwards[mostPoints.manager].scoringChamp = (managerAwards[mostPoints.manager].scoringChamp || 0) + 1;
                if (!managerAwards[mostPoints.manager].scoringChampYears) managerAwards[mostPoints.manager].scoringChampYears = [];
                managerAwards[mostPoints.manager].scoringChampYears.push(year);

                if (!managerAwards[fewestWins.manager]) managerAwards[fewestWins.manager] = {};
                managerAwards[fewestWins.manager].garbage = (managerAwards[fewestWins.manager].garbage || 0) + 1;
                if (!managerAwards[fewestWins.manager].garbageYears) managerAwards[fewestWins.manager].garbageYears = [];
                managerAwards[fewestWins.manager].garbageYears.push(year);

                if (!managerAwards[leastPoints.manager]) managerAwards[leastPoints.manager] = {};
                managerAwards[leastPoints.manager].clown = (managerAwards[leastPoints.manager].clown || 0) + 1;
                if (!managerAwards[leastPoints.manager].clownYears) managerAwards[leastPoints.manager].clownYears = [];
                managerAwards[leastPoints.manager].clownYears.push(year);

                // Mike Trout Award (highest scoring hitter)
                const batters = playerStats.filter(p => p.position_type === 'B');
                if (batters.length > 0) {
                    const topHitter = batters.reduce((max, player) =>
                        (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                    );
                    // Find the team_key for this player's manager
                    const playerTeam = standings.find(t => t.team_name === topHitter.team_name);
                    const teamKey = playerTeam ? playerTeam.team_key : null;

                    // NORMALIZE THE MANAGER NAME with team info
                    const normalizedManager = normalizeManagerName(topHitter.manager, parseInt(year), topHitter.team_name, teamKey);
                    if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                    managerAwards[normalizedManager].troutAward = (managerAwards[normalizedManager].troutAward || 0) + 1;
                    if (!managerAwards[normalizedManager].troutAwardYears) managerAwards[normalizedManager].troutAwardYears = [];
                    managerAwards[normalizedManager].troutAwardYears.push(year);
                }

                // Jacob deGrom Award (highest scoring pitcher)
                const pitchers = playerStats.filter(p => p.position_type === 'P');
                if (pitchers.length > 0) {
                    const topPitcher = pitchers.reduce((max, player) =>
                        (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                    );
                    // Find the team_key for this player's manager
                    const playerTeam = standings.find(t => t.team_name === topPitcher.team_name);
                    const teamKey = playerTeam ? playerTeam.team_key : null;

                    // NORMALIZE THE MANAGER NAME with team info
                    const normalizedManager = normalizeManagerName(topPitcher.manager, parseInt(year), topPitcher.team_name, teamKey);
                    if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                    managerAwards[normalizedManager].degromAward = (managerAwards[normalizedManager].degromAward || 0) + 1;
                    if (!managerAwards[normalizedManager].degromAwardYears) managerAwards[normalizedManager].degromAwardYears = [];
                    managerAwards[normalizedManager].degromAwardYears.push(year);
                }

                // Diamond in the Rough & Bust of the Year Awards
                const draftData = data.draftData || [];
                const teamInfo = data.teamInfo || {};
                const keepersForYear = allKeepers[year.toString()] || {};

                // Create lowercase keeper lookup
                const keepersLower = {};
                for (const name of Object.keys(keepersForYear)) {
                    keepersLower[name.toLowerCase()] = true;
                }

                if (draftData.length > 0 && playerStats.length > 0) {
                    // Create player stats lookup by name (lowercase)
                    const playerStatsMap = {};
                    playerStats.forEach(p => {
                        if (p.name) {
                            playerStatsMap[p.name.toLowerCase()] = p;
                        }
                    });

                    // Sort players by fantasy points to get expected value by rank
                    const sortedByPoints = [...playerStats]
                        .filter(p => p.fantasy_points && p.fantasy_points > 0)
                        .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));

                    // Create expected points by overall rank (pick number)
                    const expectedPointsByPick = {};
                    sortedByPoints.forEach((p, idx) => {
                        expectedPointsByPick[idx + 1] = p.fantasy_points || 0;
                    });

                    // Calculate value over expected for each draft pick (excluding keepers)
                    const draftValues = [];
                    draftData.forEach(pick => {
                        const playerName = pick.player_name || '';
                        const pickNum = pick.pick || 0;

                        // Skip keepers
                        if (keepersLower[playerName.toLowerCase()]) {
                            return;
                        }

                        // Get actual points
                        const playerData = playerStatsMap[playerName.toLowerCase()];
                        const actualPoints = playerData ? (playerData.fantasy_points || 0) : 0;

                        // Define headshot
                        const headshot = (playerData && playerData.headshot_url) ? playerData.headshot_url : (pick.headshot_url || '');

                        // Get expected points based on pick position
                        const expectedPoints = expectedPointsByPick[pickNum] || 0;

                        // Calculate value over expected
                        const valueOverExpected = actualPoints - expectedPoints;

                        // Get team info
                        const team = teamInfo[pick.team_key] || {};

                        // Get normalized manager name
                        const managerName = team.manager ? normalizeManagerName(team.manager, parseInt(year), team.name, pick.team_key) : '';

                        draftValues.push({
                            player_name: playerName,
                            player_headshot: headshot,
                            pick: pickNum,
                            round: pick.round || Math.ceil(pickNum / 12),
                            actualPoints: actualPoints,
                            expectedPoints: expectedPoints,
                            valueOverExpected: valueOverExpected,
                            manager: managerName, // Use the normalized name here
                            team_logo: team.logo || ''
                        });
                    });

                    // Find best value (Diamond) - highest positive value over expected
                    if (draftValues.length > 0) {
                        const bestValue = draftValues.reduce((best, pick) =>
                            pick.valueOverExpected > best.valueOverExpected ? pick : best
                        );
                        if (bestValue.valueOverExpected > 0 && bestValue.manager) {
                            const normalizedManager = normalizeManagerName(bestValue.manager, parseInt(year), null, bestValue.team_key);
                            if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                            managerAwards[normalizedManager].diamondAward = (managerAwards[normalizedManager].diamondAward || 0) + 1;
                            if (!managerAwards[normalizedManager].diamondAwardYears) managerAwards[normalizedManager].diamondAwardYears = [];
                            managerAwards[normalizedManager].diamondAwardYears.push(year);
                        }

                        // Find worst value (Bust) - only from first 5 rounds
                        const earlyPicks = draftValues.filter(p => p.round <= 5);
                        if (earlyPicks.length > 0) {
                            const worstValue = earlyPicks.reduce((worst, pick) =>
                                pick.valueOverExpected < worst.valueOverExpected ? pick : worst
                            );
                            if (worstValue.valueOverExpected < 0 && worstValue.manager) {
                                const normalizedManager = normalizeManagerName(worstValue.manager, parseInt(year), null, worstValue.team_key);
                                if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                                managerAwards[normalizedManager].bustAward = (managerAwards[normalizedManager].bustAward || 0) + 1;
                                if (!managerAwards[normalizedManager].bustAwardYears) managerAwards[normalizedManager].bustAwardYears = [];
                                managerAwards[normalizedManager].bustAwardYears.push(year);
                            }
                        }
                    }
                }
            }

            return managerAwards;
        }

        // ===== DRAFT GRADE CALCULATION =====
        let managerDraftGrades = {}; // { managerName: { grades: [{year, score, grade}], avgScore, avgGrade } }
        let draftGradesLoaded = false;
        
        async function calculateDraftGrades() {
            if (draftGradesLoaded) return managerDraftGrades;
            
            console.log('Calculating draft grades...');
            
            // Load keepers data
            let allKeepersData = {};
            try {
                const keepersResponse = await fetch('data/keepers.json');
                if (keepersResponse.ok) {
                    allKeepersData = await keepersResponse.json();
                }
            } catch (e) {
                console.log('Could not load keepers data for draft grades');
            }
            
            // Ensure expectedPointsByRound is calculated (reuse from preseason tools)
            if (Object.keys(expectedPointsByRound).length === 0) {
                await calculateExpectedPoints();
            }
            
            console.log('Using expected points by round:', expectedPointsByRound);
            
            // Years to analyze (completed seasons only)
            const years = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            
            // Store yearly results with grades calculated per-season
            const yearlyResults = {}; // { year: { manager: { expected, actual, score, grade, percentile } } }
            
            for (const year of years) {
                try {
                    // Load draft data
                    const draftPath = year === 2026 
                        ? 'data/historical/2025/draft.json'
                        : `data/historical/${year}/draft.json`;
                    const draftResponse = await fetch(draftPath);
                    if (!draftResponse.ok) continue;
                    const draftData = await draftResponse.json();
                    
                    // Load teams to map team_key to manager
                    const teamsPath = year === 2026
                        ? 'data/historical/2025/teams.json'
                        : `data/historical/${year}/teams.json`;
                    const teamsResponse = await fetch(teamsPath);
                    if (!teamsResponse.ok) continue;
                    const teamsData = await teamsResponse.json();
                    
                    // Map team_key to normalized manager name
                    const teamKeyToManager = {};
                    teamsData.forEach(team => {
                        const normalizedManager = normalizeManagerName(team.manager, year, team.team_name, team.team_key);
                        teamKeyToManager[team.team_key] = normalizedManager;
                    });
                    
                    // Load player stats for actual points
                    const statsPath = year === 2026
                        ? 'data/historical/2025/player_stats.json'
                        : `data/historical/${year}/player_stats.json`;
                    const statsResponse = await fetch(statsPath);
                    if (!statsResponse.ok) continue;
                    const statsData = await statsResponse.json();
                    
                    const playerStatsByName = {};
                    statsData.forEach(p => {
                        if (p.name) {
                            playerStatsByName[p.name.toLowerCase().trim()] = p;
                        }
                    });
                    
                    // Get keepers for this year
                    const yearKeepers = allKeepersData[year.toString()] || {};
                    const keeperNamesLower = Object.keys(yearKeepers).map(n => n.toLowerCase().trim());
                    
                    // Group picks by manager (excluding keepers)
                    const managerPicks = {}; // { managerName: [picks] }
                    
                    draftData.forEach(pick => {
                        const teamKey = pick.team_key;
                        const manager = teamKeyToManager[teamKey];
                        if (!manager) return;
                        
                        const playerName = pick.player_name || '';
                        const round = pick.round || 0;
                        
                        // Skip if this player was a keeper
                        if (keeperNamesLower.includes(playerName.toLowerCase().trim())) {
                            return;
                        }
                        
                        if (!managerPicks[manager]) {
                            managerPicks[manager] = [];
                        }
                        
                        // Get actual fantasy points for this player
                        const playerStats = playerStatsByName[playerName.toLowerCase().trim()];
                        const actualPoints = playerStats?.fantasy_points || 0;
                        const expectedPoints = getExpectedPointsForRound(round);
                        
                        managerPicks[manager].push({
                            playerName,
                            round,
                            actualPoints,
                            expectedPoints
                        });
                    });
                    
                    // Calculate score for each manager this year
                    const yearScores = [];
                    const yearManagerData = {};
                    
                    for (const [manager, picks] of Object.entries(managerPicks)) {
                        if (picks.length === 0) continue;
                        
                        const totalExpected = picks.reduce((sum, p) => sum + p.expectedPoints, 0);
                        const totalActual = picks.reduce((sum, p) => sum + p.actualPoints, 0);
                        
                        // Score = (actual - expected) / expected * 100, as a percentage over/under expectation
                        const score = totalExpected > 0 ? ((totalActual - totalExpected) / totalExpected) * 100 : 0;
                        
                        yearManagerData[manager] = {
                            expected: totalExpected,
                            actual: totalActual,
                            score: score,
                            picks: picks.length
                        };
                        
                        yearScores.push(score);
                    }
                    
                    // Sort scores for percentile calculation within this year
                    yearScores.sort((a, b) => a - b);
                    
                    // Calculate percentiles and grades within this year
                    for (const [manager, data] of Object.entries(yearManagerData)) {
                        const percentile = calculatePercentile(data.score, yearScores);
                        const grade = percentileToGrade(percentile);
                        
                        yearManagerData[manager].percentile = percentile;
                        yearManagerData[manager].grade = grade;
                    }
                    
                    yearlyResults[year] = yearManagerData;
                    
                } catch (e) {
                    console.log(`Error processing draft grades for ${year}:`, e);
                }
            }
            
            // Now build managerDraftGrades from yearlyResults
            const allManagerNames = new Set();
            for (const year of Object.keys(yearlyResults)) {
                for (const manager of Object.keys(yearlyResults[year])) {
                    allManagerNames.add(manager);
                }
            }
            
            for (const manager of allManagerNames) {
                const grades = [];
                
                for (const year of years) {
                    const yearData = yearlyResults[year]?.[manager];
                    if (yearData) {
                        grades.push({
                            year: year,
                            score: yearData.score,
                            grade: yearData.grade,
                            draftPoints: gradeToPoints(yearData.grade),
                            expected: yearData.expected,
                            actual: yearData.actual,
                            picks: yearData.picks,
                            percentile: yearData.percentile
                        });
                    }
                }
                
                if (grades.length > 0) {
                    // Calculate average score
                    const avgScore = grades.reduce((sum, g) => sum + g.score, 0) / grades.length;
                    
                    // Calculate average draft points
                    const avgDraftPoints = grades.reduce((sum, g) => sum + g.draftPoints, 0) / grades.length;
                    
                    // Apply small sample penalty: subtract points for fewer seasons
                    // 1 season = -1.5 points, 2 seasons = -1.0, 3 seasons = -0.5, 4+ = no penalty
                    const seasons = grades.length;
                    let samplePenalty = 0;
                    if (seasons === 1) samplePenalty = 1.5;
                    else if (seasons === 2) samplePenalty = 1.0;
                    else if (seasons === 3) samplePenalty = 0.5;
                    
                    const adjustedDraftPoints = avgDraftPoints - samplePenalty;
                    
                    // For avg grade, collect all scores from all years this manager participated in
                    // and calculate percentile against those year's scores
                    const allYearScores = [];
                    for (const g of grades) {
                        const yearData = yearlyResults[g.year];
                        if (yearData) {
                            for (const m of Object.keys(yearData)) {
                                allYearScores.push(yearData[m].score);
                            }
                        }
                    }
                    allYearScores.sort((a, b) => a - b);
                    
                    const avgPercentile = calculatePercentile(avgScore, allYearScores);
                    const avgGrade = percentileToGrade(avgPercentile);
                    
                    managerDraftGrades[manager] = {
                        grades: grades.sort((a, b) => b.year - a.year),
                        avgScore: avgScore,
                        avgGrade: avgGrade,
                        avgPercentile: avgPercentile,
                        avgDraftPoints: avgDraftPoints,
                        adjustedDraftPoints: adjustedDraftPoints,
                        seasons: seasons
                    };
                }
            }
            
            console.log('Draft grades calculated:', Object.keys(managerDraftGrades).length, 'managers');
            console.log('Sample draft grades:', managerDraftGrades);
            draftGradesLoaded = true;
            return managerDraftGrades;
        }
        
        function calculatePercentile(value, sortedArray) {
            if (sortedArray.length === 0) return 50;
            let count = 0;
            for (const v of sortedArray) {
                if (v < value) count++;
            }
            return (count / sortedArray.length) * 100;
        }
        
        function percentileToGrade(percentile) {
            if (percentile >= 95) return 'A+';
            if (percentile >= 90) return 'A';
            if (percentile >= 85) return 'A-';
            if (percentile >= 80) return 'B+';
            if (percentile >= 70) return 'B';
            if (percentile >= 60) return 'B-';
            if (percentile >= 50) return 'C+';
            if (percentile >= 40) return 'C';
            if (percentile >= 30) return 'C-';
            if (percentile >= 20) return 'D+';
            if (percentile >= 10) return 'D';
            if (percentile >= 5) return 'D-';
            return 'F';
        }
        
        function gradeToPoints(grade) {
            const gradePoints = {
                'A+': 12, 'A': 11, 'A-': 10,
                'B+': 9, 'B': 8, 'B-': 7,
                'C+': 6, 'C': 5, 'C-': 4,
                'D+': 3, 'D': 2, 'D-': 1,
                'F': 0
            };
            return gradePoints[grade] !== undefined ? gradePoints[grade] : 5;
        }
        
        function pointsToGrade(points) {
            if (points >= 11.5) return 'A+';
            if (points >= 10.5) return 'A';
            if (points >= 9.5) return 'A-';
            if (points >= 8.5) return 'B+';
            if (points >= 7.5) return 'B';
            if (points >= 6.5) return 'B-';
            if (points >= 5.5) return 'C+';
            if (points >= 4.5) return 'C';
            if (points >= 3.5) return 'C-';
            if (points >= 2.5) return 'D+';
            if (points >= 1.5) return 'D';
            if (points >= 0.5) return 'D-';
            return 'F';
        }
        
        function getGradeColor(grade) {
            const gradeColors = {
                'A+': '#0d6e0d', 'A': '#1a8f1a', 'A-': '#2eaa2e',
                'B+': '#5cb85c', 'B': '#7bc87b', 'B-': '#9ad89a',
                'C+': '#f0ad4e', 'C': '#ec971f', 'C-': '#d58512',
                'D+': '#e07020', 'D': '#d9534f', 'D-': '#c9302c',
                'F': '#a02020'
            };
            return gradeColors[grade] || '#666';
        }
        
        function getGradeBackgroundColor(grade) {
            const bgColors = {
                'A+': 'rgba(13, 110, 13, 0.15)', 'A': 'rgba(26, 143, 26, 0.15)', 'A-': 'rgba(46, 170, 46, 0.15)',
                'B+': 'rgba(92, 184, 92, 0.15)', 'B': 'rgba(123, 200, 123, 0.15)', 'B-': 'rgba(154, 216, 154, 0.15)',
                'C+': 'rgba(240, 173, 78, 0.15)', 'C': 'rgba(236, 151, 31, 0.15)', 'C-': 'rgba(213, 133, 18, 0.15)',
                'D+': 'rgba(224, 112, 32, 0.15)', 'D': 'rgba(217, 83, 79, 0.15)', 'D-': 'rgba(201, 48, 44, 0.15)',
                'F': 'rgba(160, 32, 32, 0.15)'
            };
            return bgColors[grade] || 'transparent';
        }

        // ===== LOAD MANAGER PROFILES =====
        async function loadManagerProfiles() {
            const loadingEl = document.getElementById('managers-loading');
            const errorEl = document.getElementById('managers-error');
            const gridEl = document.getElementById('manager-grid');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                gridEl.innerHTML = '';

                // Load manager stats
                const response = await fetch('data/managers/all_time_stats.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawManagersData = await response.json();

                // Load manager history for detailed view
                const historyResponse = await fetch('data/managers/manager_history.json');
                if (historyResponse.ok) {
                    managerHistoryData = await historyResponse.json();
                }

                // Normalize and merge manager data
                allManagersData = normalizeAndMergeManagerData(rawManagersData, managerHistoryData);

                // Inject 2026 season data from current_season if not already present
                const currentStandingsForInjection = await fetch('data/current_season/standings.json');
                if (currentStandingsForInjection.ok) {
                    const currentStandings2026 = await currentStandingsForInjection.json();
                    const normalized2026 = normalizeStandingsData(currentStandings2026, 2026);
                    
                    // Get 2026 team data for logos
                    const teams2026 = await getTeamData(2026);
                    
                    allManagersData.forEach(manager => {
                        // Check if manager already has 2026 season
                        const has2026 = manager.season_history.some(s => s.year === 2026);
                        if (!has2026) {
                            // Find this manager in current standings
                            const current2026 = normalized2026.find(t => 
                                normalizeManagerName(t.manager, 2026, t.team_name) === manager.manager_name
                            );
                            if (current2026) {
                                // Add 2026 season to history
                                manager.season_history.push({
                                    year: 2026,
                                    team_name: current2026.team_name,
                                    wins: current2026.wins || 0,
                                    losses: current2026.losses || 0,
                                    ties: current2026.ties || 0,
                                    points_for: current2026.points_for || 0,
                                    points_against: current2026.points_against || 0,
                                    rank: current2026.rank || 0
                                });
                                
                                // Update totals
                                manager.total_wins += current2026.wins || 0;
                                manager.total_losses += current2026.losses || 0;
                                manager.total_ties += current2026.ties || 0;
                                manager.total_points_for += current2026.points_for || 0;
                                manager.seasons_played += 1;
                                
                                // Recalculate win percentage
                                const totalGames = manager.total_wins + manager.total_losses + manager.total_ties;
                                manager.win_pct = totalGames > 0 ? manager.total_wins / totalGames : 0;
                            }
                        }
                    });
                }

                // Determine all unique seasons we need to load
                const allSeasons = new Set();
                allManagersData.forEach(manager => {
                    manager.season_history.forEach(season => {
                        allSeasons.add(season.year);
                    });
                });

                // Pre-load team data for all seasons in parallel
                await Promise.all(Array.from(allSeasons).map(year => getTeamData(year)));

                // Calculate awards for all managers
                const managerAwards = await calculateManagerAwards();
                managerAwardsData = managerAwards; // Store globally for modal access
                
                // Calculate draft grades for all managers
                await calculateDraftGrades();

                // Now build manager logos using cached data
                const managerLogos = {};
                for (const manager of allManagersData) {
                    const recentSeason = Math.max(...manager.season_history.map(s => s.year));
                    const recentSeasonData = manager.season_history.find(s => s.year === recentSeason);

                    const teams = await getTeamData(recentSeason);
                    if (teams) {
                        // Try to match by team_name first, then by manager name
                        let managerTeam = teams.find(t => t.team_name === recentSeasonData.team_name);
                        
                        // If not found by team name, try matching by manager name
                        if (!managerTeam) {
                            managerTeam = teams.find(t => {
                                const teamManager = normalizeManagerName(t.manager, recentSeason, t.team_name, t.team_key);
                                return teamManager === manager.manager_name;
                            });
                        }
                        
                        if (managerTeam) {
                            managerLogos[manager.manager_name] = fixTeamLogo(managerTeam.team_logo);
                        }
                    }
                }

                // Determine which managers are currently active
                const currentStandingsResponse = await fetch('data/current_season/standings.json');
                let currentManagers = [];
                if (currentStandingsResponse.ok) {
                    const currentStandings = await currentStandingsResponse.json();
                    const normalizedStandings = normalizeStandingsData(currentStandings, 2026);
                    currentManagers = normalizedStandings.map(team => team.manager);
                }
                
                // Find the most recent champion (manager who won the most recent completed season)
                let mostRecentChampion = null;
                const completedSeasons = [2025, 2024, 2023, 2022, 2021, 2020, 2019]; // Most recent first
                for (const year of completedSeasons) {
                    for (const manager of allManagersData) {
                        const seasonData = manager.season_history.find(s => s.year === year && s.rank === 1);
                        if (seasonData) {
                            mostRecentChampion = manager.manager_name;
                            break;
                        }
                    }
                    if (mostRecentChampion) break;
                }

                // Sort by win percentage (best first)
                allManagersData.sort((a, b) => b.win_pct - a.win_pct);

                allManagersData.forEach(manager => {
                    const isActive = currentManagers.includes(manager.manager_name);
                    const card = document.createElement('div');
                    card.className = isActive ? 'manager-card' : 'manager-card inactive';
                    card.onclick = () => showManagerDetail(manager.manager_name);

                    // Get last season played
                    const lastSeason = Math.max(...manager.season_history.map(s => s.year));

                    // Get logo if available, add ring badge if most recent champion
                    const isCurrentChampion = manager.manager_name === mostRecentChampion;
                    let logo = '';
                    if (managerLogos[manager.manager_name]) {
                        logo = `<div class="manager-logo-wrapper">
                            <img src="${managerLogos[manager.manager_name]}" class="manager-logo" alt="${manager.manager_name}">
                            ${isCurrentChampion ? '<img src="champion_ring.png" class="manager-ring-badge" alt="Current Champion">' : ''}
                        </div>`;
                    }

                    // Build awards display
                    const awards = managerAwards[manager.manager_name] || {};
                    let awardsHTML = '';

                    const awardsList = [];
                    if (awards.championships) awardsList.push({ type: 'image', src: 'champion_ring.png', count: awards.championships, alt: 'Championship' });
                    if (awards.regularSeason) awardsList.push({ type: 'image', src: 'data/awards/reg_season_champion.png', count: awards.regularSeason, alt: 'Regular Season Champion' });
                    if (awards.scoringChamp) awardsList.push({ type: 'image', src: 'data/awards/scoring_champion.png', count: awards.scoringChamp, alt: 'Scoring Champion' });
                    if (awards.troutAward) awardsList.push({ type: 'image', src: 'data/awards/hitter.png', count: awards.troutAward, alt: 'Mike Trout Award' });
                    if (awards.degromAward) awardsList.push({ type: 'image', src: 'data/awards/pitcher.png', count: awards.degromAward, alt: 'Jacob deGrom Award' });
                    if (awards.diamondAward) awardsList.push({ type: 'image', src: 'data/awards/diamond.png', count: awards.diamondAward, alt: 'Diamond in the Rough' });
                    if (awards.garbage) awardsList.push({ type: 'image', src: 'data/awards/garbage.png', count: awards.garbage, alt: 'Garbage Award' });
                    if (awards.clown) awardsList.push({ type: 'image', src: 'data/awards/clown.png', count: awards.clown, alt: 'Clown Award' });
                    if (awards.bustAward) awardsList.push({ type: 'image', src: 'data/awards/bust.png', count: awards.bustAward, alt: 'Bust of the Year' });

                    if (awardsList.length > 0) {
                        awardsHTML = '<div class="awards-row">';
                        awardsList.forEach(award => {
                            awardsHTML += '<div class="award-badge">';
                            if (award.type === 'image') {
                                awardsHTML += `<img src="${award.src}" alt="${award.alt}" class="award-image">`;
                            } else {
                                awardsHTML += award.emoji;
                            }
                            if (award.count > 1) {
                                awardsHTML += `<span class="award-count">x${award.count}</span>`;
                            }
                            awardsHTML += '</div>';
                        });
                        awardsHTML += '</div>';
                    }

                    card.innerHTML = `
                        <h3>${logo}${manager.manager_name}</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                            ${!isActive ? '<div class="badge">Inactive</div>' : '<div class="badge">Active</div>'}
                            ${awardsHTML}
                        </div>
                        <div class="stat"><strong>Year Joined:</strong> ${manager.first_season}</div>
                        <div class="stat"><strong>Years in League:</strong> ${manager.seasons_played}</div>
                        ${!isActive ? `<div class="stat"><strong>Last Season:</strong> ${lastSeason}</div>` : ''}
                        <div class="stat"><strong>All-Time Record:</strong> ${manager.total_wins}-${manager.total_losses}-${manager.total_ties} (${(manager.win_pct * 100).toFixed(1)}%)</div>
                        <div class="stat"><strong>Championships:</strong> ${manager.championships}</div>
                        <div class="stat"><strong>Runner-ups:</strong> ${manager.runner_ups}</div>
                        <div class="stat"><strong>Playoff Apps:</strong> ${manager.playoff_appearances}</div>
                        <div class="stat"><strong>Avg Finish:</strong> ${manager.avg_finish.toFixed(1)}</div>
                    `;
                    gridEl.appendChild(card);
                });

                loadingEl.style.display = 'none';

                // Load and render win percentage chart
                await loadWinPctChart(allManagersData, managerLogos);

            } catch (error) {
                console.error('Error loading manager profiles:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading manager profiles: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        // ===== WIN PERCENTAGE OVER TIME CHART =====
        async function loadWinPctChart(managers, managerLogos) {
            const chartContainer = document.getElementById('winpct-chart-container');
            const chartEl = document.getElementById('winpct-chart');

            try {
                // Load all scores for all seasons (historical + current)
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026];
                const allScoresData = [];
                const seasonStartWeeks = {}; // Track week index where each season starts

                let globalWeekIndex = 0;

                for (const year of seasons) {
                    try {
                        let response;
                        let standingsResponse;
                        
                        if (year === 2026) {
                            // Current season - load from current_season folder
                            response = await fetch('data/current_season/all_scores.json');
                            standingsResponse = await fetch('data/current_season/standings.json');
                        } else {
                            // Historical seasons
                            response = await fetch(`data/historical/${year}/all_scores.json`);
                            standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                        }

                        if (response.ok) {
                            const scores = await response.json();
                            
                            // Skip if no actual games played (all scores are 0)
                            const hasGames = scores.some(s => (s.team_score || s.points || 0) > 0);
                            if (!hasGames && year === 2026) {
                                console.log('Skipping 2026 - no games played yet');
                                continue;
                            }

                            let standings = [];
                            if (standingsResponse.ok) {
                                standings = await standingsResponse.json();
                                standings = normalizeStandingsData(standings, year);
                            }

                            // Create team_key to manager mapping
                            const teamToManager = {};
                            standings.forEach(team => {
                                teamToManager[team.team_key] = team.manager;
                            });

                            // Get unique weeks in this season
                            const weeksInSeason = [...new Set(scores.map(s => s.week))].sort((a, b) => a - b);

                            // Mark season start
                            seasonStartWeeks[year] = globalWeekIndex;

                            // Add scores with global week index
                            weeksInSeason.forEach((week, weekIdx) => {
                                const weekScores = scores.filter(s => s.week === week);
                                weekScores.forEach(score => {
                                    const manager = teamToManager[score.team_key];
                                    // Handle different score field names
                                    const teamScore = score.team_score || score.points || 0;
                                    const oppScore = score.opponent_score || score.opponent_points || 0;
                                    
                                    if (manager && teamScore > 0) {
                                        allScoresData.push({
                                            manager: manager,
                                            year: year,
                                            week: week,
                                            globalWeek: globalWeekIndex + weekIdx,
                                            score: teamScore,
                                            opponentScore: oppScore,
                                            isWin: teamScore > oppScore,
                                            isLoss: teamScore < oppScore
                                        });
                                    }
                                });
                            });

                            globalWeekIndex += weeksInSeason.length;
                        }
                    } catch (e) {
                        console.log(`Could not load ${year} scores for chart`);
                    }
                }

                if (allScoresData.length === 0) {
                    chartContainer.style.display = 'none';
                    return;
                }

                // Process data for chart
                const chartData = processWinPctData(allScoresData, managers, managerLogos, seasonStartWeeks);

                chartContainer.style.display = 'block';

                requestAnimationFrame(() => {
                    renderWinPctChart(chartEl, chartData);
                });

            } catch (error) {
                console.error('Error loading win pct chart:', error);
                chartContainer.style.display = 'none';
            }
        }

        function processWinPctData(scoresData, managers, managerLogos, seasonStartWeeks) {
            // Group scores by manager and calculate cumulative stats
            const managerData = {};

            // Sort by globalWeek
            scoresData.sort((a, b) => a.globalWeek - b.globalWeek);

            // Get all unique global weeks
            const allWeeks = [...new Set(scoresData.map(s => s.globalWeek))].sort((a, b) => a - b);

            // Build week labels (with year markers)
            const weekLabels = [];
            let currentYear = null;
            allWeeks.forEach(globalWeek => {
                const weekData = scoresData.find(s => s.globalWeek === globalWeek);
                if (weekData) {
                    if (weekData.year !== currentYear) {
                        currentYear = weekData.year;
                        weekLabels.push({ globalWeek, label: `${weekData.year}`, isSeasonStart: true, year: weekData.year, week: weekData.week });
                    } else {
                        weekLabels.push({ globalWeek, label: `W${weekData.week}`, isSeasonStart: false, year: weekData.year, week: weekData.week });
                    }
                }
            });

            // Process each score
            scoresData.forEach(score => {
                if (!managerData[score.manager]) {
                    managerData[score.manager] = {
                        manager: score.manager,
                        logo: managerLogos[score.manager] || '',
                        wins: 0,
                        losses: 0,
                        data: [],
                        lastGlobalWeek: 0
                    };
                }

                const md = managerData[score.manager];
                if (score.isWin) md.wins++;
                if (score.isLoss) md.losses++;

                // Calculate Net Wins (Distance from .500)
                // Win = +1, Loss = -1, Tie = 0
                const netWins = md.wins - md.losses;

                md.data.push({
                    globalWeek: score.globalWeek,
                    netWins: netWins, // CHANGED: Store net wins instead of win %
                    wins: md.wins,
                    losses: md.losses,
                    year: score.year,
                    week: score.week
                });

                md.lastGlobalWeek = Math.max(md.lastGlobalWeek, score.globalWeek);
            });

            // Convert to array and sort by final net wins
            const managerArray = Object.values(managerData);
            managerArray.sort((a, b) => {
                const aFinal = a.data.length > 0 ? a.data[a.data.length - 1].netWins : 0;
                const bFinal = b.data.length > 0 ? b.data[b.data.length - 1].netWins : 0;
                return bFinal - aFinal;
            });

            return {
                managers: managerArray,
                weeks: allWeeks,
                weekLabels: weekLabels,
                seasonStartWeeks: seasonStartWeeks,
                maxWeek: Math.max(...allWeeks)
            };
        }

        function renderWinPctChart(container, chartData) {
            container.innerHTML = '';

            // 1. Ensure container is positioned relative so tooltip works correctly
            container.style.position = 'relative';

            const { managers, weeks, weekLabels, seasonStartWeeks, maxWeek } = chartData;

            if (managers.length === 0 || weeks.length === 0) return;

            const isMobile = window.innerWidth <= 768;

            // Chart dimensions
            const containerWidth = container.clientWidth || 900;
            const minChartWidth = isMobile ? Math.max(weeks.length * 20, 600) : Math.max(weeks.length * 12, 800);

            const margin = { top: 40, right: 80, bottom: 80, left: 60 };
            const width = Math.max(minChartWidth, containerWidth - margin.left - margin.right);
            const height = 450;

            const minWeek = Math.min(...weeks);

            // Determine Y-axis domain (Min/Max Net Wins)
            let maxNet = 0;
            let minNet = 0;

            managers.forEach(m => {
                m.data.forEach(d => {
                    if (d.netWins > maxNet) maxNet = d.netWins;
                    if (d.netWins < minNet) minNet = d.netWins;
                });
            });

            // Add padding to Y axis
            maxNet = Math.ceil(Math.max(maxNet, 5) / 5) * 5 + 5;
            minNet = Math.floor(Math.min(minNet, -5) / 5) * 5 - 5;
            const yRange = maxNet - minNet;

            // Scale functions
            const xScale = (globalWeek) => margin.left + ((globalWeek - minWeek) / (maxWeek - minWeek || 1)) * width;
            const yScale = (val) => margin.top + ((maxNet - val) / yRange) * (height - margin.top - margin.bottom);

            // Generate colors
            const colors = generateTeamColors(managers.length);
            const managerColorMap = {};
            managers.forEach((m, i) => {
                managerColorMap[m.manager] = colors[i];
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            svg.setAttribute('class', 'chart-svg winpct-chart');
            svg.style.display = 'block';

            // --- LAYERS SETUP ---
            // 1. Grid Lines Layer (bottom)
            const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(gridLayer);

            // 2. Data/Chart Layer (middle)
            const chartLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(chartLayer);

            // 3. Y-Axis Layer (top - sticky)
            const yAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            yAxisGroup.setAttribute('class', 'y-axis-group');
            // Add a white background rect to the Y-axis group to obscure lines behind it when scrolling
            const yAxisBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            yAxisBg.setAttribute('x', 0);
            yAxisBg.setAttribute('y', 0);
            yAxisBg.setAttribute('width', margin.left);
            yAxisBg.setAttribute('height', height);
            yAxisBg.setAttribute('fill', 'white');
            yAxisGroup.appendChild(yAxisBg);

            // Add a vertical divider line at the edge of the Y-axis
            const yAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxisLine.setAttribute('x1', margin.left);
            yAxisLine.setAttribute('y1', margin.top);
            yAxisLine.setAttribute('x2', margin.left);
            yAxisLine.setAttribute('y2', height - margin.bottom);
            yAxisLine.setAttribute('stroke', '#ccc');
            yAxisLine.setAttribute('stroke-width', '1');
            yAxisGroup.appendChild(yAxisLine);

            svg.appendChild(yAxisGroup);

            // --- SCROLL HANDLER FOR STICKY AXIS ---
            container.addEventListener('scroll', () => {
                yAxisGroup.setAttribute('transform', `translate(${container.scrollLeft}, 0)`);
            });

            // Click background to deselect
            svg.addEventListener('click', (e) => {
                if (e.target === svg) {
                    selectedManager = null;
                    resetHighlights();
                }
            });

            // Draw horizontal grid lines (on Grid Layer) and Labels (on Y-Axis Layer)
            for (let val = minNet; val <= maxNet; val += 5) {
                const y = yScale(val);

                // Grid Line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);

                if (val === 0) {
                    line.setAttribute('stroke', '#000');
                    line.setAttribute('stroke-width', '2');
                } else {
                    line.setAttribute('stroke', '#e0e0e0');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '3,3');
                }
                gridLayer.appendChild(line);

                // Axis Label (Sticky)
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '11px');
                label.setAttribute('fill', val === 0 ? '#000' : '#666');
                label.setAttribute('font-weight', val === 0 ? 'bold' : 'normal');
                const labelText = val > 0 ? `+${val}` : `${val}`;
                label.textContent = labelText;
                yAxisGroup.appendChild(label); // Append to sticky group
            }

            // Draw Y-axis title (Sticky)
            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('x', 15);
            yTitle.setAttribute('y', height / 2);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('font-size', '12px');
            yTitle.setAttribute('fill', '#666');
            yTitle.setAttribute('transform', `rotate(-90, 15, ${height / 2})`);
            yTitle.textContent = 'Games Above .500';
            yAxisGroup.appendChild(yTitle); // Append to sticky group

            // Draw vertical season separator lines
            Object.entries(seasonStartWeeks).forEach(([year, startWeek]) => {
                if (startWeek > minWeek) {
                    const x = xScale(startWeek);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', margin.top);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', height - margin.bottom);
                    line.setAttribute('stroke', '#0048ba');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('stroke-dasharray', '5,3');
                    gridLayer.appendChild(line);
                }
            });

            // Draw X-axis labels
            weekLabels.forEach((wl, idx) => {
                const showLabel = wl.isSeasonStart || idx % (isMobile ? 8 : 4) === 0;
                if (!showLabel && !wl.isSeasonStart) return;

                const x = xScale(wl.globalWeek);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - margin.bottom + 15);
                label.setAttribute('text-anchor', 'start');
                label.setAttribute('font-size', wl.isSeasonStart ? '12px' : '10px');
                label.setAttribute('font-weight', wl.isSeasonStart ? 'bold' : 'normal');
                label.setAttribute('fill', wl.isSeasonStart ? '#0048ba' : '#666');
                label.setAttribute('transform', `rotate(45, ${x}, ${height - margin.bottom + 15})`);
                label.textContent = wl.isSeasonStart ? wl.year : wl.label;
                gridLayer.appendChild(label); // X-axis moves with scroll, so put on gridLayer
            });

            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.style.display = 'none';
            container.appendChild(tooltip);

            // --- STATE MANAGEMENT ---
            let selectedManager = null; // Track locked line

            // Helper to apply visual styles
            const applyHighlight = (managerName) => {
                document.querySelectorAll('.winpct-chart .chart-line').forEach(line => {
                    if (line.getAttribute('data-manager') === managerName) {
                        line.classList.add('highlighted');
                        line.classList.remove('faded');
                        // Move to end of chartLayer to be on top of others
                        if (line.parentNode === chartLayer) {
                            chartLayer.appendChild(line);
                        }
                    } else {
                        line.classList.add('faded');
                        line.classList.remove('highlighted');
                    }
                });
            };

            const resetHighlights = () => {
                document.querySelectorAll('.winpct-chart .chart-line').forEach(line => {
                    line.classList.remove('highlighted', 'faded');
                });
            };

            // Draw lines for each manager
            const lineGroups = [];

            managers.forEach((manager, idx) => {
                if (manager.data.length < 2) return;

                const color = managerColorMap[manager.manager];
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'chart-line');
                group.setAttribute('data-manager', manager.manager);

                // Build path
                let pathD = '';
                manager.data.forEach((point, i) => {
                    const x = xScale(point.globalWeek);
                    const y = yScale(point.netWins);
                    pathD += (i === 0 ? 'M' : 'L') + `${x},${y} `;
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD.trim());
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', '2.5');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('stroke-linecap', 'round');
                group.appendChild(path);

                // Invisible wider path for hover detection
                const hoverPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hoverPath.setAttribute('d', pathD.trim());
                hoverPath.setAttribute('fill', 'none');
                hoverPath.setAttribute('stroke', 'transparent');
                hoverPath.setAttribute('stroke-width', '15');
                hoverPath.style.cursor = 'pointer';
                group.appendChild(hoverPath);

                // Logo/End marker
                const lastPoint = manager.data[manager.data.length - 1];
                const logoX = xScale(lastPoint.globalWeek);
                const logoY = yScale(lastPoint.netWins);
                const logoRadius = 14;

                if (manager.logo) {
                    const clipId = `winpct-clip-${idx}`;
                    const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                    clipPath.setAttribute('id', clipId);
                    const clipCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    clipCircle.setAttribute('cx', logoX);
                    clipCircle.setAttribute('cy', logoY);
                    clipCircle.setAttribute('r', logoRadius);
                    clipPath.appendChild(clipCircle);
                    svg.appendChild(clipPath); // Defines must be in SVG, usually ok anywhere

                    const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    bgCircle.setAttribute('cx', logoX);
                    bgCircle.setAttribute('cy', logoY);
                    bgCircle.setAttribute('r', logoRadius + 2);
                    bgCircle.setAttribute('fill', 'white');
                    bgCircle.setAttribute('stroke', color);
                    bgCircle.setAttribute('stroke-width', '2');
                    group.appendChild(bgCircle);

                    const logoImg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    logoImg.setAttribute('x', logoX - logoRadius);
                    logoImg.setAttribute('y', logoY - logoRadius);
                    logoImg.setAttribute('width', logoRadius * 2);
                    logoImg.setAttribute('height', logoRadius * 2);
                    logoImg.setAttribute('href', manager.logo);
                    logoImg.setAttribute('clip-path', `url(#${clipId})`);
                    logoImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    group.appendChild(logoImg);
                } else {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', logoX);
                    circle.setAttribute('cy', logoY);
                    circle.setAttribute('r', logoRadius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', 'white');
                    circle.setAttribute('stroke-width', '2');
                    group.appendChild(circle);

                    const initial = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    initial.setAttribute('x', logoX);
                    initial.setAttribute('y', logoY + 5);
                    initial.setAttribute('text-anchor', 'middle');
                    initial.setAttribute('fill', 'white');
                    initial.setAttribute('font-size', '12px');
                    initial.setAttribute('font-weight', 'bold');
                    initial.textContent = manager.manager.charAt(0);
                    group.appendChild(initial);
                }

                const finalNetWins = lastPoint.netWins;

                // --- EVENTS ---

                // Click to toggle Highlight
                group.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent SVG background click
                    if (selectedManager === manager.manager) {
                        // Deselect if clicking the same one
                        selectedManager = null;
                        resetHighlights();
                    } else {
                        // Select new one
                        selectedManager = manager.manager;
                        applyHighlight(manager.manager);
                    }
                });

                // Hover Effects
                group.addEventListener('mouseenter', (e) => {
                    // Always highlight on hover, even if something else is selected (transient view)
                    applyHighlight(manager.manager);

                    // Show tooltip with Logo
                    const sign = finalNetWins > 0 ? '+' : '';

                    // Construct Logo HTML
                    const logoHtml = manager.logo ?
                        `<img src="${manager.logo}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 2px solid ${color};">` :
                        `<div style="width: 40px; height: 40px; border-radius: 50%; background: ${color}; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 18px; border: 2px solid white;">${manager.manager.charAt(0)}</div>`;

                    tooltip.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            ${logoHtml}
                            <div>
                                <div style="font-weight: bold; font-size: 1.1em;">${manager.manager}</div>
                                <div style="margin-top: 2px; color: #ccc;">Record: ${manager.wins}-${manager.losses}</div>
                                <div style="margin-top: 2px; color: ${finalNetWins >= 0 ? '#4cd137' : '#ff4757'}; font-weight: bold;">
                                    ${sign}${finalNetWins} games
                                </div>
                            </div>
                        </div>
                    `;
                    tooltip.style.display = 'block';
                });

                // Tooltip follow mouse (FIXED for scrolling)
                group.addEventListener('mousemove', (e) => {
                    const rect = container.getBoundingClientRect();
                    const scrollLeft = container.scrollLeft;

                    tooltip.style.left = (e.clientX - rect.left + scrollLeft + 15) + 'px';
                    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
                });

                // Mouse Leave
                group.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';

                    // If a manager is selected, revert to highlighting them
                    if (selectedManager) {
                        applyHighlight(selectedManager);
                    } else {
                        // Otherwise reset to all visible
                        resetHighlights();
                    }
                });

                lineGroups.push(group);
            });

            // Add lines to Chart Layer
            lineGroups.reverse().forEach(g => chartLayer.appendChild(g));

            container.appendChild(svg);
        }

        // ===== SHOW MANAGER DETAIL MODAL =====
        // Generate hat filename from manager name
        function getManagerHatFilename(managerName) {
            // Normalize: lowercase, remove spaces, handle names like "Logan S" -> "logans"
            const normalized = managerName.toLowerCase().replace(/\s+/g, '');
            return `hat_${normalized}.png`;
        }

        async function showManagerDetail(managerName) {
            const manager = allManagersData.find(m => m.manager_name === managerName);
            if (!manager) return;

            const modal = document.getElementById('manager-modal');
            const modalBody = document.getElementById('modal-body');

            // Load team logos for each season using cached data
            const seasonLogos = {};
            let currentManagerLogo = '';
            for (const season of manager.season_history) {
                const teams = await getTeamData(season.year);
                if (teams) {
                    const managerTeam = teams.find(t => t.team_name === season.team_name);
                    if (managerTeam) {
                        seasonLogos[season.year] = fixTeamLogo(managerTeam.team_logo);
                    }
                }
            }
            // Get most recent logo as current manager logo
            const mostRecentSeason = Math.max(...Object.keys(seasonLogos).map(Number));
            currentManagerLogo = seasonLogos[mostRecentSeason] || '';
            
            // Build a map of all manager logos for h2h display
            const allManagerLogos = {};
            for (const mgr of allManagersData) {
                const recentSeason = Math.max(...mgr.season_history.map(s => s.year));
                const teams = await getTeamData(recentSeason);
                if (teams) {
                    const mgrSeason = mgr.season_history.find(s => s.year === recentSeason);
                    if (mgrSeason) {
                        const mgrTeam = teams.find(t => t.team_name === mgrSeason.team_name);
                        if (mgrTeam) {
                            allManagerLogos[mgr.manager_name] = fixTeamLogo(mgrTeam.team_logo);
                        }
                    }
                }
            }
            // Store globally for sort function
            window.currentManagerLogos = allManagerLogos;

            // Build season timeline with draft grades
            const seasonHistory = manager.season_history.sort((a, b) => b.year - a.year);
            const managerGrades = managerDraftGrades[manager.manager_name] || { grades: [] };
            
            let timelineHTML = seasonHistory.map(season => {
                let rankClass = '';
                let rankText = `#${season.rank}`;

                if (season.rank === 1) {
                    rankClass = 'champion';
                    rankText = '<img src="champion_ring.png" alt="Champion" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 4px;">Champion';
                } else if (season.rank === 2) {
                    rankClass = 'runner-up';
                    rankText = 'Runner-up';
                }

                const logo = seasonLogos[season.year] ? `<img src="${seasonLogos[season.year]}" class="timeline-logo" alt="${season.team_name}">` : '';
                
                // Get draft grade for this season
                const seasonGrade = managerGrades.grades.find(g => g.year === season.year);
                let draftGradeHTML = '';
                if (seasonGrade) {
                    const gradeColor = getGradeColor(seasonGrade.grade);
                    const bgColor = getGradeBackgroundColor(seasonGrade.grade);
                    const scoreSign = seasonGrade.score >= 0 ? '+' : '';
                    draftGradeHTML = `
                        <span class="draft-grade-badge" style="background: ${bgColor}; color: ${gradeColor}; border: 1px solid ${gradeColor};" 
                              title="Draft: ${seasonGrade.actual.toFixed(0)} pts vs ${seasonGrade.expected.toFixed(0)} expected (${scoreSign}${seasonGrade.score.toFixed(1)}%)">
                            Draft: ${seasonGrade.grade}
                        </span>
                    `;
                }

                return `
                    <div class="timeline-item">
                        <div class="year">${season.year}</div>
                        <div class="details">
                            <span class="rank ${rankClass}">${rankText}</span>
                            ${draftGradeHTML}
                            <span>${season.wins}-${season.losses} | ${season.points_for.toLocaleString()} pts</span>
                            <div style="margin-top: 0.25rem; color: #666; font-size: 0.9rem;">
                                Team: ${season.team_name}
                            </div>
                        </div>
                        ${logo}
                    </div>
                `;
            }).join('');

            // Calculate head-to-head records
            const h2hRecords = await calculateHeadToHeadRecords(managerName);
            let h2hHTML = '';

            if (h2hRecords.length > 0) {
                h2hHTML = `
                    <div class="timeline">
                        <h3>Head-to-Head Records</h3>
                        <table class="matchup-table" id="h2h-table">
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortH2HTable(0, 'string')">Opponent</th>
                                    <th class="sortable" onclick="sortH2HTable(1, 'record')">Record</th>
                                    <th class="sortable" onclick="sortH2HTable(2, 'number')">Win %</th>
                                    <th class="sortable" onclick="sortH2HTable(3, 'number')">Avg Points For</th>
                                    <th class="sortable" onclick="sortH2HTable(4, 'number')">Avg Points Against</th>
                                </tr>
                            </thead>
                            <tbody id="h2h-body">
                                ${h2hRecords.map(record => {
                                    const oppLogo = allManagerLogos[record.opponent] || '';
                                    const logoHtml = oppLogo ? `<img src="${oppLogo}" style="width: 24px; height: 24px; border-radius: 50%; margin-right: 8px; vertical-align: middle; object-fit: cover;">` : '';
                                    return `
                                    <tr>
                                        <td>${logoHtml}${record.opponent}</td>
                                        <td>${record.wins}-${record.losses}</td>
                                        <td>${(record.win_pct * 100).toFixed(1)}%</td>
                                        <td>${record.avg_points_for.toFixed(1)}</td>
                                        <td>${record.avg_points_against.toFixed(1)}</td>
                                    </tr>
                                `}).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }

            // Build draft grade section - compare to other managers using draft points
            let draftGradeSectionHTML = '';
            if (managerGrades.adjustedDraftPoints !== undefined) {
                // Get all managers' adjusted draft points and rank them
                const allManagerScores = Object.entries(managerDraftGrades)
                    .filter(([name, data]) => data.adjustedDraftPoints !== undefined && data.grades.length > 0)
                    .map(([name, data]) => ({ 
                        name, 
                        adjustedPoints: data.adjustedDraftPoints,
                        avgPoints: data.avgDraftPoints,
                        seasons: data.seasons
                    }))
                    .sort((a, b) => b.adjustedPoints - a.adjustedPoints);
                
                // Find this manager's rank
                const managerRank = allManagerScores.findIndex(m => m.name === manager.manager_name) + 1;
                const totalManagers = allManagerScores.length;
                
                // Convert adjusted points back to a grade
                const overallGrade = pointsToGrade(managerGrades.adjustedDraftPoints);
                
                const avgGradeColor = getGradeColor(overallGrade);
                const avgBgColor = getGradeBackgroundColor(overallGrade);
                draftGradeSectionHTML = `
                    <div class="draft-grade-section">
                        <div class="draft-grade-overall" style="background: ${avgBgColor}; border-color: ${avgGradeColor};">
                            <div class="draft-grade-letter" style="color: ${avgGradeColor};">${overallGrade}</div>
                            <div class="draft-grade-label">Draft Grade</div>
                            <div class="draft-grade-score" style="color: ${avgGradeColor};">Rank #${managerRank} of ${totalManagers}</div>
                        </div>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div class="modal-stats">
                    <div class="stat-box">
                        <div class="value">${manager.total_wins}-${manager.total_losses}-${manager.total_ties}</div>
                        <div class="label">All-Time Record</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${(manager.win_pct * 100).toFixed(1)}%</div>
                        <div class="label">Win Percentage</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.championships}</div>
                        <div class="label">Championships</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.avg_finish.toFixed(1)}</div>
                        <div class="label">Avg Finish</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.playoff_appearances}</div>
                        <div class="label">Playoff Apps</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.total_points_for.toLocaleString()}</div>
                        <div class="label">Career Points</div>
                    </div>
                </div>
                
                ${draftGradeSectionHTML}
                
                <div class="timeline">
                    <h3>Season-by-Season Timeline</h3>
                    ${timelineHTML}
                </div>
                
                ${h2hHTML}
            `;

            // Set the header separately with awards emojis
            const modalHeaderSection = document.getElementById('modal-header-section');

            // Build awards display for modal header (same format as cards)
            const awards = managerAwardsData[manager.manager_name] || {};
            let modalAwardsHTML = '';

            const awardsList = [];
            if (awards.championships) awardsList.push({ type: 'image', src: 'champion_ring.png', count: awards.championships, alt: 'Championship', years: awards.championshipYears || [] });
            if (awards.regularSeason) awardsList.push({ type: 'image', src: 'data/awards/reg_season_champion.png', count: awards.regularSeason, alt: 'Regular Season Champion', years: awards.regularSeasonYears || [] });
            if (awards.scoringChamp) awardsList.push({ type: 'image', src: 'data/awards/scoring_champion.png', count: awards.scoringChamp, alt: 'Scoring Champion', years: awards.scoringChampYears || [] });
            if (awards.troutAward) awardsList.push({ type: 'image', src: 'data/awards/hitter.png', count: awards.troutAward, alt: 'Mike Trout Award', years: awards.troutAwardYears || [] });
            if (awards.degromAward) awardsList.push({ type: 'image', src: 'data/awards/pitcher.png', count: awards.degromAward, alt: 'Jacob deGrom Award', years: awards.degromAwardYears || [] });
            if (awards.diamondAward) awardsList.push({ type: 'image', src: 'data/awards/diamond.png', count: awards.diamondAward, alt: 'Diamond in the Rough', years: awards.diamondAwardYears || [] });
            if (awards.garbage) awardsList.push({ type: 'image', src: 'data/awards/garbage.png', count: awards.garbage, alt: 'Garbage Award', years: awards.garbageYears || [] });
            if (awards.clown) awardsList.push({ type: 'image', src: 'data/awards/clown.png', count: awards.clown, alt: 'Clown Award', years: awards.clownYears || [] });
            if (awards.bustAward) awardsList.push({ type: 'image', src: 'data/awards/bust.png', count: awards.bustAward, alt: 'Bust of the Year', years: awards.bustAwardYears || [] });

            if (awardsList.length > 0) {
                modalAwardsHTML = '<div class="awards-row">';
                awardsList.forEach(award => {
                    const yearsText = award.years.length > 0 ? award.years.sort().join(', ') : '';
                    const tooltipText = `${award.alt}${yearsText ? ': ' + yearsText : ''}`;
                    modalAwardsHTML += `<div class="award-badge" data-tooltip="${tooltipText}">`;
                    if (award.type === 'image') {
                        modalAwardsHTML += `<img src="${award.src}" alt="${award.alt}" class="award-image">`;
                    } else {
                        modalAwardsHTML += award.emoji;
                    }
                    if (award.count > 1) {
                        modalAwardsHTML += `<span class="award-count">x${award.count}</span>`;
                    }
                    modalAwardsHTML += '</div>';
                });
                modalAwardsHTML += '</div>';
            }

            // Determine hat image path (dynamically generated from manager name)
            const hatFilename = getManagerHatFilename(manager.manager_name);
            const hatUrl = `data/hats/${hatFilename}`;
            
            // Always try hat first, fall back to team logo if hat doesn't exist
            let profileImageHTML = '';
            if (currentManagerLogo) {
                profileImageHTML = `<img src="${hatUrl}" style="width: 80px; height: 80px; object-fit: contain;" onerror="this.src='${currentManagerLogo}'; this.style.borderRadius='50%'; this.style.width='50px'; this.style.height='50px'; this.style.border='3px solid #1e3c72'; this.style.objectFit='cover';">`;
            } else {
                profileImageHTML = `<img src="${hatUrl}" style="width: 80px; height: 80px; object-fit: contain;" onerror="this.style.display='none';">`;
            }

            modalHeaderSection.innerHTML = `
                <div class="modal-header">
                    <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                        ${profileImageHTML}
                        <h2 style="margin: 0;">${manager.manager_name}</h2>
                        ${modalAwardsHTML}
                    </div>
                    <p style="color: #666; margin-top: 0.5rem;">Joined ${manager.first_season} | ${manager.seasons_played} seasons</p>
                </div>
            `;

            // Store h2h data for sorting
            window.currentH2HData = h2hRecords;
            window.currentSortColumn = null;
            window.currentSortDirection = 'desc';

            modal.classList.add('active');
        }

        // ===== SORT HEAD-TO-HEAD TABLE =====
        function sortH2HTable(columnIndex, dataType) {
            const tbody = document.getElementById('h2h-body');
            const headers = document.querySelectorAll('#h2h-table th');

            if (!window.currentH2HData || window.currentH2HData.length === 0) return;

            // Toggle sort direction if clicking same column
            if (window.currentSortColumn === columnIndex) {
                window.currentSortDirection = window.currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                window.currentSortColumn = columnIndex;
                window.currentSortDirection = 'desc'; // Default to descending
            }

            // Update header classes
            headers.forEach((header, index) => {
                header.classList.remove('sorted-asc', 'sorted-desc');
                if (index === columnIndex) {
                    header.classList.add(window.currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });

            // Sort the data
            const sortedData = [...window.currentH2HData].sort((a, b) => {
                let valueA, valueB;

                switch (columnIndex) {
                    case 0: // Opponent
                        valueA = a.opponent.toLowerCase();
                        valueB = b.opponent.toLowerCase();
                        break;
                    case 1: // Record (by total wins)
                        valueA = a.wins;
                        valueB = b.wins;
                        break;
                    case 2: // Win %
                        valueA = a.win_pct;
                        valueB = b.win_pct;
                        break;
                    case 3: // Avg Points For
                        valueA = a.avg_points_for;
                        valueB = b.avg_points_for;
                        break;
                    case 4: // Avg Points Against
                        valueA = a.avg_points_against;
                        valueB = b.avg_points_against;
                        break;
                }

                if (window.currentSortDirection === 'asc') {
                    return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
                } else {
                    return valueA < valueB ? 1 : valueA > valueB ? -1 : 0;
                }
            });

            // Update table
            const logos = window.currentManagerLogos || {};
            tbody.innerHTML = sortedData.map(record => {
                const oppLogo = logos[record.opponent] || '';
                const logoHtml = oppLogo ? `<img src="${oppLogo}" style="width: 24px; height: 24px; border-radius: 50%; margin-right: 8px; vertical-align: middle; object-fit: cover;">` : '';
                return `
                <tr>
                    <td>${logoHtml}${record.opponent}</td>
                    <td>${record.wins}-${record.losses}</td>
                    <td>${(record.win_pct * 100).toFixed(1)}%</td>
                    <td>${record.avg_points_for.toFixed(1)}</td>
                    <td>${record.avg_points_against.toFixed(1)}</td>
                </tr>
            `}).join('');
        }

        // ===== CALCULATE HEAD-TO-HEAD RECORDS =====
        async function calculateHeadToHeadRecords(managerName) {
            try {
                // Get all available seasons and load their scores
                const h2hMap = {};

                const manager = allManagersData.find(m => m.manager_name === managerName);
                if (!manager) return [];

                for (const season of manager.season_history.map(h => h.year)) {
                    try {
                        let scoresResponse;
                        if (season === 2026) {
                            scoresResponse = await fetch('data/historical/2025/all_scores.json');
                        } else {
                            scoresResponse = await fetch(`data/historical/${season}/all_scores.json`);
                        }

                        if (!scoresResponse.ok) continue;

                        const scores = await scoresResponse.json();
                        let standings = season === 2026
                            ? await (await fetch('data/historical/2025/standings.json')).json()
                            : await (await fetch(`data/historical/${season}/final_standings.json`)).json();

                        // Normalize standings
                        standings = normalizeStandingsData(standings, season);

                        // Create team_key to manager mapping
                        const teamToManager = {};
                        standings.forEach(team => {
                            teamToManager[team.team_key] = team.manager;
                        });

                        // Find manager's team key
                        const managerTeam = standings.find(team => team.manager === managerName);
                        if (!managerTeam) continue;

                        // Process matchups
                        scores.forEach(matchup => {
                            if (matchup.team_key === managerTeam.team_key) {
                                const opponent = teamToManager[matchup.opponent_key];
                                if (!opponent) return;

                                if (!h2hMap[opponent]) {
                                    h2hMap[opponent] = {
                                        opponent: opponent,
                                        wins: 0,
                                        losses: 0,
                                        total_points_for: 0,
                                        total_points_against: 0,
                                        games: 0
                                    };
                                }

                                h2hMap[opponent].games++;
                                h2hMap[opponent].total_points_for += matchup.team_score;
                                h2hMap[opponent].total_points_against += matchup.opponent_score;

                                if (matchup.team_score > matchup.opponent_score) {
                                    h2hMap[opponent].wins++;
                                } else if (matchup.team_score < matchup.opponent_score) {
                                    h2hMap[opponent].losses++;
                                }
                            }
                        });
                    } catch (e) {
                        console.log(`Could not load scores for ${season}`);
                    }
                }

                // Convert to array and calculate averages
                const h2hRecords = Object.values(h2hMap).map(record => ({
                    ...record,
                    win_pct: record.wins / (record.wins + record.losses),
                    avg_points_for: record.total_points_for / record.games,
                    avg_points_against: record.total_points_against / record.games
                }));

                // Sort by win percentage
                h2hRecords.sort((a, b) => b.win_pct - a.win_pct);

                return h2hRecords;
            } catch (error) {
                console.error('Error calculating head-to-head:', error);
                return [];
            }
        }

        // ===== CLOSE MANAGER MODAL =====
        function closeManagerModal() {
            const modal = document.getElementById('manager-modal');
            modal.classList.remove('active');
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('manager-modal');
            if (event.target === modal) {
                closeManagerModal();
            }
        }

        // ===== MOBILE MENU =====
        let mobileMenuScrollPosition = 0;
        
        function toggleMobileMenu() {
            const menu = document.querySelector('.mobile-menu');
            const overlay = document.querySelector('.mobile-menu-overlay');
            const isOpen = menu.classList.contains('active');
            
            if (isOpen) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }
        
        function openMobileMenu() {
            const menu = document.querySelector('.mobile-menu');
            const overlay = document.querySelector('.mobile-menu-overlay');
            
            // Save current scroll position before locking body
            mobileMenuScrollPosition = window.pageYOffset || document.documentElement.scrollTop;
            
            menu.classList.add('active');
            overlay.classList.add('active');
            document.body.classList.add('menu-open');
            document.body.style.top = `-${mobileMenuScrollPosition}px`;
            
            // Update active state for current page
            updateMobileMenuActiveState();
        }
        
        function closeMobileMenu() {
            const menu = document.querySelector('.mobile-menu');
            const overlay = document.querySelector('.mobile-menu-overlay');
            
            menu.classList.remove('active');
            overlay.classList.remove('active');
            document.body.classList.remove('menu-open');
            document.body.style.top = '';
            
            // Restore scroll position
            window.scrollTo(0, mobileMenuScrollPosition);
        }
        
        function updateMobileMenuActiveState() {
            // Find the currently active section
            const activeSection = document.querySelector('.section.active');
            if (!activeSection) return;
            
            const sectionId = activeSection.id;
            
            // Map section IDs to menu item text
            const sectionToText = {
                'standings': 'Seasons',
                'awards': 'Awards',
                'champions': 'Hall of Champions',
                'scoring': 'Player Scoring',
                'managers': 'Manager Profiles',
                'preseason': 'Preseason Tools',
                'valuesuite': 'Value Suite',
                'sportsbook': 'Sportsbook',
                'bylaws': 'Bylaws'
            };
            
            const activeText = sectionToText[sectionId];
            
            // Update mobile menu items
            document.querySelectorAll('.mobile-menu-item').forEach(item => {
                const itemText = item.querySelector('span').textContent;
                item.classList.toggle('active', itemText === activeText);
            });
        }

        // ===== NAVIGATION =====
        async function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            // Remove active class from all desktop nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Remove active class from all mobile nav buttons
            document.querySelectorAll('.mobile-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Remove active class from all side nav items
            document.querySelectorAll('.side-nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // Show selected section
            document.getElementById(sectionId).classList.add('active');

            // Add active class to clicked button (both desktop and mobile)
            if (event && event.target) {
                event.target.closest('button')?.classList.add('active');
                event.target.closest('.side-nav-item')?.classList.add('active');
            }

            // Also update the corresponding nav buttons by section ID
            const sectionToIndex = {
                'home': 0,
                'standings': 1,
                'awards': 2,
                'champions': 3,
                'scoring': 4,
                'managers': 5,
                'preseason': 6,
                'valuesuite': 7,
                'prospects': 8,
                'sportsbook': 9,
                'bylaws': 10
            };
            const index = sectionToIndex[sectionId];
            if (index !== undefined) {
                document.querySelectorAll('.nav-btn')[index]?.classList.add('active');
                document.querySelectorAll('.mobile-nav-btn')[index]?.classList.add('active');
                document.querySelectorAll('.side-nav-item')[index]?.classList.add('active');
            }
            
            // Update mobile menu active state
            updateMobileMenuActiveState();
            
            // Show/hide bylaws sidebar based on active section
            const bylawsSidebar = document.querySelector('.bylaws-sidebar');
            if (bylawsSidebar) {
                bylawsSidebar.style.display = sectionId === 'bylaws' ? 'block' : 'none';
            }

            // Load section-specific data
            if (sectionId === 'home') {
                loadHomepageData();
            } else if (sectionId === 'awards') {
                loadAwards();
            } else if (sectionId === 'champions') {
                loadChampionData();
            } else if (sectionId === 'scoring') {
                // Load player scoring if not already loaded
                if (allPlayersData.length === 0) {
                    loadPlayerScoring();
                }
            }
            else if (sectionId === 'preseason') {
                // Initialize keeper management first, then load projections
                // This ensures keeper data is available when rendering the table
                if (!keeperConfig) {
                    await initializeKeeperManagement();
                }
                // Initialize trade management (must be after keeper management)
                await initializeTradeManagement();

                // Refresh league keepers display once after everything is loaded
                // This ensures round costs properly account for traded picks
                // Only call if keeperConfig exists (meaning initialization already happened)
                if (keeperConfig) {
                    displayLeagueKeepers();
                    // Initialize projected lineups after keeper data is ready
                    initProjectedLineups();
                }

                // Load projections if not already loaded
                if (allProjectionBatters.length === 0 && allProjectionPitchers.length === 0) {
                    loadProjections();
                } else {
                    // If projections already loaded, refresh the table to show keeper info
                    filterProjections();
                }
            }
            else if (sectionId === 'valuesuite') {
                // Initialize keeper management if not already done (needed for value analysis)
                if (!keeperConfig) {
                    await initializeKeeperManagement();
                }
                // Initialize trade management (needed for draft pick values)
                await initializeTradeManagement();
                
                // Load projections if not already loaded (needed for value calculations)
                if (allProjectionBatters.length === 0 && allProjectionPitchers.length === 0) {
                    await loadProjections();
                }
                
                // Trigger the keeper value analysis
                if (keeperConfig) {
                    displayLeagueKeepers(); // This triggers the value analysis rendering
                }
            }
            else if (sectionId === 'sportsbook') {
                // Initialize keeper management (needed for authentication)
                if (!keeperConfig) {
                    await initializeKeeperManagement();
                }
                // Initialize trade management (needed for draft pick ownership)
                await initializeTradeManagement();
                // Initialize sportsbook
                await initializeSportsbook();
            }
            else if (sectionId === 'prospects') {
                // Initialize Firebase if needed for ownership data
                if (!keeperConfig) {
                    await initializeKeeperManagement();
                }
                // Load prospects data
                initProspectsOnVisible();
            }
        }

        // ===== HALL OF CHAMPIONS =====
        let championsDataLoaded = false;
        let allChampionsData = {};
        let championLogoSelectorInitialized = false;

        // Initialize the championship logo selector with all champions
        async function initChampionshipLogoSelector() {
            if (championLogoSelectorInitialized) return;
            
            const selectorContainer = document.getElementById('championship-logo-selector');
            const seasonSelect = document.getElementById('champions-season');
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFhMWEyZSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZCI+8J+PhjwvdGV4dD48L3N2Zz4=';
            
            // Populate hidden select for state management
            if (seasonSelect.options.length === 0) {
                seasons.slice().reverse().forEach(year => {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = year === 2026 ? '2026 (Current)' : year;
                    seasonSelect.appendChild(option);
                });
            }

            // Load champion data for all seasons
            const championsInfo = [];
            
            for (const year of seasons) {
                try {
                    const isCurrentSeason = year === 2026;
                    const dataPath = isCurrentSeason ? 'data/current_season' : `data/historical/${year}`;
                    // All historical seasons now use final_standings.json
                    const standingsFile = isCurrentSeason ? 'standings.json' : 'final_standings.json';
                    
                    const standingsResponse = await fetch(`${dataPath}/${standingsFile}`);
                    if (!standingsResponse.ok) {
                        championsInfo.push({ year, champion: null, logo: placeholderLogo, teamName: 'Unknown', manager: 'Unknown' });
                        continue;
                    }
                    
                    let standings = await standingsResponse.json();
                    standings = normalizeStandingsData(standings, year);
                    const champion = standings.find(team => team.rank === 1);
                    
                    if (!champion) {
                        championsInfo.push({ year, champion: null, logo: placeholderLogo, teamName: 'Unknown', manager: 'Unknown' });
                        continue;
                    }
                    
                    // Load teams data for logo
                    const teamsResponse = await fetch(`${dataPath}/teams.json`);
                    let logo = placeholderLogo;
                    if (teamsResponse.ok) {
                        const teams = await teamsResponse.json();
                        const championTeam = teams.find(t => t.team_key === champion.team_key);
                        logo = fixTeamLogo(championTeam?.team_logo) || placeholderLogo;
                    }
                    
                    championsInfo.push({
                        year,
                        champion,
                        logo,
                        teamName: champion.team_name,
                        manager: champion.manager
                    });
                } catch (e) {
                    console.log(`Error loading ${year} champion:`, e);
                    championsInfo.push({ year, champion: null, logo: placeholderLogo, teamName: 'Unknown', manager: 'Unknown' });
                }
            }
            
            // Build the logo selector HTML
            let html = '';
            championsInfo.forEach(info => {
                const isCurrentSeason = info.year === 2026;
                const currentClass = isCurrentSeason ? 'current-season' : '';
                const ringBadge = isCurrentSeason ? '<img src="champion_ring.png" class="champion-ring-badge" alt="Current Leader">' : '';
                html += `
                    <div class="championship-logo-item ${currentClass}" data-year="${info.year}" onclick="selectChampionYear(${info.year})">
                        <div class="logo-wrapper">
                            <img src="${info.logo}" alt="${info.teamName}" onerror="this.src='${placeholderLogo}'">
                        </div>
                        ${ringBadge}
                        <div class="year-indicator">${info.year}</div>
                        <div class="logo-tooltip">
                            <div class="tooltip-year">${info.year}${isCurrentSeason ? ' ' : ''}</div>
                            <div class="tooltip-team">${info.teamName}</div>
                            <div class="tooltip-manager">${info.manager}</div>
                        </div>
                    </div>
                `;
            });
            
            selectorContainer.innerHTML = html;
            
            championLogoSelectorInitialized = true;
            
            // Select the most recent (first) season by default
            selectChampionYear(2025, false);
        }

        // Handle year selection from logo click
        function selectChampionYear(year, triggerLoad = true) {
            const seasonSelect = document.getElementById('champions-season');
            
            // Update hidden select
            seasonSelect.value = year;
            
            // Update active state on logos
            document.querySelectorAll('.championship-logo-item').forEach(item => {
                const itemYear = parseInt(item.dataset.year);
                if (itemYear === year) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            // Load champion data if requested
            if (triggerLoad) {
                loadChampionData();
            }
        }

        async function loadChampionData() {
            const loadingEl = document.getElementById('champions-loading');
            const errorEl = document.getElementById('champions-error');
            const contentEl = document.getElementById('champions-content');
            const seasonSelect = document.getElementById('champions-season');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                contentEl.style.display = 'none';

                // Initialize the logo selector if not done yet
                if (!championLogoSelectorInitialized) {
                    await initChampionshipLogoSelector();
                }

                const selectedYear = parseInt(seasonSelect.value) || 2025;
                
                // Update active logo state
                selectChampionYear(selectedYear, false);
                
                const isCurrentSeason = selectedYear === 2026;
                const dataPath = isCurrentSeason ? 'data/current_season' : `data/historical/${selectedYear}`;

                // Load standings to find champion
                // All historical seasons now use final_standings.json
                const standingsFile = isCurrentSeason ? 'standings.json' : 'final_standings.json';
                const standingsResponse = await fetch(`${dataPath}/${standingsFile}`);
                if (!standingsResponse.ok) throw new Error(`No data for ${selectedYear}`);
                let standings = await standingsResponse.json();
                standings = normalizeStandingsData(standings, selectedYear);

                // Find champion (rank 1)
                const champion = standings.find(team => team.rank === 1);
                if (!champion) throw new Error('Champion not found');

                // Load teams data for logo
                const teamsResponse = await fetch(`${dataPath}/teams.json`);
                let teams = [];
                if (teamsResponse.ok) {
                    teams = await teamsResponse.json();
                }
                const championTeam = teams.find(t => t.team_key === champion.team_key);
                const teamLogo = fixTeamLogo(championTeam?.team_logo) || '';

                // Load scores for schedule
                const scoresResponse = await fetch(`${dataPath}/all_scores.json`);
                let scores = [];
                if (scoresResponse.ok) {
                    scores = await scoresResponse.json();
                }

                // Load player stats for roster
                const playerStatsResponse = await fetch(`${dataPath}/player_stats.json`);
                let playerStats = [];
                if (playerStatsResponse.ok) {
                    playerStats = await playerStatsResponse.json();
                }

                // Count championships for this manager (and check for back-to-back)
                const championshipInfo = await countManagerChampionships(champion.manager, selectedYear);

                // Render champion header
                renderChampionHeader(champion, teamLogo, selectedYear, isCurrentSeason);

                // Render championship count
                renderChampionshipCount(championshipInfo);

                // Render stats
                renderChampionStats(champion, scores, standings);

                // Render schedule
                renderChampionSchedule(champion, scores, standings, teams);

                // Render roster
                renderChampionRoster(champion, playerStats);

                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading champion data:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        async function countManagerChampionships(managerName, upToYear) {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            let count = 0;
            let thisIsNth = 0;
            let championshipYears = [];

            for (const year of seasons) {
                if (year > upToYear) break;
                try {
                    let response;
                    if (year === 2025) {
                        response = await fetch('data/historical/2025/standings.json');
                    } else {
                        response = await fetch(`data/historical/${year}/final_standings.json`);
                    }
                    if (response.ok) {
                        let standings = await response.json();
                        standings = normalizeStandingsData(standings, year);
                        const champ = standings.find(t => t.rank === 1);
                        if (champ && champ.manager === managerName) {
                            count++;
                            championshipYears.push(year);
                            if (year === upToYear) {
                                thisIsNth = count;
                            }
                        }
                    }
                } catch (e) {
                    console.log(`Could not load ${year} standings`);
                }
            }

            // Check for back-to-back (consecutive years)
            let isBackToBack = false;
            let consecutiveCount = 1;

            if (championshipYears.length >= 2) {
                const currentIndex = championshipYears.indexOf(upToYear);
                if (currentIndex > 0) {
                    // Check if previous championship was the year before
                    const prevYear = championshipYears[currentIndex - 1];
                    if (prevYear === upToYear - 1) {
                        isBackToBack = true;
                        // Count consecutive championships
                        consecutiveCount = 2;
                        for (let i = currentIndex - 2; i >= 0; i--) {
                            if (championshipYears[i] === championshipYears[i + 1] - 1) {
                                consecutiveCount++;
                            } else {
                                break;
                            }
                        }
                    }
                }
            }

            return {
                nth: thisIsNth,
                total: count,
                isBackToBack: isBackToBack,
                consecutiveCount: consecutiveCount,
                years: championshipYears
            };
        }

        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        function renderChampionHeader(champion, teamLogo, year, isCurrentSeason) {
            const headerEl = document.getElementById('champion-header');
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFhMWEyZSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZCI+8J+Phjwv dGV4dD48L3N2Zz4=';

            const seasonLabel = isCurrentSeason ? `${year} Season Leader` : `${year} Season Champion`;

            headerEl.innerHTML = `
                <img src="${teamLogo || placeholderLogo}" alt="${champion.team_name}" class="team-logo" onerror="this.src='${placeholderLogo}'">
                <div class="champion-info">
                    <h3>${champion.team_name}</h3>
                    <div class="manager-name">Manager: ${champion.manager}</div>
                    <div class="season-year">${seasonLabel}</div>
                </div>
                <div class="trophy-icon"><img src="champion_ring.png" style="width:50px;height:50px;"></div>
            `;
        }

        function renderChampionshipCount(info) {
            const bannerEl = document.getElementById('championship-count-banner');

            if (!info || info.nth === 0) {
                bannerEl.style.display = 'none';
                return;
            }

            const { nth, isBackToBack, consecutiveCount } = info;
            const ordinal = getOrdinal(nth);
            let message = '';

            if (nth === 1) {
                message = ` First Championship Title! `;
            } else if (isBackToBack) {
                if (consecutiveCount === 2) {
                    message = ` Back-to-Back Champions! ${ordinal} Title! `;
                } else if (consecutiveCount === 3) {
                    message = ` THREE-PEAT! ${ordinal} Championship! `;
                } else if (consecutiveCount >= 4) {
                    message = `DYNASTY! ${consecutiveCount}-PEAT DYNASTY! ${ordinal} Championship!`;
                }
            } else if (nth >= 3) {
                message = ` Dynasty Alert: ${ordinal} Championship! `;
            } else {
                message = ` ${ordinal} Championship Title! `;
            }

            bannerEl.innerHTML = message;
            bannerEl.style.display = 'block';
        }

        function renderChampionStats(champion, scores, standings) {
            // Calculate stats from scores
            const championScores = scores.filter(s => s.team_key === champion.team_key);

            let wins = 0, losses = 0, totalPoints = 0, bestWeek = 0;
            championScores.forEach(matchup => {
                totalPoints += matchup.team_score || 0;
                if (matchup.team_score > matchup.opponent_score) wins++;
                else if (matchup.team_score < matchup.opponent_score) losses++;
                if (matchup.team_score > bestWeek) bestWeek = matchup.team_score;
            });

            const gamesPlayed = wins + losses;
            const ppg = gamesPlayed > 0 ? (totalPoints / gamesPlayed).toFixed(1) : '-';

            document.getElementById('champion-record').textContent = `${wins}-${losses}`;
            document.getElementById('champion-points').textContent = totalPoints.toFixed(1);
            document.getElementById('champion-ppg').textContent = ppg;
            document.getElementById('champion-best-week').textContent = bestWeek.toFixed(1);
        }

        function renderChampionSchedule(champion, scores, standings, teams) {
            const tbody = document.getElementById('champion-schedule');
            const championScores = scores.filter(s => s.team_key === champion.team_key);

            // Create team key to name and logo mapping
            const teamKeyToInfo = {};
            standings.forEach(team => {
                const teamData = teams.find(t => t.team_key === team.team_key);
                teamKeyToInfo[team.team_key] = {
                    name: team.team_name,
                    logo: fixTeamLogo(teamData?.team_logo) || ''
                };
            });

            // Sort by week
            championScores.sort((a, b) => a.week - b.week);

            // Determine playoff weeks (usually last 3-4 weeks)
            const maxWeek = Math.max(...championScores.map(s => s.week));
            const playoffStart = maxWeek - 2; // Assume 3 week playoffs

            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjwvc3ZnPg==';

            tbody.innerHTML = championScores.map(matchup => {
                const opponentInfo = teamKeyToInfo[matchup.opponent_key] || { name: 'Unknown', logo: '' };
                const opponentLogo = opponentInfo.logo || placeholderLogo;
                const isWin = matchup.team_score > matchup.opponent_score;
                const result = isWin ? 'W' : 'L';
                const resultClass = isWin ? 'result-win' : 'result-loss';
                const rowResultClass = isWin ? 'schedule-row-win' : 'schedule-row-loss';

                let rowClass = rowResultClass;

                // CHANGED: Wrap "Week " in a span so we can hide it with CSS on mobile
                const weekPrefix = '<span class="week-text">Week </span>';
                let weekLabel = `${weekPrefix}${matchup.week}`;

                if (matchup.week >= playoffStart) {
                    rowClass += ' playoff-week';
                    if (matchup.week === maxWeek) {
                        rowClass += ' championship-week';
                        weekLabel = `${weekPrefix}${matchup.week} Finals`;
                    } else {
                        weekLabel = `${weekPrefix}${matchup.week} `;
                    }
                }

                return `
                    <tr class="${rowClass}">
                        <td>${weekLabel}</td>
                        <td>
                            <div class="schedule-opponent">
                                <img src="${opponentLogo}" alt="" class="schedule-team-logo" onerror="this.style.display='none'">
                                <span>${opponentInfo.name}</span>
                            </div>
                        </td>
                        <td>${matchup.team_score.toFixed(1)} - ${matchup.opponent_score.toFixed(1)}</td>
                        <td class="${resultClass}">${result}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderChampionRoster(champion, playerStats) {
            const rosterEl = document.getElementById('champion-roster');

            // Filter players on champion's team
            const rosterPlayers = playerStats.filter(p => p.team_key === champion.team_key);

            if (rosterPlayers.length === 0) {
                rosterEl.innerHTML = '<p style="color: #666; text-align: center;">Roster data not available for this season.</p>';
                return;
            }

            // Separate by position type and points
            const batters = rosterPlayers.filter(p => p.position_type === 'B' && (p.fantasy_points || 0) > 0);
            const pitchers = rosterPlayers.filter(p => p.position_type === 'P' && (p.fantasy_points || 0) > 0);
            const prospects = rosterPlayers.filter(p => (p.fantasy_points || 0) === 0);

            // Sort each group by fantasy points descending
            batters.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            pitchers.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            prospects.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            const renderPlayerCard = (player, isProspect = false) => {
                const headshot = player.headshot_url || placeholderImg;
                const points = (player.fantasy_points || 0).toFixed(1);
                const cardClass = isProspect ? 'roster-player-card prospect' : 'roster-player-card';
                return `
                    <div class="${cardClass}">
                        <img src="${headshot}" alt="${player.name}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                        <div class="player-info">
                            <div class="player-name">${player.name}</div>
                            <div class="player-position">${player.primary_position || '-'}</div>
                        </div>
                        <div class="player-points">
                            <div class="points-value">${points}</div>
                            <div class="points-label">pts</div>
                        </div>
                    </div>
                `;
            };

            let html = '<div class="roster-columns">';

            // Batters column
            html += '<div class="roster-column">';
            if (batters.length > 0) {
                html += `<div class="roster-section-title">Batters (${batters.length})</div>`;
                html += `<div class="roster-grid">${batters.map(p => renderPlayerCard(p, false)).join('')}</div>`;
            }
            html += '</div>';

            // Pitchers column
            html += '<div class="roster-column">';
            if (pitchers.length > 0) {
                html += `<div class="roster-section-title">Pitchers (${pitchers.length})</div>`;
                html += `<div class="roster-grid">${pitchers.map(p => renderPlayerCard(p, false)).join('')}</div>`;
            }
            html += '</div>';

            html += '</div>';

            // Prospects section (players with 0 points)
            if (prospects.length > 0) {
                html += '<div class="prospects-section">';
                html += `<div class="roster-section-title"> Prospects (${prospects.length})</div>`;
                html += `<div class="roster-grid">${prospects.map(p => renderPlayerCard(p, true)).join('')}</div>`;
                html += '</div>';
            }

            rosterEl.innerHTML = html;
        }

        // ===== LOAD AWARDS =====
        async function loadAwards() {
            console.log("Loading awards...");
            const loadingEl = document.getElementById('awards-loading');
            const errorEl = document.getElementById('awards-error');
            const contentEl = document.getElementById('awards-content');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                contentEl.style.display = 'none';

                // Load all seasons data
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                const seasonData = {};

                console.log("Fetching data for seasons:", seasons);

                for (const year of seasons) {
                    try {
                        let standingsResponse, teamsResponse, playerStatsResponse, draftResponse;

                        // All historical seasons now use final_standings.json
                        standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                        teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                        playerStatsResponse = await fetch(`data/historical/${year}/player_stats.json`);
                        draftResponse = await fetch(`data/historical/${year}/draft.json`);

                        console.log(`${year}: standings=${standingsResponse.ok}, teams=${teamsResponse.ok}, playerStats=${playerStatsResponse.ok}`);

                        if (standingsResponse.ok && teamsResponse.ok) {
                            const standings = await standingsResponse.json();
                            const teams = await teamsResponse.json();
                            const playerStats = playerStatsResponse.ok ? await playerStatsResponse.json() : [];
                            const draftData = draftResponse && draftResponse.ok ? await draftResponse.json() : [];

                            // Normalize standings
                            const normalizedStandings = normalizeStandingsData(standings, year);

                            // Create team logo map
                            const logoMap = {};
                            teams.forEach(team => {
                                logoMap[team.team_key] = fixTeamLogo(team.team_logo);
                            });

                            // Create team info map
                            const teamInfoMap = {};
                            teams.forEach(team => {
                                teamInfoMap[team.team_key] = {
                                    name: team.team_name,
                                    manager: team.manager,
                                    logo: fixTeamLogo(team.team_logo)
                                };
                            });

                            seasonData[year] = {
                                standings: normalizedStandings,
                                logos: logoMap,
                                teamInfo: teamInfoMap,
                                playerStats: playerStats,
                                draftData: draftData
                            };
                        }
                    } catch (e) {
                        console.error(`Error loading ${year}:`, e);
                    }
                }

                console.log("Loaded season data for:", Object.keys(seasonData));

                // Calculate awards
                const regularSeasonWinners = [];
                const scoringChampions = [];
                const garbageAwards = [];
                const clownAwards = [];
                const troutAwards = [];
                const degromAwards = [];
                const diamondAwards = [];
                const bustAwards = [];

                // Load keepers data for excluding from draft value calculations
                let allKeepers = {};
                try {
                    const keepersResponse = await fetch('data/keepers.json');
                    if (keepersResponse.ok) {
                        allKeepers = await keepersResponse.json();
                    }
                } catch (e) {
                    console.log('No keepers data available');
                }

                for (const [year, data] of Object.entries(seasonData)) {
                    const standings = data.standings;
                    const logos = data.logos;
                    const playerStats = data.playerStats || [];

                    // Regular Season Champion (most wins)
                    const mostWins = standings.reduce((max, team) =>
                        team.wins > max.wins ? team : max
                    );
                    regularSeasonWinners.push({
                        year,
                        manager: mostWins.manager,
                        team_name: mostWins.team_name,
                        logo: logos[mostWins.team_key],
                        value: mostWins.wins
                    });

                    // Scoring Champion (most points)
                    const mostPoints = standings.reduce((max, team) =>
                        team.points_for > max.points_for ? team : max
                    );
                    scoringChampions.push({
                        year,
                        manager: mostPoints.manager,
                        team_name: mostPoints.team_name,
                        logo: logos[mostPoints.team_key],
                        value: Math.round(mostPoints.points_for)
                    });

                    // Garbage Award (worst record - fewest wins, tiebreaker: least points)
                    const fewestWins = standings.reduce((min, team) => {
                        if (team.wins < min.wins) return team;
                        if (team.wins === min.wins && team.points_for < min.points_for) return team;
                        return min;
                    });
                    garbageAwards.push({
                        year,
                        manager: fewestWins.manager,
                        team_name: fewestWins.team_name,
                        logo: logos[fewestWins.team_key],
                        wins: fewestWins.wins,
                        losses: fewestWins.losses
                    });

                    // Clown Award (least points)
                    const leastPoints = standings.reduce((min, team) =>
                        team.points_for < min.points_for ? team : min
                    );
                    clownAwards.push({
                        year,
                        manager: leastPoints.manager,
                        team_name: leastPoints.team_name,
                        logo: logos[leastPoints.team_key],
                        value: Math.round(leastPoints.points_for)
                    });

                    // Mike Trout Award (highest scoring hitter)
                    const batters = playerStats.filter(p => p.position_type === 'B');
                    if (batters.length > 0) {
                        const topHitter = batters.reduce((max, player) =>
                            (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                        );
                        troutAwards.push({
                            year,
                            manager: topHitter.manager,
                            team_logo: fixTeamLogo(topHitter.team_logo),
                            player_name: topHitter.name,
                            player_headshot: topHitter.headshot_url,
                            value: Math.round(topHitter.fantasy_points || 0)
                        });
                    }

                    // Jacob deGrom Award (highest scoring pitcher)
                    const pitchers = playerStats.filter(p => p.position_type === 'P');
                    if (pitchers.length > 0) {
                        const topPitcher = pitchers.reduce((max, player) =>
                            (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                        );
                        degromAwards.push({
                            year,
                            manager: topPitcher.manager,
                            team_logo: fixTeamLogo(topPitcher.team_logo),
                            player_name: topPitcher.name,
                            player_headshot: topPitcher.headshot_url,
                            value: Math.round(topPitcher.fantasy_points || 0)
                        });
                    }

                    // Diamond in the Rough & Bust of the Year Awards
                    // Calculate points over expected value based on draft position
                    const draftData = data.draftData || [];
                    const teamInfo = data.teamInfo || {};
                    const keepersForYear = allKeepers[year.toString()] || {};

                    // Create lowercase keeper lookup
                    const keepersLower = {};
                    for (const name of Object.keys(keepersForYear)) {
                        keepersLower[name.toLowerCase()] = true;
                    }

                    if (draftData.length > 0 && playerStats.length > 0) {
                        // Create player stats lookup by name (lowercase)
                        const playerStatsMap = {};
                        playerStats.forEach(p => {
                            if (p.name) {
                                playerStatsMap[p.name.toLowerCase()] = p;
                            }
                        });

                        // Sort players by fantasy points to get expected value by rank
                        const sortedByPoints = [...playerStats]
                            .filter(p => p.fantasy_points && p.fantasy_points > 0)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));

                        // Create expected points by overall rank (pick number)
                        // Expected value = average points of players picked around that position
                        const expectedPointsByPick = {};
                        sortedByPoints.forEach((p, idx) => {
                            expectedPointsByPick[idx + 1] = p.fantasy_points || 0;
                        });

                        // Calculate value over expected for each draft pick (excluding keepers)
                        const draftValues = [];
                        draftData.forEach(pick => {
                            const playerName = pick.player_name || '';
                            const pickNum = pick.pick || 0;

                            // Skip keepers
                            if (keepersLower[playerName.toLowerCase()]) {
                                return;
                            }

                            // Get actual points and headshot from player stats
                            const playerData = playerStatsMap[playerName.toLowerCase()];
                            const actualPoints = playerData ? (playerData.fantasy_points || 0) : 0;

                            // Get headshot - prefer player stats (more reliable), fallback to draft data
                            const headshot = (playerData && playerData.headshot_url) ? playerData.headshot_url : (pick.headshot_url || '');

                            // Get expected points based on pick position
                            const expectedPoints = expectedPointsByPick[pickNum] || 0;

                            // Calculate value over expected
                            const valueOverExpected = actualPoints - expectedPoints;

                            // Get team info
                            const team = teamInfo[pick.team_key] || {};

                            // Normalize manager name
                            const managerName = team.manager ? normalizeManagerName(team.manager, parseInt(year), team.name, pick.team_key) : '';

                            draftValues.push({
                                player_name: playerName,
                                player_headshot: headshot,
                                pick: pickNum,
                                round: pick.round || Math.ceil(pickNum / 12),
                                actualPoints: actualPoints,
                                expectedPoints: expectedPoints,
                                valueOverExpected: valueOverExpected,
                                manager: managerName, // Use the normalized name
                                team_logo: fixTeamLogo(team.logo) || ''
                            });
                        });

                        // Find best value (Diamond) - highest positive value over expected
                        if (draftValues.length > 0) {
                            const bestValue = draftValues.reduce((best, pick) =>
                                pick.valueOverExpected > best.valueOverExpected ? pick : best
                            );
                            if (bestValue.valueOverExpected > 0) {
                                diamondAwards.push({
                                    year,
                                    manager: bestValue.manager,
                                    team_logo: bestValue.team_logo,
                                    player_name: bestValue.player_name,
                                    player_headshot: bestValue.player_headshot,
                                    pick: bestValue.pick,
                                    round: bestValue.round,
                                    value: Math.round(bestValue.valueOverExpected)
                                });
                            }

                            // Find worst value (Bust) - lowest (most negative) value over expected
                            // Only consider players drafted in first 5 rounds
                            const earlyPicks = draftValues.filter(p => p.round <= 5);
                            if (earlyPicks.length > 0) {
                                const worstValue = earlyPicks.reduce((worst, pick) =>
                                    pick.valueOverExpected < worst.valueOverExpected ? pick : worst
                                );
                                if (worstValue.valueOverExpected < 0) {
                                    bustAwards.push({
                                        year,
                                        manager: worstValue.manager,
                                        team_logo: worstValue.team_logo,
                                        player_name: worstValue.player_name,
                                        player_headshot: worstValue.player_headshot,
                                        pick: worstValue.pick,
                                        round: worstValue.round,
                                        value: Math.round(worstValue.valueOverExpected)
                                    });
                                }
                            }
                        }
                    }
                }

                console.log("Calculated awards:", {
                    regularSeasonWinners: regularSeasonWinners.length,
                    scoringChampions: scoringChampions.length,
                    garbageAwards: garbageAwards.length,
                    clownAwards: clownAwards.length,
                    troutAwards: troutAwards.length,
                    degromAwards: degromAwards.length,
                    diamondAwards: diamondAwards.length,
                    bustAwards: bustAwards.length
                });

                // Sort all by year (most recent first)
                [regularSeasonWinners, scoringChampions, garbageAwards, clownAwards, troutAwards, degromAwards, diamondAwards, bustAwards].forEach(arr => {
                    arr.sort((a, b) => b.year - a.year);
                });

                // Populate tables
                populateAwardTable('regular-season-winners', regularSeasonWinners, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value}</span></td>
                `);

                populateAwardTable('scoring-champions', scoringChampions, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('garbage-awards', garbageAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.wins}-${award.losses}</span></td>
                `);

                populateAwardTable('clown-awards', clownAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                // Base64 encoded placeholder for player headshots
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                populateAwardTable('trout-awards', troutAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('degrom-awards', degromAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('diamond-awards', diamondAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td>Rd ${award.round}, #${award.pick}</td>
                    <td><span class="award-value" style="color: #28a745;">+${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('bust-awards', bustAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td>Rd ${award.round}, #${award.pick}</td>
                    <td><span class="award-value" style="color: #dc3545;">${award.value.toLocaleString()}</span></td>
                `);

                console.log("Awards populated successfully");
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading awards:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading awards: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function populateAwardTable(tableId, awards, rowTemplate) {
            const tbody = document.getElementById(tableId);
            tbody.innerHTML = '';

            awards.forEach(award => {
                const row = document.createElement('tr');
                row.innerHTML = rowTemplate(award);
                tbody.appendChild(row);
            });
        }

        // ===== PRESEASON PROJECTIONS FUNCTIONS =====
        let allProjectionBatters = [];
        let allProjectionPitchers = [];
        let filteredProjections = [];
        let currentProjectionPlayerType = 'all';
        let showKeptPlayers = true;
        let projectionSort = { column: 'projected_points', direction: 'desc' };
        let projectionsData = null;
        
        // Average projections across all systems for keeper displays
        let averageProjectionsMap = {}; // { playerName: { avgPoints, systems: [...], headshot } }
        let averageProjectionsLoaded = false;
        
        // Load all projection systems and calculate averages
        async function loadAverageProjections() {
            if (averageProjectionsLoaded) return;
            
            const projectionSystems = ['thebatx', 'thebat', 'steamer', 'zips', 'atc', 'depthcharts', 'oopsy'];
            const playerProjections = {}; // { playerName: { points: [], headshot, position, type } }
            
            for (const system of projectionSystems) {
                try {
                    const response = await fetch(`data/projections/projections_${system}.json`);
                    if (!response.ok) continue;
                    
                    const data = await response.json();
                    
                    // Skip if file is empty or has no players
                    const batters = data.batters || [];
                    const pitchers = data.pitchers || [];
                    
                    if (batters.length === 0 && pitchers.length === 0) {
                        console.log(`Skipping ${system} - no projection data`);
                        continue;
                    }
                    
                    // Process batters
                    batters.forEach(player => {
                        if (!player.name || !player.projected_points || player.projected_points <= 0) return;
                        
                        const nameLower = player.name.toLowerCase().trim();
                        
                        if (!playerProjections[nameLower]) {
                            playerProjections[nameLower] = {
                                points: [],
                                headshot: player.headshot_url || '',
                                position: player.position || '',
                                type: 'batter'
                            };
                        }
                        
                        playerProjections[nameLower].points.push(player.projected_points);
                        
                        // Update headshot if we have a better one (not generic)
                        if (player.headshot_url && !player.headshot_url.includes('/people/1/')) {
                            playerProjections[nameLower].headshot = player.headshot_url;
                        }
                        
                        // Update position if we have one
                        if (player.position && !playerProjections[nameLower].position) {
                            playerProjections[nameLower].position = player.position;
                        }
                    });
                    
                    // Process pitchers
                    pitchers.forEach(player => {
                        if (!player.name || !player.projected_points || player.projected_points <= 0) return;
                        
                        const nameLower = player.name.toLowerCase().trim();
                        
                        if (!playerProjections[nameLower]) {
                            playerProjections[nameLower] = {
                                points: [],
                                headshot: player.headshot_url || '',
                                position: player.position || '',
                                type: 'pitcher'
                            };
                        }
                        
                        playerProjections[nameLower].points.push(player.projected_points);
                        
                        // Update headshot if we have a better one (not generic)
                        if (player.headshot_url && !player.headshot_url.includes('/people/1/')) {
                            playerProjections[nameLower].headshot = player.headshot_url;
                        }
                        
                        // Update position if we have one
                        if (player.position && !playerProjections[nameLower].position) {
                            playerProjections[nameLower].position = player.position;
                        }
                    });
                    
                    console.log(`Loaded ${system}: ${batters.length} batters, ${pitchers.length} pitchers`);
                } catch (e) {
                    console.log(`Could not load ${system} projections for averaging:`, e);
                }
            }
            
            // Calculate averages
            Object.entries(playerProjections).forEach(([name, data]) => {
                if (data.points.length > 0) {
                    const avg = data.points.reduce((sum, p) => sum + p, 0) / data.points.length;
                    averageProjectionsMap[name] = {
                        avgPoints: Math.round(avg * 10) / 10, // Round to 1 decimal
                        systems: data.points.length,
                        headshot: data.headshot,
                        position: data.position,
                        type: data.type
                    };
                    
                    // Also store without (Batter)/(Pitcher) suffix for Ohtani matching
                    const baseName = name.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                    if (baseName !== name && !averageProjectionsMap[baseName]) {
                        averageProjectionsMap[baseName] = averageProjectionsMap[name];
                    }
                }
            });
            
            console.log(`Loaded average projections for ${Object.keys(averageProjectionsMap).length} players`);
            averageProjectionsLoaded = true;
        }
        
        // Get average projection for a player
        function getAverageProjection(playerName) {
            const nameLower = (playerName || '').toLowerCase().trim();
            const baseName = nameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
            return averageProjectionsMap[nameLower]?.avgPoints || 
                   averageProjectionsMap[baseName]?.avgPoints || 0;
        }

        // Helper function to create position badge(s) with color
        // Handles multiple positions like "1B, 3B" or "1B/3B"
        function getPositionBadge(position, playerName) {
            if (!position || position === '-') return '<span class="position-badge">-</span>';

            // Handle Util position directly
            if (position.toLowerCase() === 'util') {
                return '<span class="position-badge pos-Util">Util</span>';
            }

            // Parse positions
            let positionsArray = position.split(/[,\/]/).map(p => p.trim()).filter(p => p);
            
            // Filter out DH if there are other positions
            const nonDHPositions = positionsArray.filter(p => p.toUpperCase() !== 'DH');
            if (nonDHPositions.length > 0) {
                positionsArray = nonDHPositions;
            } else if (positionsArray.some(p => p.toUpperCase() === 'DH')) {
                // DH is the only position - show as Util
                return '<span class="position-badge pos-Util">Util</span>';
            }

            // Handle Ohtani batter case specifically - if Shohei Ohtani has only pitcher positions, show Util
            const pitcherPositions = ['SP', 'RP', 'P'];
            const allPitcher = positionsArray.length > 0 && positionsArray.every(p => pitcherPositions.includes(p));
            const isOhtani = playerName && playerName.toLowerCase().includes('ohtani');
            if (allPitcher && isOhtani && positionsArray.length > 1) {
                // This is Ohtani batter (has SP, P but is in batters list)
                return '<span class="position-badge pos-Util">Util</span>';
            }

            // Generate a badge for each position
            return positionsArray.map(pos => {
                return `<span class="position-badge pos-${pos}">${pos}</span>`;
            }).join(' ');
        }

        async function loadProjections() {
            const projectionType = document.getElementById('projection-type').value;
            const loadingEl = document.getElementById('proj-loading');
            const errorEl = document.getElementById('proj-error');
            const containerEl = document.getElementById('proj-stats-container');
            const noDataEl = document.getElementById('proj-no-data');

            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            containerEl.style.display = 'none';
            if (noDataEl) noDataEl.style.display = 'none';
            
            // Hide any previous BAT X notice
            const batxNotice = document.getElementById('proj-batx-notice');
            if (batxNotice) batxNotice.style.display = 'none';
            
            // Load average projections first (for headshot fallbacks)
            await loadAverageProjections();

            try {
                // Try to load projections data
                const response = await fetch(`data/projections/projections_${projectionType}.json`);

                if (!response.ok) {
                    throw new Error(`${projectionType} projections have not been released. Check back soon!`);
                }

                projectionsData = await response.json();

                allProjectionBatters = projectionsData.batters || [];
                allProjectionPitchers = projectionsData.pitchers || [];

                console.log(`Loaded ${allProjectionBatters.length} batters and ${allProjectionPitchers.length} pitchers`);
                
                // Show toast popup if The BAT X (batters only)
                if (projectionType === 'thebatx' && allProjectionPitchers.length === 0) {
                    showBatXToast();
                }
                
                // Handle Shohei Ohtani specially - normalize position to Util for batter, SP for pitcher
                allProjectionBatters.forEach(p => {
                    const nameLower = p.name?.toLowerCase() || '';
                    if (nameLower.includes('shohei ohtani') || nameLower === 'shohei ohtani') {
                        // Ohtani batter should be listed as Util, not DH
                        if (p.position && (p.position.includes('DH') || p.position.includes('Util'))) {
                            p.position = 'Util';
                        }
                    }
                });
                
                allProjectionPitchers.forEach(p => {
                    const nameLower = p.name?.toLowerCase() || '';
                    if (nameLower.includes('shohei ohtani') || nameLower === 'shohei ohtani') {
                        // Ohtani pitcher should be SP
                        p.position = 'SP';
                    }
                });
                
                // Fill in missing headshots from cached headshots (from other projection systems)
                const genericHeadshotPattern = /\/people\/1\/headshot/;
                [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                    // Check if headshot is missing or generic
                    if (!p.headshot_url || genericHeadshotPattern.test(p.headshot_url)) {
                        const nameLower = (p.name || '').toLowerCase().trim();
                        const baseName = nameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                        // Try to get from averageProjectionsMap (which has headshots from all systems)
                        const cached = averageProjectionsMap[nameLower] || averageProjectionsMap[baseName];
                        if (cached && cached.headshot && !genericHeadshotPattern.test(cached.headshot)) {
                            p.headshot_url = cached.headshot;
                        }
                    }
                });

                // Pre-calculate games and PPG for sorting
                allProjectionBatters.forEach(p => {
                    const stats = p.stats || {};
                    // Use actual G from projections
                    p.games = stats.G || 0;
                    p.ppg = p.games > 0 ? (p.projected_points || 0) / p.games : 0;
                });

                allProjectionPitchers.forEach(p => {
                    const stats = p.stats || {};
                    p.games = stats.G || 0;
                    p.ppg = p.games > 0 ? (p.projected_points || 0) / p.games : 0;
                });

                // Calculate position ranks
                calculateProjectionPositionRanks();

                // Display scoring settings
                displayScoringSettings(projectionsData.scoring);

                loadingEl.style.display = 'none';
                containerEl.style.display = 'block';

                filterProjections();

            } catch (error) {
                console.error('Error loading projections:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = error.message;
                errorEl.style.display = 'block';
            }
        }
        
        // Toast notification for BAT X
        function showBatXToast() {
            // Remove existing toast if any
            const existingToast = document.getElementById('batx-toast');
            if (existingToast) existingToast.remove();
            
            const toast = document.createElement('div');
            toast.id = 'batx-toast';
            toast.innerHTML = 'The BAT X only projects batters, choose another projection to see pitchers';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--retro-blue);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                opacity: 0;
                transition: opacity 0.3s ease;
            `;
            document.body.appendChild(toast);
            
            // Fade in
            setTimeout(() => toast.style.opacity = '1', 10);
            
            // Fade out and remove after 2 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        function calculateProjectionPositionRanks() {
            // Combine all players for ranking
            const allPlayers = [...allProjectionBatters, ...allProjectionPitchers];

            // Define positions to rank (batting positions + pitching)
            const positions = ['C', '1B', '2B', '3B', 'SS', 'LF', 'CF', 'RF', 'OF', 'DH', 'SP', 'RP'];

            positions.forEach(pos => {
                // Get players eligible for this position
                let eligiblePlayers;
                if (pos === 'OF') {
                    // OF includes LF, CF, RF, OF
                    eligiblePlayers = allPlayers.filter(p => {
                        const playerPos = (p.position || '').toUpperCase();
                        return playerPos.includes('LF') || playerPos.includes('CF') ||
                            playerPos.includes('RF') || playerPos.includes('OF');
                    });
                } else {
                    eligiblePlayers = allPlayers.filter(p => {
                        const playerPos = (p.position || '').toUpperCase();
                        return playerPos.includes(pos);
                    });
                }

                // Sort by projected points descending
                eligiblePlayers.sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));

                // Assign ranks
                eligiblePlayers.forEach((player, index) => {
                    if (!player.position_ranks) {
                        player.position_ranks = {};
                    }
                    player.position_ranks[pos] = index + 1;
                });
            });

            // Also calculate overall batter and pitcher ranks
            const batters = allPlayers.filter(p => p.type === 'batter')
                .sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));
            batters.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['B'] = index + 1;
                // UTIL rank is same as overall batter rank
                player.position_ranks['UTIL'] = index + 1;
            });

            const pitchers = allPlayers.filter(p => p.type === 'pitcher')
                .sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));
            pitchers.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['P'] = index + 1;
            });
        }

        function formatProjectionPosition(position, playerName) {
            // Format position string
            if (!position) return 'Util';
            
            // Split by comma or slash
            let positions = position.split(/[,\/]/)
                .map(p => p.trim())
                .filter(p => p && !['UTIL', 'NA', 'B'].includes(p.toUpperCase()));
            
            // Filter out DH if there are other positions
            const nonDHPositions = positions.filter(p => p.toUpperCase() !== 'DH');
            
            // If there are non-DH positions, use those instead
            if (nonDHPositions.length > 0) {
                positions = nonDHPositions;
            } else if (positions.some(p => p.toUpperCase() === 'DH')) {
                // DH is the only position - convert to Util
                return 'Util';
            }
            
            // Check if this is Shohei Ohtani (batter version)
            const isOhtaniBatter = playerName && 
                playerName.toLowerCase().includes('shohei ohtani') && 
                !playerName.toLowerCase().includes('pitcher');

            // Handle Ohtani batter case - always show as Util
            if (isOhtaniBatter) {
                // If only pitcher positions (SP, RP, P), show as Util
                const pitcherPositions = ['SP', 'RP', 'P'];
                if (positions.length === 0 || positions.every(p => pitcherPositions.includes(p.toUpperCase()))) {
                    return 'Util';
                }
            }

            // If no valid positions after filtering, return Util
            return positions.length > 0 ? positions.join(', ') : 'Util';
        }

        function getProjectionPositionRank(player) {
            if (!player.position_ranks) return '-';
            
            // Check if this is Shohei Ohtani
            const nameLower = (player.name || '').toLowerCase();
            const isOhtani = nameLower.includes('shohei ohtani');
            const isOhtaniBatter = isOhtani && player.type === 'batter';
            const isOhtaniPitcher = isOhtani && player.type === 'pitcher';
            
            // Ohtani batter should always show UTIL rank
            if (isOhtaniBatter) {
                const utilRank = player.position_ranks['UTIL'] || player.position_ranks['B'];
                return utilRank ? `UTIL${utilRank}` : '-';
            }
            
            // Ohtani pitcher should always show SP rank
            if (isOhtaniPitcher) {
                const spRank = player.position_ranks['SP'];
                return spRank ? `SP${spRank}` : '-';
            }

            // Get positions, filtering out UTIL, NA, B
            let positions = (player.position || '').split(/[,\/]/)
                .map(p => p.trim())
                .filter(p => p && !['UTIL', 'NA', 'B'].includes(p.toUpperCase()));
            
            // Filter out DH if there are other positions
            const nonDHPositions = positions.filter(p => p.toUpperCase() !== 'DH');
            if (nonDHPositions.length > 0) {
                positions = nonDHPositions;
            }

            // If no valid positions or only DH, use UTIL rank
            if (positions.length === 0 || (positions.length === 1 && positions[0].toUpperCase() === 'DH')) {
                const utilRank = player.position_ranks['UTIL'] || player.position_ranks['B'];
                return utilRank ? `UTIL${utilRank}` : '-';
            }

            // Get the primary position (first one)
            let primaryPos = positions[0].toUpperCase();

            // Normalize OF positions
            if (['LF', 'CF', 'RF'].includes(primaryPos)) {
                // Use OF rank if available, otherwise use specific position
                if (player.position_ranks['OF']) {
                    return `OF${player.position_ranks['OF']}`;
                }
            }

            const rank = player.position_ranks[primaryPos];
            if (rank) {
                return `${primaryPos}${rank}`;
            }

            // Fallback to UTIL rank for batters without recognized position
            if (player.type === 'batter') {
                const utilRank = player.position_ranks['UTIL'] || player.position_ranks['B'];
                return utilRank ? `UTIL${utilRank}` : positions[0];
            }

            return positions[0];
        }

        function displayScoringSettings(scoring) {
            const container = document.getElementById('proj-scoring-display');
            // Element was removed, so just return
            if (!container) return;

            if (!scoring) {
                container.innerHTML = '<p>Scoring settings not available.</p>';
                return;
            }

            const battingHtml = scoring.batting ? `
                <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <h4 style="color: var(--retro-blue); font-size: 0.9rem; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0;">Batting</h4>
                    ${Object.entries(scoring.batting).map(([stat, val]) => `
                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0; font-size: 0.85rem;">
                            <span style="color: #555;">${stat}</span>
                            <span style="font-weight: 600; color: ${val >= 0 ? '#28a745' : '#dc3545'};">${val >= 0 ? '+' : ''}${val}</span>
                        </div>
                    `).join('')}
                </div>
            ` : '';

            const pitchingHtml = scoring.pitching ? `
                <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <h4 style="color: var(--retro-blue); font-size: 0.9rem; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0;">Pitching</h4>
                    ${Object.entries(scoring.pitching).map(([stat, val]) => `
                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0; font-size: 0.85rem;">
                            <span style="color: #555;">${stat}</span>
                            <span style="font-weight: 600; color: ${val >= 0 ? '#28a745' : '#dc3545'};">${val >= 0 ? '+' : ''}${val}</span>
                        </div>
                    `).join('')}
                </div>
            ` : '';

            container.innerHTML = battingHtml + pitchingHtml;
        }

        function setProjectionPlayerType(type) {
            currentProjectionPlayerType = type;

            document.querySelectorAll('#preseason .stat-type-toggle .toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`proj-btn-${type}`).classList.add('active');

            filterProjections();
        }

        function filterProjections() {
            const positionFilter = document.getElementById('proj-position-filter').value;
            const searchTerm = document.getElementById('proj-player-search').value.toLowerCase();

            let data = [];

            if (currentProjectionPlayerType === 'all') {
                data = [...allProjectionBatters, ...allProjectionPitchers];
            } else if (currentProjectionPlayerType === 'batters') {
                data = [...allProjectionBatters];
            } else {
                data = [...allProjectionPitchers];
            }

            // Apply position filter
            if (positionFilter !== 'all') {
                if (positionFilter === 'B') {
                    data = data.filter(p => p.type === 'batter');
                } else if (positionFilter === 'P') {
                    data = data.filter(p => p.type === 'pitcher');
                } else {
                    data = data.filter(p => {
                        const pos = (p.position || '').toUpperCase();
                        if (positionFilter === 'OF') {
                            return pos.includes('LF') || pos.includes('CF') || pos.includes('RF') || pos.includes('OF');
                        }
                        return pos.includes(positionFilter);
                    });
                }
            }

            // Apply search filter
            if (searchTerm) {
                data = data.filter(p =>
                    (p.name || '').toLowerCase().includes(searchTerm) ||
                    (p.team || '').toLowerCase().includes(searchTerm)
                );
            }

            // Apply kept player filter
            if (!showKeptPlayers) {
                data = data.filter(p => getPlayerKeeperInfo(p.name) === null);
            }

            // Sort data
            data.sort((a, b) => {
                const col = projectionSort.column;
                
                // Special handling for BPA sorting
                if (col === 'bpa' && !showKeptPlayers) {
                    // BPA is based on projected points ranking among non-keepers
                    // Lower BPA = better, so we sort by projected_points descending for 'asc' BPA
                    const aPoints = a.projected_points || 0;
                    const bPoints = b.projected_points || 0;
                    // For BPA, 'asc' means best available first (highest points), 'desc' means worst first
                    return projectionSort.direction === 'asc' ? (bPoints - aPoints) : (aPoints - bPoints);
                }

                // === HELPER: Check both main object AND stats object ===
                const getVal = (obj) => {
                    // 1. Check main object (Rank, Name, Projected Points, Games)
                    if (obj[col] !== undefined) return obj[col];

                    // 2. Check stats object (HR, RBI, ERA, WHIP, etc.)
                    if (obj.stats && obj.stats[col] !== undefined) return obj.stats[col];

                    // 3. Handle 'K' vs 'SO' mapping if needed
                    if (col === 'K' && obj.stats && obj.stats.SO !== undefined) return obj.stats.SO;

                    return 0; // Default for missing data
                };

                let aVal = getVal(a);
                let bVal = getVal(b);

                if (typeof aVal === 'string') {
                    return projectionSort.direction === 'asc'
                        ? (aVal || '').localeCompare(bVal || '')
                        : (bVal || '').localeCompare(aVal || '');
                }

                return projectionSort.direction === 'asc' ? (aVal - bVal) : (bVal - aVal);
            });

            filteredProjections = data;
            renderProjectionTable();
        }

        function renderProjectionTable() {
            const thead = document.getElementById('proj-table-head');
            const tbody = document.getElementById('proj-table-body');
            const countEl = document.getElementById('proj-player-count');

            // Check if we have mixed data or just batters/pitchers
            const hasBatters = filteredProjections.some(p => p.type === 'batter');
            const hasPitchers = filteredProjections.some(p => p.type === 'pitcher');
            
            // Calculate BPA rankings when keepers are hidden
            // BPA = ranking by projected points with keepers removed
            // Use name + type as key to distinguish Ohtani batter from Ohtani pitcher
            let bpaRankings = {};
            if (!showKeptPlayers) {
                // Get all players (not just filtered) excluding keepers, sorted by projected points
                const allNonKeepers = [...allProjectionBatters, ...allProjectionPitchers]
                    .filter(p => getPlayerKeeperInfo(p.name) === null)
                    .sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));
                
                // Assign BPA rank to each player using name + type as key
                allNonKeepers.forEach((player, index) => {
                    const nameLower = (player.name || '').toLowerCase().trim();
                    const playerType = player.type || 'unknown';
                    const bpaKey = `${nameLower}|${playerType}`;
                    bpaRankings[bpaKey] = index + 1;
                });
            }

            // Build headers based on data type
            let headers = `
                <tr>
                    <th class="sortable" onclick="sortProjectionTable('rank')">#</th>
                    <th class="sortable" onclick="sortProjectionTable('name')">Player</th>
                    <th class="sortable" onclick="sortProjectionTable('position')">Pos</th>
                    <th>Rank</th>
                    <th class="sortable stat-col" onclick="sortProjectionTable('projected_points')">Proj Pts</th>
                    ${!showKeptPlayers ? '<th class="sortable stat-col bpa-header" onclick="sortProjectionTable(\'bpa\')" title="Best Player Available - Draft ranking with keepers removed from the player pool">BPA</th>' : ''}
                    <th class="sortable stat-col" onclick="sortProjectionTable('games')">G</th>
                    <th class="sortable stat-col" onclick="sortProjectionTable('ppg')">PPG</th>
            `;

            if (hasBatters && !hasPitchers) {
                headers += `
                    <th class="sortable" onclick="sortProjectionTable('HR')">HR</th>
                    <th class="sortable" onclick="sortProjectionTable('RBI')">RBI</th>
                    <th class="sortable" onclick="sortProjectionTable('R')">R</th>
                    <th class="sortable" onclick="sortProjectionTable('SB')">SB</th>
                    <th class="sortable" onclick="sortProjectionTable('AVG')">AVG</th>
                    <th class="sortable" onclick="sortProjectionTable('OPS')">OPS</th>
                `;
            } else if (hasPitchers && !hasBatters) {
                headers += `
                    <th class="sortable" onclick="sortProjectionTable('W')">W</th>
                    <th class="sortable" onclick="sortProjectionTable('SV')">SV</th>
                    <th class="sortable" onclick="sortProjectionTable('K')">K</th>
                    <th class="sortable" onclick="sortProjectionTable('ERA')">ERA</th>
                    <th class="sortable" onclick="sortProjectionTable('WHIP')">WHIP</th>
                    <th class="sortable" onclick="sortProjectionTable('IP')">IP</th>
                `;
            } else {
                // Mixed - show key stats for both
                headers += `
                    <th class="stat-col">Key Stats</th>
                `;
            }

            headers += '</tr>';
            thead.innerHTML = headers;

            // Update sort indicators
            updateProjectionSortIndicators();

            // Build rows
            tbody.innerHTML = '';

            // Base64 placeholder for headshots
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            // Calculate column count for round divider colspan
            let colCount = 8; // Base columns: #, Player, Pos, Rank, Proj Pts, G, PPG + BPA when shown
            if (!showKeptPlayers) colCount++; // BPA column
            if (hasBatters && !hasPitchers) colCount += 6; // Batter stats
            else if (hasPitchers && !hasBatters) colCount += 6; // Pitcher stats
            else colCount += 1; // Mixed key stats

            // Track player index for round dividers (only when keepers hidden and not filtering by position/search)
            let playerCount = 0;
            const showRoundDividers = !showKeptPlayers && 
                                       projectionSort.column === 'projected_points' && 
                                       projectionSort.direction === 'desc' &&
                                       document.getElementById('proj-position-filter').value === 'all' &&
                                       !document.getElementById('proj-player-search').value.trim();

            filteredProjections.forEach((player, index) => {
                // Insert round divider before every 12 players when keepers are hidden
                if (showRoundDividers && playerCount % 12 === 0) {
                    const roundNum = Math.floor(playerCount / 12) + 1;
                    const roundRow = document.createElement('tr');
                    roundRow.className = 'round-divider';
                    roundRow.innerHTML = `<td colspan="${colCount}">Projected Round ${roundNum}</td>`;
                    tbody.appendChild(roundRow);
                }
                playerCount++;

                const row = document.createElement('tr');
                const stats = player.stats || {};

                let statsHtml = '';
                if (hasBatters && !hasPitchers) {
                    statsHtml = `
                        <td class="stat-col">${stats.HR || 0}</td>
                        <td class="stat-col">${stats.RBI || 0}</td>
                        <td class="stat-col">${stats.R || 0}</td>
                        <td class="stat-col">${stats.SB || 0}</td>
                        <td class="stat-col">${(stats.AVG || 0).toFixed(3)}</td>
                        <td class="stat-col">${(stats.OPS || 0).toFixed(3)}</td>
                    `;
                } else if (hasPitchers && !hasBatters) {
                    statsHtml = `
                        <td class="stat-col">${stats.W || 0}</td>
                        <td class="stat-col">${stats.SV || 0}</td>
                        <td class="stat-col">${stats.K || stats.SO || 0}</td>
                        <td class="stat-col">${(stats.ERA || 0).toFixed(2)}</td>
                        <td class="stat-col">${(stats.WHIP || 0).toFixed(2)}</td>
                        <td class="stat-col">${(stats.IP || 0).toFixed(0)}</td>
                    `;
                } else {
                    // Mixed view - show abbreviated stats
                    if (player.type === 'batter') {
                        statsHtml = `<td class="stat-col" style="font-size: 0.8rem;">${stats.HR || 0}HR, ${stats.SB || 0}SB, ${(stats.OPS || 0).toFixed(3)}OPS</td>`;
                    } else {
                        statsHtml = `<td class="stat-col" style="font-size: 0.8rem;">${(stats.IP || 0).toFixed(0)}IP, ${(stats.ERA || 0).toFixed(2)}ERA, ${stats.K || stats.SO || 0}K</td>`;
                    }
                }

                // Get headshot - use MLB ID to construct URL if headshot_url is missing
                let headshot = player.headshot_url;
                if (!headshot && player.mlb_id) {
                    headshot = `https://img.mlbstatic.com/mlb-photos/image/upload/d_people:generic:headshot:67:current.png/w_213,q_auto:best/v1/people/${player.mlb_id}/headshot/67/current`;
                }
                if (!headshot) {
                    headshot = placeholderImg;
                }

                // Get team display and logo
                const teamDisplay = formatMLBTeamDisplay(player.team || '');
                const mlbLogoUrl = getMLBTeamLogo(player.team || '');
                const mlbLogoHtml = mlbLogoUrl
                    ? `<img src="${mlbLogoUrl}" alt="" class="player-mlb-logo" onerror="this.style.display='none'">`
                    : '';

                // Format position (excluding Util) and get position rank
                const positionDisplay = formatProjectionPosition(player.position, player.name);
                const positionRank = getProjectionPositionRank(player);

                // Use pre-calculated games and PPG
                const projPoints = player.projected_points || 0;
                const games = player.games || 0;
                const ppg = games > 0 ? player.ppg.toFixed(2) : '-';

                // Check if player is kept by someone
                const keeperInfo = getPlayerKeeperInfo(player.name);
                const isKept = keeperInfo !== null;
                
                // Get BPA rank for this player (only when keepers hidden)
                // Use name + type as key to distinguish Ohtani batter from Ohtani pitcher
                const playerNameLower = (player.name || '').toLowerCase().trim();
                const playerType = player.type || 'unknown';
                const bpaKey = `${playerNameLower}|${playerType}`;
                const bpaRank = bpaRankings[bpaKey] || '-';

                // Escape player name for onclick
                const escapedName = player.name.replace(/'/g, "\\'");

                // Add keeper styling
                if (isKept) {
                    row.classList.add('is-keeper');
                }

                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>
                        <div class="player-name-cell" onclick="showProjectionPlayerDetail('${escapedName}')">
                            <img src="${headshot}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                            <div>
                                <div class="player-name">
                                    ${player.name || 'Unknown'}
                                    ${isKept ? '<span class="keeper-badge">K</span>' : ''}
                                </div>
                                <div class="player-mlb-team">${mlbLogoHtml}${teamDisplay}</div>
                                ${isKept ? `<div class="keeper-by-tag">Kept by ${keeperInfo.manager}</div>` : ''}
                            </div>
                        </div>
                    </td>
                    <td>${getPositionBadge(positionDisplay, player.name)}</td>
                    <td class="player-position">${positionRank}</td>
                    <td class="stat-col player-points">${projPoints.toFixed(1)}</td>
                    ${!showKeptPlayers ? `<td class="stat-col bpa-value">${bpaRank}</td>` : ''}
                    <td class="stat-col">${games || '-'}</td>
                    <td class="stat-col">${ppg}</td>
                    ${statsHtml}
                `;

                tbody.appendChild(row);
            });

            countEl.textContent = `${filteredProjections.length} players`;
        }

        // Helper function to check if a player is kept
        function getPlayerKeeperInfo(playerName) {
            if (!keeperSelections || !keeperConfig) return null;

            const normalizedName = playerName.toLowerCase().trim();

            for (const [teamKey, keepers] of Object.entries(keeperSelections)) {
                if (!keepers || !Array.isArray(keepers)) continue;

                const found = keepers.find(k => k.player_name.toLowerCase().trim() === normalizedName);
                if (found) {
                    const teamInfo = keeperConfig.teams[teamKey];
                    const rawManager = teamInfo?.manager || 'Unknown';
                    // Use normalizeManagerName to get consistent manager display
                    const normalizedManager = normalizeManagerName(rawManager, 2026, teamInfo?.team_name || '', teamKey);
                    return {
                        teamKey,
                        manager: normalizedManager,
                        teamName: teamInfo?.team_name || 'Unknown'
                    };
                }
            }

            return null;
        }

        function sortProjectionTable(column) {
            if (projectionSort.column === column) {
                projectionSort.direction = projectionSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                projectionSort.column = column;
                projectionSort.direction = column === 'name' ? 'asc' : 'desc';
            }
            filterProjections();
        }

        function updateProjectionSortIndicators() {
            // 1. Remove indicators from all headers
            document.querySelectorAll('#proj-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // 2. Find the header that matches the current sort column
            const sortCol = projectionSort.column;
            const headers = document.querySelectorAll('#proj-table th');

            headers.forEach(th => {
                const onclick = th.getAttribute('onclick');
                // Check if this header's onclick contains the current sort column name
                if (onclick && onclick.includes(`'${sortCol}'`)) {
                    th.classList.add(projectionSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function exportProjectionsCSV() {
            if (filteredProjections.length === 0) {
                alert('No data to export');
                return;
            }

            let csv = 'Rank,Player,Team,Position,Projected Points\n';

            filteredProjections.forEach((player, index) => {
                csv += `${index + 1},"${player.name}",${player.team},${player.position},${player.projected_points}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'projected_fantasy_points.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function toggleKeptPlayers() {
            showKeptPlayers = !showKeptPlayers;
            const btn = document.getElementById('btn-toggle-kept');

            if (showKeptPlayers) {
                btn.textContent = 'Hide Kept Players';
                // Reset to default style
                btn.style.background = '#e9ecef';
                btn.style.color = '#333';
                btn.style.borderColor = '#ced4da';
            } else {
                btn.textContent = 'Show Kept Players';
                // active style to show filter is on
                btn.style.background = '#6c757d';
                btn.style.color = 'white';
                btn.style.borderColor = '#6c757d';
            }

            // Re-run filter to update table
            filterProjections();
        }

        // ===== KEEPER MANAGEMENT =====

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBDGlo49Hue0-64_kBgDlXuNExtSowCksg",
            authDomain: "fantasy-baseball-civil-war.firebaseapp.com",
            databaseURL: "https://fantasy-baseball-civil-war-default-rtdb.firebaseio.com",
            projectId: "fantasy-baseball-civil-war",
            storageBucket: "fantasy-baseball-civil-war.firebasestorage.app",
            messagingSenderId: "629177123282",
            appId: "1:629177123282:web:f8aac5965be0dea886880b",
            measurementId: "G-FGGY9F6L6C"
        };

        // Initialize Firebase
        let firebaseApp = null;
        let firebaseDb = null;
        let firebaseInitialized = false;

        function updateFirebaseStatus(connected) {
            const statusEl = document.getElementById('firebase-status');
            if (statusEl) {
                if (connected) {
                    statusEl.className = 'firebase-status connected';
                    statusEl.querySelector('.status-text').textContent = 'Live Sync';
                    statusEl.title = 'Connected to real-time database - changes sync automatically';
                } else {
                    statusEl.className = 'firebase-status disconnected';
                    statusEl.querySelector('.status-text').textContent = 'Offline';
                    statusEl.title = 'Not connected - changes saved locally only';
                }
            }
        }

        function initializeFirebase() {
            try {
                if (typeof firebase === 'undefined') {
                    console.error('Firebase SDK not loaded');
                    updateFirebaseStatus(false);
                    return;
                }

                if (!firebaseInitialized) {
                    firebaseApp = firebase.initializeApp(firebaseConfig);
                    firebaseDb = firebase.database();
                    firebaseInitialized = true;
                    console.log('Firebase initialized successfully');

                    // Monitor connection state
                    firebaseDb.ref('.info/connected').on('value', (snapshot) => {
                        const connected = snapshot.val() === true;
                        updateFirebaseStatus(connected);
                        console.log('Firebase connection:', connected ? 'connected' : 'disconnected');
                    });

                    // Set up real-time listener for keeper selections
                    setupKeeperListener();
                }
            } catch (e) {
                console.error('Firebase initialization error:', e);
                updateFirebaseStatus(false);
            }
        }

        // Listen for real-time keeper updates from Firebase
        function setupKeeperListener() {
            if (!firebaseDb) return;

            const keepersRef = firebaseDb.ref('keepers_2026');
            keepersRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    // Merge Firebase data with local selections
                    // Firebase data takes precedence except for current user's team
                    const currentTeamData = currentKeeperTeam ? keeperSelections[currentKeeperTeam] : null;

                    keeperSelections = {};
                    Object.entries(data).forEach(([sanitizedKey, keepers]) => {
                        // Convert sanitized key back to original format (underscores to dots)
                        const teamKey = unsanitizeFirebaseKey(sanitizedKey);
                        // Convert Firebase format (may have numeric keys) to array
                        if (Array.isArray(keepers)) {
                            keeperSelections[teamKey] = keepers;
                        } else if (keepers && typeof keepers === 'object') {
                            keeperSelections[teamKey] = Object.values(keepers);
                        }
                    });

                    // Restore current user's unsaved changes if they're in the modal
                    if (currentTeamData && currentKeeperTeam) {
                        // Only restore if modal is open and user has unsaved changes
                        const modal = document.getElementById('keeper-modal');
                        if (modal && modal.style.display === 'flex') {
                            keeperSelections[currentKeeperTeam] = currentTeamData;
                        }
                    }

                    console.log('Keeper data updated from Firebase');
                    displayLeagueKeepers();
                }
            }, (error) => {
                console.error('Firebase listener error:', error);
            });
        }

        // Save keeper selections to Firebase
        // Firebase paths can't contain ".", "#", "$", "[", or "]" so we sanitize team keys
        function sanitizeFirebaseKey(key) {
            return key.replace(/\./g, '_');
        }

        function unsanitizeFirebaseKey(key) {
            return key.replace(/_/g, '.');
        }

        async function saveKeepersToFirebase(teamKey, keepers) {
            console.log('saveKeepersToFirebase called, firebaseDb:', !!firebaseDb, 'firebaseInitialized:', firebaseInitialized);

            if (!firebaseDb) {
                console.log('Firebase not initialized, saving to localStorage only');
                return false;
            }

            try {
                const sanitizedKey = sanitizeFirebaseKey(teamKey);
                console.log('Attempting to save to Firebase:', sanitizedKey, keepers);
                await firebaseDb.ref(`keepers_2026/${sanitizedKey}`).set(keepers);
                console.log(`Successfully saved keepers for ${teamKey} to Firebase`);
                return true;
            } catch (e) {
                console.error('Error saving to Firebase:', e);
                return false;
            }
        }

        let keeperConfig = null;
        let keeperSelections = {};
        let currentKeeperTeam = null;
        let keeperRosterData = [];
        let keeperProjectionsMap = {};
        let keeperDraftData = {}; // Store draft data for cost calculations
        let showTradedPicks = false; // Toggle state for showing traded picks (default hidden)
        let showLeagueProspects = false; // Toggle state for showing prospects in league keepers (default hidden)
        const KEEPER_BUDGET = 50; // $50 per team

        // Password hashing function (simple SHA-256)
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Calculate dollar cost based on draft round
        function getKeeperDollarCost(draftRound) {
            if (!draftRound || draftRound < 1) return 1; // Undrafted players cost $1
            // Round 1 = $20, Round 2 = $19, ... Round 20+ = $1
            return Math.max(1, 21 - draftRound);
        }

        // Calculate next year's draft round cost for keeping a player
        function getKeeperRoundCost(previousRound, totalRounds = 20) {
            if (!previousRound || previousRound < 1) return totalRounds; // Undrafted costs last round
            // Rounds 1-3: costs a 1st rounder
            if (previousRound <= 3) return 1;
            // Rounds 4-10: costs 3 rounds earlier
            if (previousRound <= 10) return previousRound - 3;
            // Rounds 11+: costs 4 rounds earlier
            return Math.max(1, previousRound - 4);
        }

        // Get the total number of rounds in the draft
        function getTotalDraftRounds() {
            if (!keeperDraftData || !keeperDraftData.length) return 20; // Default
            return Math.max(...keeperDraftData.map(p => p.round || 0));
        }

        // Get player's draft info from 2025
        function getPlayerDraftInfo(playerName) {
            const totalRounds = getTotalDraftRounds();

            if (!keeperDraftData || !keeperDraftData.length) {
                // No draft data available, return undrafted defaults
                return {
                    round: null,
                    pick: null,
                    team_key: null,
                    dollarCost: 1,
                    roundCost: totalRounds,
                    isUndrafted: true
                };
            }

            const normalizedName = playerName.toLowerCase().trim();
            const pick = keeperDraftData.find(p =>
                p.player_name && p.player_name.toLowerCase().trim() === normalizedName
            );

            if (pick) {
                return {
                    round: pick.round,
                    pick: pick.pick,
                    team_key: pick.team_key,
                    dollarCost: getKeeperDollarCost(pick.round),
                    roundCost: getKeeperRoundCost(pick.round, totalRounds),
                    isUndrafted: false
                };
            }

            // Player was not drafted (free agent pickup)
            return {
                round: null,
                pick: null,
                team_key: null,
                dollarCost: 1, // Undrafted costs $1
                roundCost: totalRounds, // Undrafted costs last round
                isUndrafted: true
            };
        }

        // Calculate the actual round costs for a team's keepers, handling multiple last-round picks
        // This now considers traded picks - if you traded for extra round 22 picks, you can use them
        function calculateTeamKeeperRoundCosts(teamKey) {
            const allKeepers = keeperSelections[teamKey] || [];
            if (allKeepers.length === 0) return [];

            // Filter out prospects - they don't use draft picks
            const keepers = allKeepers.filter(k => !k.isProspect);
            if (keepers.length === 0) return [];

            const totalRounds = getTotalDraftRounds();

            // Get the team's available picks (including traded picks)
            const ownedPicks = getTeamPicks(teamKey);

            console.log('=== calculateTeamKeeperRoundCosts DEBUG ===');
            console.log('Team:', teamKey);
            console.log('Keepers:', keepers.map(k => `${k.player_name} (baseRoundCost: ${k.roundCost})`));
            console.log('Owned picks:', ownedPicks.map(p => `Rd ${p.round}`).join(', '));

            // Build a count of how many picks the team has at each round
            const pickCounts = {};
            ownedPicks.forEach(pick => {
                pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
            });

            console.log('Pick counts by round:', pickCounts);

            // Get base round costs for each keeper (excluding prospects)
            let roundCosts = keepers.map(k => ({
                player_name: k.player_name,
                baseRoundCost: k.roundCost || totalRounds,
                isUndrafted: k.isUndrafted || false
            }));

            // Sort by round cost (highest/latest rounds first for undrafted)
            roundCosts.sort((a, b) => b.baseRoundCost - a.baseRoundCost);

            console.log('Sorted keepers (highest round first):', roundCosts.map(k => `${k.player_name} (${k.baseRoundCost})`));

            // Track used picks at each round
            const usedPicksAtRound = {};

            // Get sorted list of rounds we actually have picks in
            const ownedRounds = [...new Set(ownedPicks.map(p => p.round))].sort((a, b) => b - a);

            // Assign actual rounds, using available picks
            roundCosts.forEach(keeper => {
                let assignedRound = keeper.baseRoundCost;

                // Initialize used count for this round
                if (!usedPicksAtRound[assignedRound]) {
                    usedPicksAtRound[assignedRound] = 0;
                }

                // Check if we have an available pick at this round
                const availableAtRound = (pickCounts[assignedRound] || 0) - (usedPicksAtRound[assignedRound] || 0);

                if (availableAtRound > 0) {
                    // We have an available pick at this round
                    usedPicksAtRound[assignedRound]++;
                } else {
                    // Need to find the next available round going backwards (earlier in draft)
                    // Only consider rounds where we actually have picks
                    let foundRound = false;

                    // Filter to rounds earlier than the base cost and sort descending (latest first)
                    const eligibleRounds = ownedRounds.filter(r => r < assignedRound);

                    for (const round of eligibleRounds) {
                        if (!usedPicksAtRound[round]) {
                            usedPicksAtRound[round] = 0;
                        }
                        const available = (pickCounts[round] || 0) - usedPicksAtRound[round];
                        if (available > 0) {
                            assignedRound = round;
                            usedPicksAtRound[round]++;
                            foundRound = true;
                            break;
                        }
                    }

                    // If no earlier round found, try any available round we own
                    if (!foundRound) {
                        for (const round of ownedRounds) {
                            if (!usedPicksAtRound[round]) {
                                usedPicksAtRound[round] = 0;
                            }
                            const available = (pickCounts[round] || 0) - usedPicksAtRound[round];
                            if (available > 0) {
                                assignedRound = round;
                                usedPicksAtRound[round]++;
                                foundRound = true;
                                break;
                            }
                        }
                    }

                    // If still no round found (shouldn't happen normally), mark as needing a pick
                    if (!foundRound) {
                        assignedRound = null; // No pick available
                    }
                }

                keeper.actualRoundCost = assignedRound;
                console.log(`  ${keeper.player_name}: base=${keeper.baseRoundCost} -> actual=${assignedRound}`);
            });

            console.log('Final assignments:', roundCosts.map(k => `${k.player_name}: Rd ${k.actualRoundCost}`));
            console.log('=== END DEBUG ===');

            return roundCosts;
        }

        // Calculate total budget used by a team's keepers
        function calculateTeamBudgetUsed(teamKey) {
            const keepers = keeperSelections[teamKey] || [];
            // Only count non-prospect keepers, and use 0 for prospects
            return keepers.reduce((total, k) => {
                if (k.isProspect) return total; // Prospects are free
                return total + (k.dollarCost !== undefined ? k.dollarCost : 1);
            }, 0);
        }

        async function initializeKeeperManagement() {
            try {
                // Initialize Firebase first
                initializeFirebase();

                // Load keeper config
                const configResponse = await fetch('data/keepers/keeper_config.json');
                if (configResponse.ok) {
                    keeperConfig = await configResponse.json();
                } else {
                    // Generate default config from current teams
                    await generateDefaultKeeperConfig();
                }

                // Load 2025 draft data for cost calculations
                try {
                    const draftResponse = await fetch('data/historical/2025/draft.json');
                    if (draftResponse.ok) {
                        keeperDraftData = await draftResponse.json();
                        console.log(`Loaded ${keeperDraftData.length} draft picks for keeper costs`);
                    }
                } catch (e) {
                    console.log('Could not load draft data for keeper costs');
                }

                // Load existing keeper selections from Firebase (primary) or fallback to JSON file
                if (firebaseDb) {
                    try {
                        const snapshot = await firebaseDb.ref('keepers_2026').once('value');
                        const data = snapshot.val();
                        if (data) {
                            Object.entries(data).forEach(([sanitizedKey, keepers]) => {
                                // Convert sanitized key back to original format
                                const teamKey = unsanitizeFirebaseKey(sanitizedKey);
                                if (Array.isArray(keepers)) {
                                    keeperSelections[teamKey] = keepers;
                                } else if (keepers && typeof keepers === 'object') {
                                    keeperSelections[teamKey] = Object.values(keepers);
                                }
                            });
                            console.log('Loaded keeper selections from Firebase');
                        }
                    } catch (e) {
                        console.log('Could not load from Firebase, trying JSON file:', e);
                    }
                }

                // Fallback: Load from JSON file if Firebase is empty or unavailable
                if (Object.keys(keeperSelections).length === 0) {
                    try {
                        const selectionsResponse = await fetch('data/keepers/keepers_2026.json');
                        if (selectionsResponse.ok) {
                            const data = await selectionsResponse.json();
                            keeperSelections = data.keepers || {};
                            console.log('Loaded keeper selections from JSON file');
                        }
                    } catch (e) {
                        console.log('No JSON keeper file found');
                    }
                }

                // Populate team selector
                populateKeeperTeamSelect();

                // Load and display league keepers
                displayLeagueKeepers();

                // Build projections lookup map
                const allProj = [...allProjectionBatters, ...allProjectionPitchers];
                allProj.forEach(p => {
                    const normalizedName = p.name.toLowerCase().trim();
                    keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                });

            } catch (e) {
                console.log('Error initializing keeper management:', e);
            }
        }

        async function generateDefaultKeeperConfig() {
            // Load teams from 2026 (current season) for logos
            let teams = await getTeamData(2026);
            
            // Fallback to 2025 if 2026 not available
            if (!teams || teams.length === 0) {
                teams = await getTeamData(2025);
            }
            if (!teams) return;

            // Load manager history to get join years
            let managerJoinYears = {};
            try {
                const historyResponse = await fetch('data/managers/manager_history.json');
                if (historyResponse.ok) {
                    const history = await historyResponse.json();
                    history.forEach(manager => {
                        if (manager.seasons && manager.seasons.length > 0) {
                            const firstYear = Math.min(...manager.seasons.map(s => s.year));
                            managerJoinYears[manager.manager_name] = firstYear;
                        }
                    });
                }
            } catch (e) {
                console.log('Could not load manager history');
            }

            keeperConfig = {
                season: 2026,
                max_keepers: 5,
                deadline: "2026-03-15T23:59:59",
                teams: {}
            };

            for (const team of teams) {
                const joinYear = managerJoinYears[team.manager] || 2020;
                const password = `${team.manager}${joinYear}`;
                const passwordHash = await hashPassword(password);

                keeperConfig.teams[team.team_key] = {
                    team_name: team.team_name,
                    manager: team.manager,
                    password_hash: passwordHash,
                    team_logo: fixTeamLogo(team.team_logo),
                    keepers_locked: false
                };
            }
        }

        function populateKeeperTeamSelect() {
            const select = document.getElementById('keeper-team-select');
            if (!keeperConfig || !keeperConfig.teams) return;

            select.innerHTML = '<option value="">-- Select Team --</option>';

            // Sort teams by manager name
            const sortedTeams = Object.entries(keeperConfig.teams)
                .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

            for (const [teamKey, teamInfo] of sortedTeams) {
                const option = document.createElement('option');
                option.value = teamKey;
                option.textContent = `${capitalizeManagerName(teamInfo.manager)} - ${teamInfo.team_name}`;
                select.appendChild(option);
            }
        }

        function onKeeperTeamSelect() {
            const select = document.getElementById('keeper-team-select');
            const passwordField = document.getElementById('keeper-password-field');
            const errorEl = document.getElementById('keeper-auth-error');

            errorEl.style.display = 'none';

            if (select.value) {
                passwordField.style.display = 'flex';
                document.getElementById('keeper-password').value = '';
                document.getElementById('keeper-password').focus();
            } else {
                passwordField.style.display = 'none';
            }
        }

        async function authenticateKeeper() {
            const teamKey = document.getElementById('keeper-team-select').value;
            const password = document.getElementById('keeper-password').value;
            const errorEl = document.getElementById('keeper-auth-error');

            if (!teamKey || !password) {
                errorEl.textContent = 'Please select a team and enter your password.';
                errorEl.style.display = 'block';
                return;
            }

            const teamInfo = keeperConfig.teams[teamKey];
            if (!teamInfo) {
                errorEl.textContent = 'Invalid team selection.';
                errorEl.style.display = 'block';
                return;
            }

            // Hash the entered password and compare
            const enteredHash = await hashPassword(password);

            if (enteredHash !== teamInfo.password_hash) {
                errorEl.textContent = 'Incorrect password. Hint: [YourName][YearJoined]';
                errorEl.style.display = 'block';
                return;
            }

            // Authentication successful
            currentKeeperTeam = teamKey;
            errorEl.style.display = 'none';

            // Hide auth section, show selection section
            document.getElementById('keeper-modal-auth').style.display = 'none';
            document.getElementById('keeper-modal-selection').style.display = 'flex';
            
            // Remove auth-view class to expand modal for selection view
            document.querySelector('.keeper-modal-content').classList.remove('auth-view');

            // Update header with team name and logo
            document.getElementById('keeper-current-team').textContent = `${teamInfo.team_name}`;

            // Update budget display with team's actual budget
            const teamBudget = typeof getTeamBudget === 'function' ? getTeamBudget(teamKey) : KEEPER_BUDGET;
            const budgetDisplay = document.getElementById('keeper-budget-display');
            if (budgetDisplay) {
                budgetDisplay.textContent = `$${teamBudget}`;
            }

            // Set team logo
            const logoEl = document.getElementById('keeper-team-logo');
            if (teamInfo.team_logo) {
                logoEl.src = fixTeamLogo(teamInfo.team_logo);
                logoEl.style.display = 'block';
            } else {
                logoEl.style.display = 'none';
            }

            // Load roster and display
            await loadKeeperRoster(teamKey);
            updateKeeperStatus();
            updateKeeperSelectedSummary();
        }

        function logoutKeeper() {
            currentKeeperTeam = null;
            document.getElementById('keeper-modal-auth').style.display = 'block';
            document.getElementById('keeper-modal-selection').style.display = 'none';
            document.getElementById('keeper-team-select').value = '';
            document.getElementById('keeper-password-field').style.display = 'none';
            document.getElementById('keeper-password').value = '';
            document.getElementById('keeper-auth-error').style.display = 'none';
            
            // Add auth-view class back for smaller modal
            document.querySelector('.keeper-modal-content').classList.add('auth-view');
        }

        function openKeeperModal() {
            // Initialize if needed
            if (!keeperConfig) {
                initializeKeeperManagement();
            }

            // Reset to auth view
            document.getElementById('keeper-modal-auth').style.display = 'block';
            document.getElementById('keeper-modal-selection').style.display = 'none';
            document.getElementById('keeper-team-select').value = '';
            document.getElementById('keeper-password-field').style.display = 'none';
            document.getElementById('keeper-password').value = '';
            document.getElementById('keeper-auth-error').style.display = 'none';
            
            // Add auth-view class for smaller modal
            document.querySelector('.keeper-modal-content').classList.add('auth-view');

            // Show modal and prevent background scroll
            document.getElementById('keeper-modal').classList.add('active');
            document.body.classList.add('keeper-modal-open');
        }

        function closeKeeperModal() {
            document.getElementById('keeper-modal').classList.remove('active');
            document.body.classList.remove('keeper-modal-open');
            logoutKeeper();
        }

        // Close keeper modal on outside click
        document.getElementById('keeper-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeKeeperModal();
            }
        });

        async function loadKeeperRoster(teamKey) {
            const loadingEl = document.getElementById('keeper-roster-loading');
            const tbody = document.getElementById('keeper-roster-body');

            loadingEl.style.display = 'block';
            tbody.innerHTML = '';

            // Debug: log current keeper selections for this team
            console.log('Loading roster for team:', teamKey);
            console.log('Current keeperSelections for this team:', keeperSelections[teamKey]);

            try {
                // Load 2025 player stats to get roster
                const response = await fetch('data/historical/2025/player_stats.json');
                if (!response.ok) throw new Error('Could not load player data');

                const allPlayers = await response.json();

                // Filter to just this team's players
                keeperRosterData = allPlayers.filter(p => p.team_key === teamKey);

                // Load projections if not already loaded - use same format as main projections
                if (Object.keys(keeperProjectionsMap).length === 0) {
                    try {
                        // First check if allProjectionBatters/Pitchers are already loaded
                        if (allProjectionBatters.length > 0 || allProjectionPitchers.length > 0) {
                            [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                                const normalizedName = p.name.toLowerCase().trim();
                                keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                            });
                            console.log(`Loaded ${Object.keys(keeperProjectionsMap).length} projections from global data`);
                        } else {
                            // Load from projections file directly
                            const projResponse = await fetch('data/projections/projections_thebat.json');
                            if (projResponse.ok) {
                                const projData = await projResponse.json();
                                const batters = projData.batters || [];
                                const pitchers = projData.pitchers || [];
                                [...batters, ...pitchers].forEach(p => {
                                    const normalizedName = p.name.toLowerCase().trim();
                                    keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                                });
                                console.log(`Loaded ${Object.keys(keeperProjectionsMap).length} projections from file`);
                            }
                        }
                    } catch (e) {
                        console.log('Could not load projections:', e);
                    }
                }

                // Load player history data if not already loaded (for prospect determination)
                if (Object.keys(playerHistoryData).length === 0) {
                    try {
                        const historyResponse = await fetch('data/players/player_history.json');
                        if (historyResponse.ok) {
                            playerHistoryData = await historyResponse.json();
                            console.log(`Loaded player history for ${Object.keys(playerHistoryData).length} players`);
                        }
                    } catch (e) {
                        console.log('Could not load player history:', e);
                    }
                }

                // Sort by fantasy points descending
                keeperRosterData.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));

                // Get current keeper selections for this team
                const teamKeepers = keeperSelections[teamKey] || [];
                const keeperNames = teamKeepers.map(k => k.player_name.toLowerCase());

                // Render roster
                keeperRosterData.forEach((player, index) => {
                    const isKept = keeperNames.includes(player.name.toLowerCase());
                    const projPts = keeperProjectionsMap[player.name.toLowerCase().trim()];
                    const projDisplay = typeof projPts === 'number' ? projPts.toFixed(1) : '-';

                    // Get draft info and costs
                    const draftInfo = getPlayerDraftInfo(player.name);
                    const dollarCost = draftInfo ? draftInfo.dollarCost : 1;
                    const roundCost = draftInfo ? draftInfo.roundCost : getTotalDraftRounds();
                    const draftRound = draftInfo && draftInfo.round ? draftInfo.round : 99;
                    const draftRoundDisplay = draftInfo && draftInfo.round ? `Rd ${draftInfo.round}` : 'FA';
                    const isUndrafted = draftInfo ? draftInfo.isUndrafted : true;

                    // Check if player qualifies as a prospect (free keeper)
                    // Must be undrafted AND have limited playing time AND no previous season history
                    const stats = player.stats || {};
                    const isPitcher = ['SP', 'RP', 'P'].includes(player.primary_position);
                    const hasLimitedTime = isPitcher
                        ? (stats.IP || 0) < 50
                        : (stats.AB || 0) < 130;

                    // Check if player has any previous season history in the league WITH points scored
                    const normalizedName = player.name.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    const playerHistory = playerHistoryData[normalizedName];
                    const hasPreviousSeasons = playerHistory && playerHistory.seasons &&
                        playerHistory.seasons.some(s => s.year < 2025 && (s.fantasy_points || 0) > 0);

                    // Only a prospect if undrafted, limited time, AND no previous seasons with points
                    const isProspect = isUndrafted && hasLimitedTime && !hasPreviousSeasons;

                    const row = document.createElement('tr');
                    row.className = isKept ? 'is-keeper' : '';
                    if (isProspect) row.classList.add('is-prospect');
                    row.dataset.playerName = player.name;
                    row.dataset.dollarCost = isProspect ? 0 : dollarCost;
                    row.dataset.roundCost = isProspect ? 0 : roundCost;
                    row.dataset.pts2025 = player.fantasy_points || 0;
                    row.dataset.pts2026 = projPts || 0;
                    row.dataset.position = player.primary_position || '';
                    row.dataset.drafted = draftRound;
                    row.dataset.isProspect = isProspect ? '1' : '0';
                    
                    // Calculate expected points for round and keeper value
                    // Value formula matches Value Suite: value = projectedPts + (projectedPts - expectedPts)
                    const rdExpPts = isProspect ? 0 : getExpectedPointsForRound(roundCost);
                    const surplusValue = isProspect ? (projPts || 0) : ((projPts || 0) - rdExpPts);
                    const keeperValue = isProspect ? (projPts || 0) : ((projPts || 0) + surplusValue);
                    row.dataset.rdexp = rdExpPts;
                    row.dataset.value = keeperValue;

                    const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
                    const headshot = player.headshot_url || placeholderImg;

                    // Display cost info - prospects are free
                    const rdCostDisplay = isProspect ? '<span class="keeper-round-cost prospect-free">Free</span>' : `<span class="keeper-round-cost">Rd ${roundCost}</span>`;
                    const dollarCostDisplay = isProspect ? '<span class="keeper-dollar-cost prospect-free">$0</span>' : `<span class="keeper-dollar-cost">$${dollarCost}</span>`;
                    
                    // Display expected points and value
                    // Color based on surplusValue (above/below expected), display keeperValue
                    const rdExpDisplay = isProspect ? '-' : rdExpPts.toFixed(0);
                    const valueDisplay = keeperValue.toFixed(0);
                    const valueClass = surplusValue > 0 ? 'value-positive' : (surplusValue < 0 ? 'value-negative' : '');

                    row.innerHTML = `
                        <td style="text-align: center;">
                            <input type="checkbox" class="keeper-checkbox" 
                                   ${isKept ? 'checked' : ''} 
                                   onchange="toggleKeeper('${player.name.replace(/'/g, "\\'")}', this.checked)">
                        </td>
                        <td>
                            <div class="player-name-cell">
                                <img src="${headshot}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                                <span class="player-name">${player.name}</span>
                                ${isKept ? '<span class="keeper-badge">K</span>' : ''}
                                ${isProspect ? '<span class="prospect-badge">P</span>' : ''}
                            </div>
                        </td>
                        <td>${getPositionBadge(player.primary_position || '-', player.name)}</td>
                        <td class="stat-col">${(player.fantasy_points || 0).toFixed(1)}</td>
                        <td class="stat-col"><em>${projDisplay}</em></td>
                        <td class="keeper-cost-col">
                            <span class="keeper-draft-round">${draftRoundDisplay}</span>
                        </td>
                        <td class="keeper-cost-col">
                            ${rdCostDisplay}
                        </td>
                        <td class="keeper-cost-col">
                            <span class="keeper-rdexp">${rdExpDisplay}</span>
                        </td>
                        <td class="keeper-cost-col">
                            <span class="keeper-value ${valueClass}">${valueDisplay}</span>
                        </td>
                        <td class="keeper-cost-col">
                            ${dollarCostDisplay}
                        </td>
                    `;

                    tbody.appendChild(row);
                });

                loadingEl.style.display = 'none';

                // Update the draft picks display
                updateKeeperPicksDisplay();

                // Setup sortable columns
                setupKeeperTableSort();

            } catch (e) {
                console.error('Error loading roster:', e);
                loadingEl.style.display = 'none';
                tbody.innerHTML = '<tr><td colspan="10" style="text-align: center; color: #888;">Could not load roster</td></tr>';
            }
        }

        let keeperSortColumn = 'pts2025';
        let keeperSortDirection = 'desc';

        function setupKeeperTableSort() {
            const headers = document.querySelectorAll('#keeper-roster-table th.sortable');
            headers.forEach(th => {
                th.style.cursor = 'pointer';
                th.onclick = () => sortKeeperTable(th.dataset.sort);
            });
        }

        function sortKeeperTable(column) {
            const tbody = document.getElementById('keeper-roster-body');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Toggle direction if same column
            if (keeperSortColumn === column) {
                keeperSortDirection = keeperSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                keeperSortColumn = column;
                keeperSortDirection = 'desc';
            }

            // Update header indicators
            document.querySelectorAll('#keeper-roster-table th.sortable').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sort === column) {
                    th.classList.add(keeperSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });

            rows.sort((a, b) => {
                let aVal, bVal;

                if (column === 'name') {
                    aVal = a.dataset.playerName.toLowerCase();
                    bVal = b.dataset.playerName.toLowerCase();
                    return keeperSortDirection === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else if (column === 'position') {
                    aVal = a.dataset.position;
                    bVal = b.dataset.position;
                    return keeperSortDirection === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else if (column === 'pts2025') {
                    aVal = parseFloat(a.dataset.pts2025) || 0;
                    bVal = parseFloat(b.dataset.pts2025) || 0;
                } else if (column === 'pts2026') {
                    aVal = parseFloat(a.dataset.pts2026) || 0;
                    bVal = parseFloat(b.dataset.pts2026) || 0;
                } else if (column === 'drafted') {
                    aVal = parseFloat(a.dataset.drafted) || 99;
                    bVal = parseFloat(b.dataset.drafted) || 99;
                } else if (column === 'rdcost') {
                    aVal = parseFloat(a.dataset.roundCost) || 99;
                    bVal = parseFloat(b.dataset.roundCost) || 99;
                } else if (column === 'rdexp') {
                    aVal = parseFloat(a.dataset.rdexp) || 0;
                    bVal = parseFloat(b.dataset.rdexp) || 0;
                } else if (column === 'value') {
                    aVal = parseFloat(a.dataset.value) || 0;
                    bVal = parseFloat(b.dataset.value) || 0;
                } else if (column === 'cost') {
                    aVal = parseFloat(a.dataset.dollarCost) || 0;
                    bVal = parseFloat(b.dataset.dollarCost) || 0;
                }

                if (keeperSortDirection === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        function toggleKeeper(playerName, isKeeping) {
            if (!currentKeeperTeam) return;

            // Initialize array if needed
            if (!keeperSelections[currentKeeperTeam]) {
                keeperSelections[currentKeeperTeam] = [];
            }

            const teamKeepers = keeperSelections[currentKeeperTeam];
            const existingIndex = teamKeepers.findIndex(k => k.player_name.toLowerCase() === playerName.toLowerCase());

            if (isKeeping) {
                // Get player data to check prospect status
                const player = keeperRosterData.find(p => p.name === playerName);
                const draftInfo = getPlayerDraftInfo(playerName);
                const isUndrafted = draftInfo ? draftInfo.isUndrafted : true;

                // Check if player qualifies as a prospect (free keeper)
                const stats = player?.stats || {};
                const isPitcher = ['SP', 'RP', 'P'].includes(player?.primary_position);
                const hasLimitedTime = isPitcher
                    ? (stats.IP || 0) < 50
                    : (stats.AB || 0) < 130;

                // Check if player has any previous season history in the league WITH points scored
                const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                const playerHistory = playerHistoryData[normalizedName];
                const hasPreviousSeasons = playerHistory && playerHistory.seasons &&
                    playerHistory.seasons.some(s => s.year < 2025 && (s.fantasy_points || 0) > 0);

                // Only a prospect if undrafted, limited time, AND no previous seasons with points
                const isProspect = isUndrafted && hasLimitedTime && !hasPreviousSeasons;

                // Prospects are free - no dollar or round cost
                const dollarCost = isProspect ? 0 : (draftInfo ? draftInfo.dollarCost : 1);
                const roundCost = isProspect ? 0 : (draftInfo ? draftInfo.roundCost : getTotalDraftRounds());

                // Check budget (only for non-prospects)
                if (!isProspect) {
                    const currentBudgetUsed = calculateTeamBudgetUsed(currentKeeperTeam);
                    const teamTotalBudget = getTeamBudget ? getTeamBudget(currentKeeperTeam) : KEEPER_BUDGET;
                    if (currentBudgetUsed + dollarCost > teamTotalBudget) {
                        alert(`Adding this player would exceed your keeper budget.\n\nYour Budget: $${teamTotalBudget}\nCurrently Used: $${currentBudgetUsed}\nThis player: $${dollarCost}\nTotal would be: $${currentBudgetUsed + dollarCost}`);
                        // Uncheck box
                        const row = document.querySelector(`tr[data-player-name="${playerName}"]`);
                        if (row) {
                            row.querySelector('.keeper-checkbox').checked = false;
                        }
                        return;
                    }

                    // Check if there's an available pick at or before the required round
                    const canKeepResult = canKeepPlayerWithPick(playerName, roundCost);
                    if (!canKeepResult.canKeep) {
                        alert(`Cannot keep ${playerName}.\n\n${canKeepResult.reason}\n\nYou need a pick in round ${roundCost} or earlier to keep this player.`);
                        // Uncheck box
                        const row = document.querySelector(`tr[data-player-name="${playerName}"]`);
                        if (row) {
                            row.querySelector('.keeper-checkbox').checked = false;
                        }
                        return;
                    }
                }

                // Add keeper with cost info
                if (existingIndex === -1) {
                    teamKeepers.push({
                        player_name: playerName,
                        player_id: player?.player_key || '',
                        position: player?.primary_position || '',
                        fantasy_points_2025: player?.fantasy_points || 0,
                        dollarCost: dollarCost,
                        roundCost: roundCost,
                        draftRound: draftInfo?.round || null,
                        isUndrafted: isUndrafted,
                        isProspect: isProspect
                    });
                }
            } else {
                // Remove keeper
                if (existingIndex !== -1) {
                    teamKeepers.splice(existingIndex, 1);
                }
            }

            // Trigger updates immediately
            updateKeeperRosterDisplay();
            updateKeeperStatus();
            updateKeeperSelectedSummary();
        }

        // Check if a player can be kept given their round cost and current keeper selections
        function canKeepPlayerWithPick(playerName, requiredRound) {
            const teamPicks = getTeamPicks(currentKeeperTeam);
            const currentKeepers = (keeperSelections[currentKeeperTeam] || []).filter(k => !k.isProspect);

            console.log('canKeepPlayerWithPick:', playerName, 'requiredRound:', requiredRound);
            console.log('Current keepers for team:', currentKeepers.map(k => `${k.player_name} (Rd ${k.roundCost})`));
            console.log('Team picks:', teamPicks.map(p => `Rd ${p.round}`));

            // Check if we have at least one pick at or before the required round
            const eligiblePicksForNewPlayer = teamPicks.filter(p => p.round <= requiredRound);

            if (eligiblePicksForNewPlayer.length === 0) {
                return {
                    canKeep: false,
                    reason: `You don't have any draft picks in rounds 1-${requiredRound}.`
                };
            }

            // Count ALL picks (not just eligible ones) - keepers use their own round cost picks
            const pickCounts = {};
            teamPicks.forEach(pick => {
                pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
            });

            // Get all current keepers plus the new player we're trying to add
            const keeperRoundCosts = currentKeepers.map(k => ({
                player_name: k.player_name,
                roundCost: k.roundCost
            }));

            // Add the new player we're trying to keep
            keeperRoundCosts.push({
                player_name: playerName,
                roundCost: requiredRound
            });

            // Sort by round cost descending (latest rounds first - they get assigned first)
            keeperRoundCosts.sort((a, b) => b.roundCost - a.roundCost);

            console.log('Attempting to assign keepers:', keeperRoundCosts.map(k => `${k.player_name} (Rd ${k.roundCost})`));

            // Track used picks at each round
            const usedPicksAtRound = {};

            // Try to assign each keeper to a pick
            for (const keeper of keeperRoundCosts) {
                let assigned = false;

                // Try to find an available pick at the keeper's round cost first, then work backwards
                for (let round = keeper.roundCost; round >= 1; round--) {
                    const available = (pickCounts[round] || 0) - (usedPicksAtRound[round] || 0);
                    if (available > 0) {
                        usedPicksAtRound[round] = (usedPicksAtRound[round] || 0) + 1;
                        assigned = true;
                        console.log(`  ${keeper.player_name} (needs Rd ${keeper.roundCost}) -> assigned to Rd ${round}`);
                        break;
                    }
                }

                if (!assigned) {
                    if (keeper.player_name === playerName) {
                        // This is the player we're trying to add and they couldn't be assigned
                        const usedRounds = Object.entries(usedPicksAtRound)
                            .filter(([r, c]) => c > 0)
                            .map(([r]) => `Rd ${r}`)
                            .join(', ');

                        return {
                            canKeep: false,
                            reason: `All your available picks in rounds 1-${requiredRound} are already being used by other keepers${usedRounds ? ` (${usedRounds})` : ''}.`
                        };
                    } else {
                        // An existing keeper couldn't be assigned - this shouldn't happen if data is valid
                        console.warn(`Warning: Existing keeper ${keeper.player_name} couldn't be assigned a pick`);
                    }
                }
            }

            return { canKeep: true };
        }

        function updateKeeperStatus() {
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];
            const statusEl = document.getElementById('keeper-status');
            const barEl = document.getElementById('keeper-progress-bar');

            // Calculate budget used and team's total budget (may be affected by trades)
            const budgetUsed = calculateTeamBudgetUsed(currentKeeperTeam);
            const teamTotalBudget = getTeamBudget ? getTeamBudget(currentKeeperTeam) : KEEPER_BUDGET;
            const budgetRemaining = teamTotalBudget - budgetUsed;

            // Count prospects vs regular keepers
            const prospectCount = teamKeepers.filter(k => k.isProspect).length;
            const regularCount = teamKeepers.filter(k => !k.isProspect).length;

            // Update status text to show budget and prospect count
            let statusText = `$${budgetUsed} / $${teamTotalBudget} used (${regularCount} keeper${regularCount !== 1 ? 's' : ''})`;
            if (prospectCount > 0) {
                statusText += ` + ${prospectCount} prospect${prospectCount !== 1 ? 's' : ''}`;
            }
            statusEl.textContent = statusText;

            // Update progress bar based on budget
            if (barEl) {
                const percentage = teamTotalBudget > 0 ? Math.min((budgetUsed / teamTotalBudget) * 100, 100) : 0;
                barEl.style.width = percentage + '%';

                // Add/remove full class for color change
                if (budgetUsed >= teamTotalBudget) {
                    barEl.classList.add('full');
                    statusEl.classList.add('full');
                } else {
                    barEl.classList.remove('full');
                    statusEl.classList.remove('full');
                }
            }
        }

        function saveKeeperSelections() {
            // Save current team's selections to localStorage
            const localData = JSON.parse(localStorage.getItem('keeper_selections_2026') || '{}');
            localData[currentKeeperTeam] = keeperSelections[currentKeeperTeam];
            localStorage.setItem('keeper_selections_2026', JSON.stringify(localData));
        }

        async function clearKeeperCache() {
            // Show current state before clearing
            const localData = localStorage.getItem('keeper_selections_2026');
            console.log('=== BEFORE CLEAR ===');
            console.log('localStorage keeper_selections_2026:', localData);
            console.log('In-memory keeperSelections:', JSON.stringify(keeperSelections, null, 2));

            if (!confirm('This will clear all locally cached keeper data and reload from Firebase. Continue?')) {
                return;
            }

            // Clear localStorage
            localStorage.removeItem('keeper_selections_2026');
            console.log('Cleared keeper_selections_2026 from localStorage');

            // Reset in-memory data
            keeperSelections = {};

            // Reload from Firebase
            if (firebaseDb) {
                try {
                    const snapshot = await firebaseDb.ref('keepers_2026').once('value');
                    const data = snapshot.val();
                    console.log('Raw Firebase data:', data);
                    if (data) {
                        Object.entries(data).forEach(([sanitizedKey, keepers]) => {
                            const teamKey = unsanitizeFirebaseKey(sanitizedKey);
                            if (Array.isArray(keepers)) {
                                keeperSelections[teamKey] = keepers;
                            } else if (keepers && typeof keepers === 'object') {
                                keeperSelections[teamKey] = Object.values(keepers);
                            }
                        });
                    }
                    console.log('=== AFTER RELOAD ===');
                    console.log('In-memory keeperSelections:', JSON.stringify(keeperSelections, null, 2));
                } catch (e) {
                    console.error('Error reloading from Firebase:', e);
                }
            } else {
                console.log('Firebase not available');
            }

            // Refresh display
            displayLeagueKeepers();

            alert(' Cache cleared! Check console for details.');
        }

        function updateKeeperRosterDisplay() {
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];
            const keeperNames = teamKeepers.map(k => k.player_name.toLowerCase());

            document.querySelectorAll('#keeper-roster-body tr').forEach(row => {
                const playerName = row.dataset.playerName;
                const isKept = keeperNames.includes(playerName.toLowerCase());

                row.className = isKept ? 'is-keeper' : '';

                // Update checkbox
                const checkbox = row.querySelector('.keeper-checkbox');
                if (checkbox) checkbox.checked = isKept;

                // Update keeper badge
                const nameCell = row.querySelector('.player-name-cell');
                const existingBadge = nameCell.querySelector('.keeper-badge');
                if (isKept && !existingBadge) {
                    nameCell.insertAdjacentHTML('beforeend', '<span class="keeper-badge">K</span>');
                } else if (!isKept && existingBadge) {
                    existingBadge.remove();
                }
            });

            // Also update the picks display
            updateKeeperPicksDisplay();
        }

        function toggleTradedPicks() {
            showTradedPicks = !showTradedPicks;
            const btn = document.getElementById('keeper-toggle-traded');
            const text = document.getElementById('toggle-traded-text');

            if (showTradedPicks) {
                btn.classList.add('active');
                text.textContent = 'Hide Traded';
            } else {
                btn.classList.remove('active');
                text.textContent = 'Show Traded';
            }

            updateKeeperPicksDisplay();
        }

        function updateKeeperPicksDisplay() {
            const grid = document.getElementById('keeper-picks-grid');
            if (!grid || !currentKeeperTeam) return;

            const totalRounds = getTotalDraftRounds();
            const teamPicks = getTeamPicks(currentKeeperTeam);
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];

            // Separate prospects from regular keepers
            const regularKeepers = teamKeepers.filter(k => !k.isProspect);
            const prospects = teamKeepers.filter(k => k.isProspect);

            // Calculate which rounds are used by regular keepers (not prospects)
            const roundCosts = calculateTeamKeeperRoundCosts(currentKeeperTeam);

            // Build a map of round -> keeper info for picks used (only regular keepers)
            const keeperByRound = {};
            roundCosts.forEach(rc => {
                const keeper = regularKeepers.find(k => k.player_name === rc.player_name);
                if (keeper && rc.actualRoundCost !== null) {
                    if (!keeperByRound[rc.actualRoundCost]) {
                        keeperByRound[rc.actualRoundCost] = [];
                    }
                    keeperByRound[rc.actualRoundCost].push({
                        name: rc.player_name,
                        headshot: keeperRosterData.find(p => p.name === rc.player_name)?.headshot_url
                    });
                }
            });

            // Build a map of which picks we own at each round
            const picksAtRound = {};
            teamPicks.forEach(pick => {
                if (!picksAtRound[pick.round]) {
                    picksAtRound[pick.round] = [];
                }
                picksAtRound[pick.round].push(pick);
            });

            // Generate HTML for each round
            let html = '';
            for (let round = 1; round <= totalRounds; round++) {
                const picks = picksAtRound[round] || [];
                const ownsPick = picks.length > 0;

                // Check if we traded away our pick at this round
                const tradedAway = !ownsPick;

                // Skip traded AWAY picks if toggle is off (but always show picks we own)
                if (!showTradedPicks && tradedAway) {
                    continue;
                }

                if (ownsPick) {
                    // Show each pick we own at this round (always show these regardless of toggle)
                    picks.forEach((pick, idx) => {
                        const isFromTrade = pick.originalOwner !== currentKeeperTeam;
                        const originalTeam = keeperConfig?.teams[pick.originalOwner]?.team_name || '';

                        // Check if this specific pick slot is used for a keeper
                        const keepersAtThisRound = keeperByRound[round] || [];
                        const keeperForThisPick = keepersAtThisRound[idx];

                        let boxClass = 'keeper-pick-box';
                        if (isFromTrade) boxClass += ' traded-for';
                        if (keeperForThisPick) boxClass += ' used-for-keeper';

                        const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                        if (keeperForThisPick) {
                            const headshot = keeperForThisPick.headshot || placeholderImg;

                            html += `
                                <div class="${boxClass}" title="${keeperForThisPick.name} - Round ${round}">
                                    <img src="${headshot}" class="keeper-headshot" onerror="this.src='${placeholderImg}'">
                                    <div class="keeper-overlay">
                                        <span>Rd ${round}</span>
                                    </div>
                                </div>
                            `;
                        } else {
                            html += `
                                <div class="${boxClass}" title="Round ${round}${isFromTrade ? ' (from ' + originalTeam + ')' : ''}">
                                    <span class="pick-round">Rd</span>
                                    <span class="pick-number">${round}</span>
                                    ${isFromTrade ? '<span class="traded-label">+Trade</span>' : ''}
                                </div>
                            `;
                        }
                    });
                } else if (showTradedPicks) {
                    // Traded away - only show if toggle is on
                    html += `
                        <div class="keeper-pick-box traded-away" title="Round ${round} - Traded Away">
                            <span class="pick-round">Rd</span>
                            <span class="pick-number">${round}</span>
                            <span class="traded-label">Traded</span>
                        </div>
                    `;
                }
            }

            // Add prospects section if there are any
            if (prospects.length > 0) {
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                html += `<div class="keeper-prospects-divider">Prospects (Free)</div>`;

                prospects.forEach(prospect => {
                    const player = keeperRosterData.find(p => p.name === prospect.player_name);
                    const headshot = player?.headshot_url || placeholderImg;

                    html += `
                        <div class="keeper-pick-box prospect-pick" title="${prospect.player_name} - Free Prospect">
                            <img src="${headshot}" class="keeper-headshot" onerror="this.src='${placeholderImg}'">
                            <div class="keeper-overlay prospect-overlay">
                                <span>P</span>
                            </div>
                        </div>
                    `;
                });
            }

            grid.innerHTML = html;
        }

        function updateKeeperSelectedSummary() {
            const summaryEl = document.getElementById('keeper-selected-summary');
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];

            if (teamKeepers.length === 0) {
                summaryEl.innerHTML = '<span class="no-selection">No keepers selected. Check the boxes next to players you want to keep.</span>';
            } else {
                const totalCost = calculateTeamBudgetUsed(currentKeeperTeam);
                const prospectCount = teamKeepers.filter(k => k.isProspect).length;

                // Calculate actual round costs (handling multiple last-round picks) - excludes prospects
                const roundCosts = calculateTeamKeeperRoundCosts(currentKeeperTeam);

                let headerText = `Selected Keepers (Total: $${totalCost})`;
                if (prospectCount > 0) {
                    headerText = `Selected Keepers ($${totalCost} + ${prospectCount} prospect${prospectCount !== 1 ? 's' : ''})`;
                }

                let summaryHtml = `<div class="keeper-summary-header">${headerText}</div>`;
                summaryHtml += '<div class="keeper-summary-list">';
                summaryHtml += teamKeepers.map(k => {
                    const isProspect = k.isProspect || false;

                    if (isProspect) {
                        // Prospect display - no round cost, $0
                        return `
                        <span class="selected-player is-prospect">
                            <span class="prospect-badge">P</span>
                            ${k.player_name}
                            <span class="keeper-cost-tag prospect-free">Free</span>
                            <span class="remove-keeper" onclick="toggleKeeper('${k.player_name.replace(/'/g, "\\'")}', false)" title="Remove"></span>
                        </span>
                    `;
                    } else {
                        // Regular keeper display
                        const roundInfo = roundCosts.find(rc => rc.player_name === k.player_name);
                        const actualRound = roundInfo ? roundInfo.actualRoundCost : k.roundCost;
                        const isAdjusted = roundInfo && roundInfo.actualRoundCost !== roundInfo.baseRoundCost;
                        const noPick = actualRound === null;

                        const roundDisplay = noPick
                            ? '<span class="keeper-round-tag no-pick">No Pick!</span>'
                            : `<span class="keeper-round-tag ${isAdjusted ? 'adjusted' : ''}">Rd ${actualRound}</span>`;

                        return `
                        <span class="selected-player ${noPick ? 'no-pick-warning' : ''}">
                            <span class="keeper-badge">K</span>
                            ${k.player_name}
                            <span class="keeper-cost-tag">$${k.dollarCost !== undefined ? k.dollarCost : 1}</span>
                            ${roundDisplay}
                            <span class="remove-keeper" onclick="toggleKeeper('${k.player_name.replace(/'/g, "\\'")}', false)" title="Remove"></span>
                        </span>
                    `;
                    }
                }).join('');
                summaryHtml += '</div>';
                summaryEl.innerHTML = summaryHtml;
            }

            // Update submit button state
            const submitBtn = document.getElementById('keeper-submit-btn');
            submitBtn.disabled = teamKeepers.length === 0;
        }

        async function submitKeepers() {
            if (!currentKeeperTeam) return;

            const teamKeepers = keeperSelections[currentKeeperTeam] || [];
            const teamInfo = keeperConfig.teams[currentKeeperTeam];

            if (teamKeepers.length === 0) {
                alert('Please select at least one keeper before submitting.');
                return;
            }

            // Separate prospects from regular keepers
            const regularKeepers = teamKeepers.filter(k => !k.isProspect);
            const prospects = teamKeepers.filter(k => k.isProspect);

            // Calculate total cost and actual round costs
            const totalCost = calculateTeamBudgetUsed(currentKeeperTeam);
            const roundCosts = calculateTeamKeeperRoundCosts(currentKeeperTeam);

            // Confirm submission with cost details
            let confirmMsg = `Submit the following keepers for ${teamInfo.team_name}?\n\n`;

            if (regularKeepers.length > 0) {
                confirmMsg += `KEEPERS:\n`;
                regularKeepers.forEach(k => {
                    const roundInfo = roundCosts.find(rc => rc.player_name === k.player_name);
                    const actualRound = roundInfo ? roundInfo.actualRoundCost : k.roundCost;
                    confirmMsg += ` ${k.player_name} ($${k.dollarCost !== undefined ? k.dollarCost : 1}, Round ${actualRound})\n`;
                });
            }

            if (prospects.length > 0) {
                confirmMsg += `\nPROSPECTS (Free):\n`;
                prospects.forEach(k => {
                    confirmMsg += ` ${k.player_name}\n`;
                });
            }

            confirmMsg += `\nTotal Budget Used: $${totalCost} / $${KEEPER_BUDGET}`;
            if (prospects.length > 0) {
                confirmMsg += ` + ${prospects.length} prospect${prospects.length !== 1 ? 's' : ''}`;
            }

            confirmMsg += `\n\nThis will be visible to all managers.`;

            const confirmed = confirm(confirmMsg);

            if (!confirmed) return;

            // Save to Firebase (primary) and localStorage (backup)
            const firebaseSaved = await saveKeepersToFirebase(currentKeeperTeam, teamKeepers);
            saveKeeperSelections(); // localStorage backup

            // Update the visual display of the league grid
            displayLeagueKeepers();

            // CRITICAL: Force re-render of the main projections table to show "K" badges immediately
            // We call filterProjections() which internally calls renderProjectionTable()
            filterProjections();

            // Show success message
            const keeperText = regularKeepers.length > 0 ? `${regularKeepers.length} keeper${regularKeepers.length !== 1 ? 's' : ''}` : '';
            const prospectText = prospects.length > 0 ? `${prospects.length} prospect${prospects.length !== 1 ? 's' : ''}` : '';
            const totalText = [keeperText, prospectText].filter(t => t).join(' and ');

            if (firebaseSaved) {
                alert(` Keepers submitted successfully!\n\nYour ${totalText} have been saved and are now visible to all managers.`);
            } else {
                alert(` Keepers saved locally.\n\nYour ${totalText} have been saved, but could not sync to the server. They will sync when connection is restored.`);
            }

            // Close the modal
            closeKeeperModal();
        }

        let displayLeagueKeepersRunning = false;
        
        async function displayLeagueKeepers() {
            // Prevent multiple simultaneous calls
            if (displayLeagueKeepersRunning) {
                console.log('displayLeagueKeepers already running, skipping');
                return;
            }
            displayLeagueKeepersRunning = true;
            
            try {
                const grid = document.getElementById('keeper-league-grid');
                if (!keeperConfig || !keeperConfig.teams) {
                    grid.innerHTML = '<p style="color: #888;">Keeper data not available.</p>';
                    return;
                }

                grid.innerHTML = '';

            // Ensure average projections are loaded for display
            try {
                await loadAverageProjections();
            } catch (e) {
                console.log('Could not load average projections for league keepers:', e);
            }

            // Load fresh 2026 team data for updated logos (using normalized manager names)
            const currentTeams = await getTeamData(2026);
            const currentTeamLogos = {};
            if (currentTeams) {
                currentTeams.forEach(team => {
                    const normalizedManager = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                    const managerLower = normalizedManager.toLowerCase();
                    currentTeamLogos[managerLower] = fixTeamLogo(team.team_logo);
                });
            }

            // Sort teams by manager name
            const sortedTeams = Object.entries(keeperConfig.teams)
                .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

            for (const [teamKey, teamInfo] of sortedTeams) {
                // Get fresh logo from 2026 data if available (using normalized manager name)
                const normalizedManager = normalizeManagerName(teamInfo.manager, 2026, teamInfo.team_name, teamKey);
                const managerLower = normalizedManager.toLowerCase();
                const freshLogo = currentTeamLogos[managerLower] || teamInfo.team_logo;
                
                const teamKeepers = keeperSelections[teamKey] || [];

                // Filter out prospects if toggle is off
                let displayKeepers = showLeagueProspects
                    ? [...teamKeepers]
                    : teamKeepers.filter(k => !k.isProspect);

                const budgetUsed = teamKeepers.reduce((sum, k) => sum + (k.dollarCost || 0), 0);
                const teamTotalBudget = getTeamBudget ? getTeamBudget(teamKey) : KEEPER_BUDGET;

                // Calculate actual round costs for this team's keepers
                const roundCosts = calculateTeamKeeperRoundCosts(teamKey);

                // Sort keepers: regular keepers first (by round asc, then proj pts desc), then prospects (by proj pts desc, then position)
                displayKeepers.sort((a, b) => {
                    const aIsProspect = a.isProspect || false;
                    const bIsProspect = b.isProspect || false;

                    // Regular keepers come before prospects
                    if (aIsProspect !== bIsProspect) {
                        return aIsProspect ? 1 : -1;
                    }

                    // Get average projected points for sorting
                    const aProjPts = getAverageProjection(a.player_name);
                    const bProjPts = getAverageProjection(b.player_name);

                    if (aIsProspect) {
                        // Both are prospects: sort by projected points desc, then position alphabetically
                        if (bProjPts !== aProjPts) {
                            return bProjPts - aProjPts;
                        }
                        return (a.position || '').localeCompare(b.position || '');
                    } else {
                        // Both are regular keepers: sort by round asc, then projected points desc
                        const aRoundInfo = roundCosts.find(rc => rc.player_name === a.player_name);
                        const bRoundInfo = roundCosts.find(rc => rc.player_name === b.player_name);
                        const aRound = aRoundInfo ? aRoundInfo.actualRoundCost : (a.roundCost || 99);
                        const bRound = bRoundInfo ? bRoundInfo.actualRoundCost : (b.roundCost || 99);

                        // Handle null rounds (no pick) - sort them last among regular keepers
                        const aRoundVal = aRound === null ? 999 : aRound;
                        const bRoundVal = bRound === null ? 999 : bRound;

                        if (aRoundVal !== bRoundVal) {
                            return aRoundVal - bRoundVal;
                        }
                        // Same round: sort by projected points descending
                        return bProjPts - aProjPts;
                    }
                });

                const card = document.createElement('div');
                card.className = 'keeper-team-card';

                const logoImg = freshLogo
                    ? `<img src="${fixTeamLogo(freshLogo)}" class="keeper-team-card-logo" alt="">`
                    : '';

                let keepersHtml = '';
                if (displayKeepers.length === 0) {
                    keepersHtml = '<div class="no-keepers">No keepers selected yet</div>';
                } else {
                    keepersHtml = displayKeepers.map(k => {
                        const projPts = getAverageProjection(k.player_name);
                        const projDisplay = projPts > 0 ? projPts.toFixed(0) : '-';
                        const isProspect = k.isProspect || false;

                        // Find the actual round cost for this keeper
                        const roundInfo = roundCosts.find(rc => rc.player_name === k.player_name);
                        const actualRound = roundInfo ? roundInfo.actualRoundCost : k.roundCost;
                        const noPick = actualRound === null && !isProspect;

                        let roundDisplay;
                        if (isProspect) {
                            roundDisplay = '<span class="keeper-round-small prospect-free">Free</span>';
                        } else if (noPick) {
                            roundDisplay = '<span class="keeper-round-small no-pick">No Pick!</span>';
                        } else {
                            roundDisplay = `<span class="keeper-round-small">Rd ${actualRound}</span>`;
                        }

                        const costDisplay = isProspect
                            ? '<span class="keeper-cost-small prospect-free">$0</span>'
                            : `<span class="keeper-cost-small">$${k.dollarCost || 0}</span>`;

                        return `
                            <div class="keeper-player-row ${noPick ? 'no-pick-warning' : ''} ${isProspect ? 'is-prospect' : ''}">
                                ${isProspect ? '<span class="prospect-badge">P</span>' : '<span class="keeper-badge">K</span>'}
                                <span class="player-name">${k.player_name}</span>
                                ${getPositionBadge(k.position || '', k.player_name)}
                                ${roundDisplay}
                                ${costDisplay}
                                <span class="player-pts">${projDisplay}</span>
                            </div>
                        `;
                    }).join('');
                }

                // Count prospects vs regular keepers
                const prospectCount = teamKeepers.filter(k => k.isProspect).length;
                const regularCount = teamKeepers.filter(k => !k.isProspect).length;

                // Calculate budget bar - width proportional to team's total budget relative to default
                const maxBudgetForWidth = Math.max(KEEPER_BUDGET, teamTotalBudget);
                const barWidth = Math.round((teamTotalBudget / maxBudgetForWidth) * 100); // 100px max width scaled
                const fillPercentage = teamTotalBudget > 0 ? Math.min((budgetUsed / teamTotalBudget) * 100, 100) : 0;
                const barClass = budgetUsed > teamTotalBudget ? 'over' : (budgetUsed >= teamTotalBudget ? 'full' : '');

                // Build budget bar display
                let budgetDisplay = '';
                if (teamTotalBudget !== KEEPER_BUDGET || teamKeepers.length > 0) {
                    budgetDisplay = `
                        <div class="league-budget-container">
                            <div class="league-budget-bar-wrapper" style="width: ${barWidth}px;">
                                <div class="league-budget-bar ${barClass}" style="width: ${fillPercentage}%;"></div>
                            </div>
                            <span class="league-budget-text">$${budgetUsed}/$${teamTotalBudget}</span>
                            ${prospectCount > 0 && showLeagueProspects ? `<span class="prospect-count">(+${prospectCount}P)</span>` : ''}
                        </div>
                    `;
                }

                card.innerHTML = `
                    <div class="keeper-team-card-header">
                        ${logoImg}
                        <div class="keeper-team-card-info">
                            <h5>${teamInfo.team_name}</h5>
                            <span>${capitalizeManagerName(teamInfo.manager)}</span>
                            ${budgetDisplay}
                        </div>
                    </div>
                    <div class="keeper-team-card-body">
                        ${keepersHtml}
                    </div>
                `;

                grid.appendChild(card);
            }

            // Update keeper value analysis
            initializeKeeperValueAnalysis();
            } finally {
                displayLeagueKeepersRunning = false;
            }
        }

        function toggleLeagueProspects() {
            showLeagueProspects = !showLeagueProspects;
            const btn = document.getElementById('btn-toggle-prospects');
            const text = document.getElementById('toggle-prospects-text');

            if (showLeagueProspects) {
                btn.classList.add('active');
                text.textContent = 'Hide Prospects';
            } else {
                btn.classList.remove('active');
                text.textContent = 'Show Prospects';
            }

            displayLeagueKeepers();
        }

        // ===== PROJECTED LINEUPS TICKER =====
        let lineupTickerIndex = 0;
        let lineupTeamsData = [];
        let showLineupProspects = false;
        let lineupProjectionsData = { batters: [], pitchers: [] };

        // Roster position slots in order (2026 settings: 4 UTIL, 4 BN)
        const LINEUP_POSITIONS = [
            // Batters
            { pos: 'C', count: 1, type: 'batter' },
            { pos: '1B', count: 1, type: 'batter' },
            { pos: '2B', count: 1, type: 'batter' },
            { pos: '3B', count: 1, type: 'batter' },
            { pos: 'SS', count: 1, type: 'batter' },
            { pos: 'OF', count: 3, type: 'batter' },
            { pos: 'Util', count: 4, type: 'batter' },
            // Pitchers
            { pos: 'SP', count: 3, type: 'pitcher' },
            { pos: 'RP', count: 1, type: 'pitcher' },
            { pos: 'P', count: 2, type: 'pitcher' },
            // Bench
            { pos: 'BN', count: 4, type: 'bench' }
        ];

        async function initProjectedLineups() {
            if (!keeperConfig || !keeperConfig.teams) {
                console.log('Keeper config not ready for projected lineups');
                return;
            }

            // Load the selected projection type
            const projType = document.getElementById('lineup-projection-type')?.value || 'thebat';
            
            // Show/hide BAT X notice
            const batxNotice = document.getElementById('lineup-batx-notice');
            if (batxNotice) {
                batxNotice.style.display = projType === 'thebatx' ? 'block' : 'none';
            }
            
            await loadLineupProjections(projType);

            // Load fresh 2026 team data for updated logos (using normalized manager names)
            const currentTeams = await getTeamData(2026);
            const currentTeamLogos = {};
            if (currentTeams) {
                currentTeams.forEach(team => {
                    const normalizedManager = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                    const managerLower = normalizedManager.toLowerCase();
                    currentTeamLogos[managerLower] = fixTeamLogo(team.team_logo);
                });
            }

            // Build the team data array sorted by manager name, using fresh logos
            lineupTeamsData = Object.entries(keeperConfig.teams)
                .map(([teamKey, teamInfo]) => {
                    const normalizedManager = normalizeManagerName(teamInfo.manager, 2026, teamInfo.team_name, teamKey);
                    const managerLower = normalizedManager.toLowerCase();
                    return {
                        teamKey,
                        ...teamInfo,
                        // Use 2026 logo if available, otherwise fall back to config logo
                        team_logo: currentTeamLogos[managerLower] || teamInfo.team_logo,
                        keepers: keeperSelections[teamKey] || []
                    };
                })
                .sort((a, b) => a.manager.localeCompare(b.manager));

            renderLineupTicker();
            renderLineupDots();
        }

        async function loadLineupProjections(projType) {
            try {
                const response = await fetch(`data/projections/projections_${projType}.json`);
                if (response.ok) {
                    const data = await response.json();
                    lineupProjectionsData = {
                        batters: data.batters || [],
                        pitchers: data.pitchers || []
                    };
                }
            } catch (e) {
                console.log('Could not load lineup projections:', e);
            }
        }

        function getLineupProjection(playerName, position) {
            if (!playerName) return null;
            let nameLower = playerName.toLowerCase().trim();
            
            // Handle "Shohei Ohtani (Pitcher)" - strip the parenthetical and search pitchers
            const isOhtaniPitcher = nameLower.includes('shohei ohtani') && nameLower.includes('pitcher');
            if (isOhtaniPitcher) {
                nameLower = 'shohei ohtani';
                // Search pitchers first for Ohtani pitcher
                const pitcher = lineupProjectionsData.pitchers.find(p => 
                    p.name && p.name.toLowerCase().trim() === nameLower
                );
                if (pitcher) return pitcher;
            }
            
            // Strip any parenthetical from player names
            nameLower = nameLower.replace(/\s*\([^)]*\)\s*/g, '').trim();
            
            // If position indicates pitcher, search pitchers first
            const isPitcherPosition = position && (position.toUpperCase().includes('SP') || position.toUpperCase().includes('RP') || position.toUpperCase() === 'P');
            
            if (isPitcherPosition) {
                // Search pitchers first
                let player = lineupProjectionsData.pitchers.find(p => 
                    p.name && p.name.toLowerCase().trim() === nameLower
                );
                if (player) return player;
                
                // Fall back to batters
                player = lineupProjectionsData.batters.find(p => 
                    p.name && p.name.toLowerCase().trim() === nameLower
                );
                return player || null;
            }
            
            // Search batters first for non-pitchers
            let player = lineupProjectionsData.batters.find(p => 
                p.name && p.name.toLowerCase().trim() === nameLower
            );
            if (player) return player;
            
            // Search pitchers
            player = lineupProjectionsData.pitchers.find(p => 
                p.name && p.name.toLowerCase().trim() === nameLower
            );
            return player || null;
        }

        function getPlayerPositionType(position) {
            if (!position) return 'batter';
            const pos = position.toUpperCase();
            if (pos.includes('SP') || pos.includes('RP') || pos === 'P') return 'pitcher';
            return 'batter';
        }

        function canPlayPosition(playerPos, targetPos) {
            if (!playerPos || !targetPos) return false;
            const pPos = playerPos.toUpperCase();
            const tPos = targetPos.toUpperCase();
            
            // Util can be any batter
            if (tPos === 'UTIL') {
                return !pPos.includes('SP') && !pPos.includes('RP') && pPos !== 'P';
            }
            
            // P can be any pitcher
            if (tPos === 'P') {
                return pPos.includes('SP') || pPos.includes('RP') || pPos === 'P';
            }
            
            // OF matches LF, CF, RF, OF
            if (tPos === 'OF') {
                return pPos.includes('LF') || pPos.includes('CF') || pPos.includes('RF') || pPos.includes('OF');
            }
            
            // BN can be anyone
            if (tPos === 'BN') return true;
            
            // Direct match
            return pPos.includes(tPos);
        }

        function buildTeamLineup(teamData) {
            const keepers = teamData.keepers || [];
            const regularKeepers = keepers.filter(k => !k.isProspect);
            const prospects = keepers.filter(k => k.isProspect);
            
            // Create lineup structure
            const lineup = {
                batters: [],
                pitchers: [],
                bench: [],
                prospects: { batters: [], pitchers: [] }
            };
            
            // Track which keepers have been assigned
            const assigned = new Set();
            
            // Fill each position slot
            LINEUP_POSITIONS.forEach(slot => {
                for (let i = 0; i < slot.count; i++) {
                    if (slot.type === 'bench') {
                        // Bench gets remaining unassigned players
                        continue;
                    }
                    
                    // Find best unassigned keeper for this position
                    let bestKeeper = null;
                    let bestPoints = -1;
                    
                    for (const keeper of regularKeepers) {
                        if (assigned.has(keeper.player_name)) continue;
                        
                        const playerPos = keeper.position || '';
                        if (!canPlayPosition(playerPos, slot.pos)) continue;
                        
                        const projection = getLineupProjection(keeper.player_name, playerPos);
                        const points = projection?.projected_points || 0;
                        
                        if (points > bestPoints) {
                            bestPoints = points;
                            bestKeeper = keeper;
                        }
                    }
                    
                    if (bestKeeper) {
                        assigned.add(bestKeeper.player_name);
                        const projection = getLineupProjection(bestKeeper.player_name, bestKeeper.position);
                        const entry = {
                            ...bestKeeper,
                            slotPos: slot.pos,
                            projection
                        };
                        
                        if (slot.type === 'batter') {
                            lineup.batters.push(entry);
                        } else {
                            lineup.pitchers.push(entry);
                        }
                    } else {
                        // Empty slot
                        const entry = {
                            player_name: null,
                            slotPos: slot.pos,
                            isEmpty: true
                        };
                        if (slot.type === 'batter') {
                            lineup.batters.push(entry);
                        } else {
                            lineup.pitchers.push(entry);
                        }
                    }
                }
            });
            
            // Fill bench with remaining keepers
            for (const keeper of regularKeepers) {
                if (assigned.has(keeper.player_name)) continue;
                const projection = getLineupProjection(keeper.player_name, keeper.position);
                lineup.bench.push({
                    ...keeper,
                    slotPos: 'BN',
                    projection
                });
            }
            
            // Organize prospects by type
            for (const prospect of prospects) {
                const projection = getLineupProjection(prospect.player_name, prospect.position);
                const entry = {
                    ...prospect,
                    slotPos: prospect.position || 'BN',
                    projection,
                    isProspect: true
                };
                
                const posType = getPlayerPositionType(prospect.position);
                if (posType === 'pitcher') {
                    lineup.prospects.pitchers.push(entry);
                } else {
                    lineup.prospects.batters.push(entry);
                }
            }
            
            return lineup;
        }

        function renderLineupPlayerRow(player, isBatter = true) {
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
            
            if (player.isEmpty) {
                // Empty slot
                const posDisplay = player.slotPos === 'P' ? 'SP' : player.slotPos;
                return `
                    <div class="lineup-player-row empty-slot">
                        <div class="lineup-pos-badge">${getPositionBadge(posDisplay, '')}</div>
                        <img src="${placeholderImg}" class="lineup-player-headshot" alt="">
                        <div class="lineup-player-info">
                            <div class="lineup-player-name"></div>
                        </div>
                        <div class="lineup-player-points">-</div>
                    </div>
                `;
            }
            
            const projection = player.projection;
            const stats = projection?.stats || {};
            const headshot = projection?.headshot_url || placeholderImg;
            const mlbTeam = formatMLBTeamDisplay(projection?.team || '');
            const mlbLogo = getMLBTeamLogo(projection?.team || '');
            const points = projection?.projected_points || 0;
            
            // Get position badge - use SP for P slots
            const posDisplay = player.slotPos === 'P' ? 'SP' : player.slotPos;
            
            // Clean up player name - strip any parenthetical like "(Pitcher)"
            const displayName = player.player_name.replace(/\s*\([^)]*\)\s*/g, '').trim();
            
            // Build stats based on player type
            let statsHtml = '';
            if (isBatter) {
                const games = stats.G || 0;
                const ppg = games > 0 ? (points / games).toFixed(2) : '-';
                statsHtml = `
                    <div class="lineup-stat"><div class="lineup-stat-value">${stats.HR || 0}</div><div class="lineup-stat-label">HR</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${stats.SB || 0}</div><div class="lineup-stat-label">SB</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${(stats.OPS || 0).toFixed(3)}</div><div class="lineup-stat-label">OPS</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${games}</div><div class="lineup-stat-label">G</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${ppg}</div><div class="lineup-stat-label">PPG</div></div>
                `;
            } else {
                statsHtml = `
                    <div class="lineup-stat"><div class="lineup-stat-value">${stats.W || 0}</div><div class="lineup-stat-label">W</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${stats.SV || 0}</div><div class="lineup-stat-label">SV</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${stats.K || stats.SO || 0}</div><div class="lineup-stat-label">K</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${(stats.ERA || 0).toFixed(2)}</div><div class="lineup-stat-label">ERA</div></div>
                    <div class="lineup-stat"><div class="lineup-stat-value">${(stats.IP || 0).toFixed(0)}</div><div class="lineup-stat-label">IP</div></div>
                `;
            }
            
            const prospectClass = player.isProspect ? 'prospect-row' : '';
            
            return `
                <div class="lineup-player-row ${prospectClass}">
                    <div class="lineup-pos-badge">${getPositionBadge(posDisplay, player.player_name)}</div>
                    <img src="${headshot}" class="lineup-player-headshot" alt="" onerror="this.src='${placeholderImg}'">
                    <div class="lineup-player-info">
                        <div class="lineup-player-name">${displayName}${player.isProspect ? ' <span style="font-size:0.65rem;color:#888;">(P)</span>' : ''}</div>
                        <div class="lineup-player-mlb">
                            ${mlbLogo ? `<img src="${mlbLogo}" class="lineup-mlb-logo" alt="" onerror="this.style.display='none'">` : ''}
                            <span>${mlbTeam}</span>
                        </div>
                    </div>
                    <div class="lineup-player-stats">${statsHtml}</div>
                    <div class="lineup-player-points">${points.toFixed(1)}</div>
                </div>
            `;
        }

        function renderLineupCard(teamData) {
            const lineup = buildTeamLineup(teamData);
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFhMWEyZSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZCI+8J+PhjwvdGV4dD48L3N2Zz4=';
            
            // Calculate total projected points
            let totalPoints = 0;
            [...lineup.batters, ...lineup.pitchers, ...lineup.bench].forEach(p => {
                if (p.projection) totalPoints += p.projection.projected_points || 0;
            });
            
            // Render batters
            let battersHtml = lineup.batters.map(p => renderLineupPlayerRow(p, true)).join('');
            
            // Render pitchers
            let pitchersHtml = lineup.pitchers.map(p => renderLineupPlayerRow(p, false)).join('');
            
            // Render bench - split by type for each column
            let benchBattersHtml = '';
            let benchPitchersHtml = '';
            lineup.bench.forEach(p => {
                const isBatter = getPlayerPositionType(p.position) !== 'pitcher';
                if (isBatter) {
                    benchBattersHtml += renderLineupPlayerRow(p, true);
                } else {
                    benchPitchersHtml += renderLineupPlayerRow(p, false);
                }
            });
            
            // Render prospects
            const hasProspects = lineup.prospects.batters.length > 0 || lineup.prospects.pitchers.length > 0;
            let prospectBattersHtml = '';
            let prospectPitchersHtml = '';
            if (hasProspects) {
                prospectBattersHtml = lineup.prospects.batters.map(p => renderLineupPlayerRow(p, true)).join('');
                prospectPitchersHtml = lineup.prospects.pitchers.map(p => renderLineupPlayerRow(p, false)).join('');
            }
            
            return `
                <div class="lineup-ticker-card" data-team-key="${teamData.teamKey}">
                    <div class="lineup-card-header">
                        <img src="${fixTeamLogo(teamData.team_logo) || placeholderLogo}" class="team-logo" alt="" onerror="this.src='${placeholderLogo}'">
                        <div class="team-info">
                            <div class="team-name">${teamData.team_name || 'Unknown Team'}</div>
                            <div class="manager-name">${teamData.manager || 'Unknown'}</div>
                        </div>
                        <div class="team-stats">
                            <div>Proj. Total</div>
                            <div class="total-points">${totalPoints.toFixed(1)}</div>
                        </div>
                    </div>
                    <div class="lineup-card-content">
                        <div class="lineup-column">
                            <div class="lineup-section-title">Batters</div>
                            ${battersHtml}
                            ${benchBattersHtml ? `<div class="lineup-section-title">Bench</div>${benchBattersHtml}` : ''}
                            <div class="lineup-prospects-section ${showLineupProspects ? 'visible' : ''}" id="lineup-prospects-batters-${teamData.teamKey}">
                                ${prospectBattersHtml ? `<div class="lineup-section-title"> Prospect Batters</div>${prospectBattersHtml}` : ''}
                            </div>
                        </div>
                        <div class="lineup-column">
                            <div class="lineup-section-title">Pitchers</div>
                            ${pitchersHtml}
                            ${benchPitchersHtml ? `<div class="lineup-section-title">Bench</div>${benchPitchersHtml}` : ''}
                            <div class="lineup-prospects-section ${showLineupProspects ? 'visible' : ''}" id="lineup-prospects-pitchers-${teamData.teamKey}">
                                ${prospectPitchersHtml ? `<div class="lineup-section-title"> Prospect Pitchers</div>${prospectPitchersHtml}` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderLineupTicker() {
            const track = document.getElementById('lineup-ticker-track');
            if (!track || lineupTeamsData.length === 0) return;
            
            track.innerHTML = lineupTeamsData.map(team => renderLineupCard(team)).join('');
            updateLineupTickerPosition();
        }

        function renderLineupDots() {
            const dotsContainer = document.getElementById('lineup-ticker-dots');
            if (!dotsContainer || lineupTeamsData.length === 0) return;
            
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzk5OSI+PzwvdGV4dD48L3N2Zz4=';
            
            dotsContainer.innerHTML = lineupTeamsData.map((team, index) => `
                <div class="lineup-ticker-dot ${index === lineupTickerIndex ? 'active' : ''}" 
                     onclick="goToLineupTeam(${index})"
                     data-index="${index}">
                    <img src="${fixTeamLogo(team.team_logo) || placeholderLogo}" alt="${team.team_name}" onerror="this.src='${placeholderLogo}'">
                    <div class="dot-tooltip">
                        <div>${team.team_name}</div>
                        <div style="font-size: 0.65rem; opacity: 0.8;">${team.manager}</div>
                    </div>
                </div>
            `).join('');
        }

        function updateLineupTickerPosition() {
            const track = document.getElementById('lineup-ticker-track');
            if (!track) return;
            
            track.style.transform = `translateX(-${lineupTickerIndex * 100}%)`;
            
            // Update active dot
            document.querySelectorAll('.lineup-ticker-dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === lineupTickerIndex);
            });
        }

        function navigateLineupTicker(direction) {
            const newIndex = lineupTickerIndex + direction;
            if (newIndex >= 0 && newIndex < lineupTeamsData.length) {
                lineupTickerIndex = newIndex;
                updateLineupTickerPosition();
            }
        }

        function goToLineupTeam(index) {
            if (index >= 0 && index < lineupTeamsData.length) {
                lineupTickerIndex = index;
                updateLineupTickerPosition();
            }
        }

        function toggleLineupProspects() {
            showLineupProspects = !showLineupProspects;
            const btn = document.getElementById('btn-show-lineup-prospects');
            
            if (showLineupProspects) {
                btn.classList.add('active');
                btn.textContent = 'Hide Prospects';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Show Prospects';
            }
            
            // Toggle visibility of all prospect sections
            document.querySelectorAll('.lineup-prospects-section').forEach(section => {
                section.classList.toggle('visible', showLineupProspects);
            });
        }

        async function updateLineupProjections() {
            const projType = document.getElementById('lineup-projection-type')?.value || 'thebat';
            
            // Show/hide BAT X notice
            const batxNotice = document.getElementById('lineup-batx-notice');
            if (batxNotice) {
                batxNotice.style.display = projType === 'thebatx' ? 'block' : 'none';
            }
            
            await loadLineupProjections(projType);
            renderLineupTicker();
        }

        // ===== BUDGET ADJUSTMENT =====

        let manualBudgetAdjustments = {}; // Store manual budget adjustments
        let budgetsLoadedFromServer = false;

        async function loadManualBudgetAdjustments() {
            // First try to load from server JSON file
            try {
                const response = await fetch('data/keepers/budget_adjustments_2026.json');
                if (response.ok) {
                    const serverData = await response.json();
                    // Extract just the adjustment values from the server data
                    if (serverData.adjustments) {
                        Object.entries(serverData.adjustments).forEach(([teamKey, data]) => {
                            if (typeof data === 'object' && data.adjustment !== undefined) {
                                manualBudgetAdjustments[teamKey] = data.adjustment;
                            } else if (typeof data === 'number') {
                                manualBudgetAdjustments[teamKey] = data;
                            }
                        });
                    }
                    budgetsLoadedFromServer = true;
                    console.log(`Loaded budget adjustments from server for ${Object.keys(manualBudgetAdjustments).length} teams`);
                }
            } catch (e) {
                console.log('No server budget adjustments file found, checking localStorage');
            }

            // If no server data, check localStorage
            if (!budgetsLoadedFromServer) {
                try {
                    const saved = localStorage.getItem('keeper_budget_adjustments_2026');
                    if (saved) {
                        manualBudgetAdjustments = JSON.parse(saved);
                    }
                } catch (e) {
                    console.log('Could not load budget adjustments from localStorage:', e);
                }
            }
        }

        function saveManualBudgetAdjustments() {
            try {
                localStorage.setItem('keeper_budget_adjustments_2026', JSON.stringify(manualBudgetAdjustments));
            } catch (e) {
                console.log('Could not save budget adjustments:', e);
            }
        }

        function openBudgetAdjustmentModal() {
            const modal = document.getElementById('budget-adjustment-modal');
            const listEl = document.getElementById('budget-adjustment-list');

            if (!keeperConfig || !keeperConfig.teams) {
                alert('Keeper configuration not loaded yet.');
                return;
            }

            // Sort teams by manager name
            const sortedTeams = Object.entries(keeperConfig.teams)
                .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

            let html = '';
            sortedTeams.forEach(([teamKey, teamInfo]) => {
                const logoImg = teamInfo.team_logo
                    ? `<img src="${fixTeamLogo(teamInfo.team_logo)}" class="team-logo" alt="">`
                    : '<div class="team-logo" style="background: var(--retro-blue);"></div>';

                // Get current budget (base + trades + manual adjustments)
                const baseBudget = KEEPER_BUDGET;
                const tradeAdjustment = getTradeAdjustedBudget(teamKey) - baseBudget;
                const manualAdjustment = manualBudgetAdjustments[teamKey] || 0;
                const currentBudget = baseBudget + tradeAdjustment + manualAdjustment;

                html += `
                    <div class="budget-row" data-team-key="${teamKey}">
                        ${logoImg}
                        <div class="team-info">
                            <div class="team-name">${teamInfo.team_name}</div>
                            <div class="manager-name">${teamInfo.manager}</div>
                        </div>
                        <div class="budget-input-group">
                            <span>$</span>
                            <input type="number" class="budget-input" 
                                   id="budget-input-${teamKey}" 
                                   value="${currentBudget}" 
                                   min="0" max="200"
                                   data-base="${baseBudget + tradeAdjustment}"
                                   onchange="updateBudgetDiff('${teamKey}')">
                            <span class="budget-diff" id="budget-diff-${teamKey}"></span>
                        </div>
                    </div>
                `;
            });

            listEl.innerHTML = html;

            // Update all diffs
            sortedTeams.forEach(([teamKey]) => updateBudgetDiff(teamKey));

            modal.style.display = 'flex';
        }

        function updateBudgetDiff(teamKey) {
            const input = document.getElementById(`budget-input-${teamKey}`);
            const diffEl = document.getElementById(`budget-diff-${teamKey}`);

            if (!input || !diffEl) return;

            const baseValue = parseFloat(input.dataset.base) || KEEPER_BUDGET;
            const currentValue = parseFloat(input.value) || 0;
            const diff = currentValue - baseValue;

            if (diff > 0) {
                diffEl.textContent = `+$${diff}`;
                diffEl.className = 'budget-diff positive';
            } else if (diff < 0) {
                diffEl.textContent = `-$${Math.abs(diff)}`;
                diffEl.className = 'budget-diff negative';
            } else {
                diffEl.textContent = '';
                diffEl.className = 'budget-diff';
            }
        }

        function getTradeAdjustedBudget(teamKey) {
            // This gets the budget after trades but before manual adjustments
            let budget = KEEPER_BUDGET;

            if (tradeData && tradeData.trades) {
                tradeData.trades.forEach(trade => {
                    if (trade.teamA === teamKey) {
                        // Team A receives assets from B, gives up assets to B
                        trade.assetsB?.forEach(asset => {
                            if (asset.type === 'money') budget += (asset.amount || 0);
                        });
                        trade.assetsA?.forEach(asset => {
                            if (asset.type === 'money') budget -= (asset.amount || 0);
                        });
                    } else if (trade.teamB === teamKey) {
                        // Team B receives assets from A, gives up assets to A
                        trade.assetsA?.forEach(asset => {
                            if (asset.type === 'money') budget += (asset.amount || 0);
                        });
                        trade.assetsB?.forEach(asset => {
                            if (asset.type === 'money') budget -= (asset.amount || 0);
                        });
                    }
                });
            }

            return budget;
        }

        function saveBudgetAdjustments() {
            const rows = document.querySelectorAll('.budget-row');

            rows.forEach(row => {
                const teamKey = row.dataset.teamKey;
                const input = row.querySelector('.budget-input');
                const baseValue = parseFloat(input.dataset.base) || KEEPER_BUDGET;
                const currentValue = parseFloat(input.value) || KEEPER_BUDGET;
                const manualAdjustment = currentValue - baseValue;

                if (manualAdjustment !== 0) {
                    manualBudgetAdjustments[teamKey] = manualAdjustment;
                } else {
                    delete manualBudgetAdjustments[teamKey];
                }
            });

            saveManualBudgetAdjustments();
            closeBudgetModal();
            displayLeagueKeepers();

            alert(' Budget adjustments saved!');
        }

        function resetAllBudgets() {
            if (!confirm('Reset all manual budget adjustments to default ($50 + trade adjustments)?')) {
                return;
            }

            manualBudgetAdjustments = {};
            saveManualBudgetAdjustments();
            closeBudgetModal();
            displayLeagueKeepers();

            alert(' All budgets reset to defaults.');
        }

        function closeBudgetModal() {
            document.getElementById('budget-adjustment-modal').style.display = 'none';
        }

        function exportBudgetsForSite() {
            // First save current changes
            const rows = document.querySelectorAll('.budget-row');
            rows.forEach(row => {
                const teamKey = row.dataset.teamKey;
                const input = row.querySelector('.budget-input');
                const baseValue = parseFloat(input.dataset.base) || KEEPER_BUDGET;
                const currentValue = parseFloat(input.value) || KEEPER_BUDGET;
                const manualAdjustment = currentValue - baseValue;

                if (manualAdjustment !== 0) {
                    manualBudgetAdjustments[teamKey] = manualAdjustment;
                } else {
                    delete manualBudgetAdjustments[teamKey];
                }
            });
            saveManualBudgetAdjustments();

            // Build export object with team details for readability
            const exportData = {
                "_comment": "Fantasy Baseball Civil War - Budget Adjustments for 2026 Season",
                "_updated": new Date().toISOString(),
                "adjustments": {}
            };

            // Add adjustments with team names for clarity
            Object.entries(manualBudgetAdjustments).forEach(([teamKey, adjustment]) => {
                const teamInfo = keeperConfig?.teams[teamKey];
                exportData.adjustments[teamKey] = {
                    team_name: teamInfo?.team_name || 'Unknown',
                    manager: teamInfo?.manager || 'Unknown',
                    adjustment: adjustment
                };
            });

            const jsonString = JSON.stringify(exportData, null, 2);
            document.getElementById('export-budgets-json-content').value = jsonString;
            document.getElementById('export-budgets-modal').style.display = 'flex';
        }

        function closeExportBudgetsModal() {
            document.getElementById('export-budgets-modal').style.display = 'none';
        }

        function copyExportBudgetsJson() {
            const textarea = document.getElementById('export-budgets-json-content');
            textarea.select();
            document.execCommand('copy');
            alert(' Budget adjustments JSON copied to clipboard!');
        }

        function downloadExportBudgetsJson() {
            const content = document.getElementById('export-budgets-json-content').value;
            const blob = new Blob([content], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'budget_adjustments_2026.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ===== KEEPER VALUE ANALYSIS =====

        let expectedPointsByRound = {};
        let keeperValueData = {
            teams: [],
            prospects: [],
            allKeepers: []
        };
        let expectedPointsChart = null;
        let valueScatterChart = null;
        let valueVsCostScatterChart = null;

        async function calculateExpectedPoints() {
            // Load draft data from all years (2019-2025)
            const years = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const weights = {
                2025: 2.0,   // Most recent, highest weight
                2024: 1.75,
                2023: 1.5,
                2022: 1.25,
                2021: 1.0,
                2020: 0.75,  // COVID year, lower weight
                2019: 0.75
            };

            // Load keepers data to exclude from calculations
            let allKeepersData = {};
            try {
                const keepersResponse = await fetch('data/keepers.json');
                if (keepersResponse.ok) {
                    allKeepersData = await keepersResponse.json();
                }
            } catch (e) {
                console.log('Could not load keepers data for exclusion');
            }

            const roundStats = {}; // { round: { totalPoints: 0, totalWeight: 0, picks: [] } }

            for (const year of years) {
                try {
                    // Load draft data
                    const draftPath = year === 2026 
                        ? 'data/historical/2025/draft.json' 
                        : `data/historical/${year}/draft.json`;
                    const draftResponse = await fetch(draftPath);
                    if (!draftResponse.ok) {
                        console.log(`Draft data not found for ${year}: ${draftPath}`);
                        continue;
                    }
                    const draftData = await draftResponse.json();
                    console.log(`Loaded ${draftData.length} draft picks for ${year}`);

                    // Load player stats for that year
                    const statsPath = year === 2026 
                        ? 'data/historical/2025/player_stats.json' 
                        : `data/historical/${year}/player_stats.json`;
                    const statsResponse = await fetch(statsPath);
                    if (!statsResponse.ok) {
                        console.log(`Player stats not found for ${year}: ${statsPath}`);
                        continue;
                    }
                    const statsData = await statsResponse.json();
                    console.log(`Loaded ${statsData.length} player stats for ${year}`);

                    // Create player lookup by name (handle Ohtani special case)
                    const playerStatsByName = {};
                    statsData.forEach(p => {
                        if (p.name) {
                            const nameLower = p.name.toLowerCase().trim();
                            playerStatsByName[nameLower] = p;
                            // Also store without (Batter)/(Pitcher) suffix for matching
                            const baseName = nameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                            if (baseName !== nameLower && !playerStatsByName[baseName]) {
                                playerStatsByName[baseName] = p;
                            }
                        }
                    });

                    // Get keepers for this year to exclude
                    const yearKeepers = allKeepersData[year.toString()] || {};
                    const keeperNamesLower = Object.keys(yearKeepers).map(n => n.toLowerCase().trim());

                    const weight = weights[year] || 1.0;

                    // Process each draft pick
                    draftData.forEach(pick => {
                        const round = pick.round;
                        const playerName = pick.player_name || '';
                        
                        // Skip if this player was a keeper
                        if (keeperNamesLower.includes(playerName.toLowerCase().trim())) {
                            return;
                        }

                        // Find player stats
                        const playerStats = playerStatsByName[playerName.toLowerCase().trim()];
                        const rawFantasyPoints = playerStats?.fantasy_points || 0;
                        
                        // Apply replacement-level floor (200 pts) to handle injured players
                        // This prevents early-round injuries from suppressing expected values
                        const MIN_REPLACEMENT_POINTS = 200;
                        const fantasyPoints = Math.max(rawFantasyPoints, MIN_REPLACEMENT_POINTS);

                        // Initialize round if needed
                        if (!roundStats[round]) {
                            roundStats[round] = { totalPoints: 0, totalWeight: 0, picks: [] };
                        }

                        // Add weighted points
                        roundStats[round].totalPoints += fantasyPoints * weight;
                        roundStats[round].totalWeight += weight;
                        roundStats[round].picks.push({
                            year,
                            player: playerName,
                            points: fantasyPoints,
                            weight
                        });
                    });

                } catch (e) {
                    console.log(`Error processing year ${year}:`, e);
                }
            }

            // Calculate weighted averages
            const result = {};
            for (let round = 1; round <= 23; round++) {
                const stats = roundStats[round];
                if (stats && stats.totalWeight > 0) {
                    result[round] = {
                        avg: Math.round(stats.totalPoints / stats.totalWeight),
                        sampleSize: stats.picks.length,
                        picks: stats.picks
                    };
                } else {
                    result[round] = { avg: 0, sampleSize: 0, picks: [] };
                }
            }

            expectedPointsByRound = result;
            
            // Fit exponential decay model: y = a * e^(-b * x) + c
            // Using least squares fitting on the log-transformed data
            fitExpectedPointsModel(result);
            
            console.log('Expected points by round:', expectedPointsByRound);
            return result;
        }
        
        // Model parameters for expected points prediction
        let expectedPointsModel = { a: 400, b: 0.15, c: 50 };
        
        function fitExpectedPointsModel(data) {
            // Collect data points for fitting
            const points = [];
            for (let round = 1; round <= 23; round++) {
                if (data[round] && data[round].avg > 0) {
                    points.push({ x: round, y: data[round].avg });
                }
            }
            
            if (points.length < 3) return;
            
            // Use iterative least squares to fit y = a * e^(-b * x) + c
            // Start with reasonable initial guesses
            let a = points[0].y - points[points.length - 1].y;
            let b = 0.12;
            let c = points[points.length - 1].y * 0.8;
            
            // Simple gradient descent optimization
            const learningRate = 0.0001;
            const iterations = 1000;
            
            for (let iter = 0; iter < iterations; iter++) {
                let gradA = 0, gradB = 0, gradC = 0;
                
                for (const p of points) {
                    const predicted = a * Math.exp(-b * p.x) + c;
                    const error = predicted - p.y;
                    const expTerm = Math.exp(-b * p.x);
                    
                    gradA += error * expTerm;
                    gradB += error * a * (-p.x) * expTerm;
                    gradC += error;
                }
                
                a -= learningRate * gradA;
                b -= learningRate * 0.01 * gradB; // Smaller learning rate for b
                c -= learningRate * gradC;
                
                // Keep parameters in reasonable bounds
                a = Math.max(100, Math.min(800, a));
                b = Math.max(0.05, Math.min(0.3, b));
                c = Math.max(0, Math.min(200, c));
            }
            
            expectedPointsModel = { a, b, c };
            console.log('Fitted model parameters:', expectedPointsModel);
        }
        
        function predictExpectedPoints(round) {
            const { a, b, c } = expectedPointsModel;
            return Math.round(a * Math.exp(-b * round) + c);
        }
        
        // Get expected points for a round - always uses smoothed model for consistency
        // This eliminates noise like round 7 having fewer expected points than round 8
        function getExpectedPointsForRound(round) {
            // Always use the smoothed exponential model
            return predictExpectedPoints(round);
        }
        
        // Get raw (unsmoothed) expected points - only for charts showing actual vs fitted
        function getRawExpectedPointsForRound(round) {
            return expectedPointsByRound[round]?.avg || predictExpectedPoints(round);
        }

        async function analyzeKeeperValues() {
            const loadingEl = document.getElementById('keeper-value-loading');
            const contentEl = document.getElementById('keeper-value-content');

            if (!loadingEl || !contentEl) {
                console.error('Keeper value elements not found');
                return;
            }

            loadingEl.style.display = 'block';
            contentEl.style.display = 'none';

            // Step 1: Calculate expected points (this should always work)
            try {
                if (Object.keys(expectedPointsByRound).length === 0) {
                    await calculateExpectedPoints();
                }
            } catch (e) {
                console.error('Error calculating expected points:', e);
            }

            // Step 2: Always render expected points chart
            try {
                renderExpectedPointsChart();
            } catch (e) {
                console.error('Error rendering expected points chart:', e);
            }

            // Step 3: Try to load teams data from current season
            let teamsData = [];
            try {
                const teamsResponse = await fetch('data/current_season/teams.json');
                if (teamsResponse.ok) {
                    teamsData = await teamsResponse.json();
                }
            } catch (e) {
                console.log('Could not load teams data:', e);
            }

            // Step 4: Load average projections for keeper displays
            try {
                await loadAverageProjections();
            } catch (e) {
                console.log('Could not load average projections:', e);
            }

            // Step 5: Check if we have keeper selections from Firebase
            const hasKeeperSelections = Object.keys(keeperSelections).length > 0;
            
            if (!hasKeeperSelections) {
                // Show placeholder messages but keep the expected points chart visible
                const rankingsBody = document.getElementById('value-rankings-body');
                if (rankingsBody) {
                    rankingsBody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; font-style: italic; padding: 1rem;">Waiting for keeper selections from Firebase...</td></tr>';
                }
                
                const teamGrid = document.getElementById('team-value-grid');
                if (teamGrid) {
                    teamGrid.innerHTML = '<p style="color: #666; font-style: italic; grid-column: 1 / -1; text-align: center; padding: 2rem;">Team keeper breakdowns will appear once keeper selections have been made.</p>';
                }
                
                const prospectsSection = document.getElementById('prospects-value-section');
                if (prospectsSection) prospectsSection.style.display = 'none';
                
                const scatterWrapper = document.querySelector('.value-scatter-wrapper');
                if (scatterWrapper) scatterWrapper.style.display = 'none';
                
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';
                return;
            }

            // Step 6: Process each team's keepers
            const teamValues = [];
            const allKeepers = [];
            const prospects = [];
            
            // Build a mapping from manager name to keepers (handles 2025 vs 2026 key mismatch)
            const managerToKeepers = {};
            const teamKey2025ToManager = {
                '458.l.4156.t.1': 'Josh B',
                '458.l.4156.t.2': 'Ryan',
                '458.l.4156.t.3': 'Coleman',
                '458.l.4156.t.4': 'Riley',
                '458.l.4156.t.5': 'Dalton',
                '458.l.4156.t.6': 'Robert',
                '458.l.4156.t.7': 'Tyler',
                '458.l.4156.t.8': 'Dylan',
                '458.l.4156.t.9': 'Red',
                '458.l.4156.t.10': 'Logan S',
                '458.l.4156.t.11': 'Rich',
                '458.l.4156.t.12': 'Nate'
            };
            
            for (const [teamKey, keepers] of Object.entries(keeperSelections)) {
                const manager = teamKey2025ToManager[teamKey];
                if (manager) {
                    managerToKeepers[manager.toLowerCase()] = keepers;
                }
            }
            console.log('Value Suite - Manager to keepers mapping:', Object.keys(managerToKeepers));

            for (const team of teamsData) {
                // Look up keepers by manager name (handles key mismatch between seasons)
                const managerName = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                const teamKeepers = managerToKeepers[managerName.toLowerCase()] || keeperSelections[team.team_key] || [];
                
                if (teamKeepers.length === 0) continue;
                
                // Find the keeperConfig team key for this manager
                let keeperConfigTeamKey = team.team_key;
                if (keeperConfig && keeperConfig.teams) {
                    for (const [configKey, configTeam] of Object.entries(keeperConfig.teams)) {
                        const configManager = normalizeManagerName(configTeam.manager, 2026, configTeam.team_name, configKey);
                        if (configManager.toLowerCase() === managerName.toLowerCase()) {
                            keeperConfigTeamKey = configKey;
                            break;
                        }
                    }
                }

                // Calculate actual round costs (accounting for bumping when rounds are used)
                const actualRoundCosts = calculateTeamKeeperRoundCosts(keeperConfigTeamKey);
                const actualRoundMap = {};
                actualRoundCosts.forEach(rc => {
                    actualRoundMap[rc.player_name.toLowerCase()] = rc.actualRoundCost;
                });

                let totalProjected = 0;
                let totalExpected = 0;
                const keeperDetails = [];

                for (const keeper of teamKeepers) {
                    // Use average projection across all systems
                    const projectedPts = getAverageProjection(keeper.player_name);
                    
                    const isProspect = keeper.isProspect || false;
                    // Use actual round cost (after bumping) instead of base round cost
                    const baseRoundCost = keeper.roundCost || 0;
                    const actualRoundCost = actualRoundMap[keeper.player_name.toLowerCase()] ?? baseRoundCost;
                    const roundCost = isProspect ? 0 : actualRoundCost;
                    const expectedPts = isProspect ? 0 : getExpectedPointsForRound(roundCost);
                    
                    // Keeper value = Projected Points + Surplus Value
                    // This captures their full contribution: what they'll produce PLUS the bonus of getting them at a discount
                    // For example: 400pt player kept in round 5 (expected 350) = 400 + (400-350) = 450 value
                    const surplusValue = projectedPts - expectedPts;
                    const value = projectedPts + surplusValue;  // = 2 * projectedPts - expectedPts

                    const keeperData = {
                        player_name: keeper.player_name,
                        team_key: team.team_key,
                        team_name: team.team_name,
                        manager: team.manager,
                        team_logo: fixTeamLogo(team.team_logo),
                        position: keeper.position || '',
                        roundCost: roundCost,
                        baseRoundCost: baseRoundCost,
                        isProspect: isProspect,
                        projectedPts: projectedPts,
                        expectedPts: expectedPts,
                        surplusValue: surplusValue,
                        value: value
                    };

                    if (isProspect) {
                        prospects.push(keeperData);
                    } else {
                        keeperDetails.push(keeperData);
                        allKeepers.push(keeperData);
                        totalProjected += projectedPts;
                        totalExpected += expectedPts;
                    }
                }

                // Sort keepers by round
                keeperDetails.sort((a, b) => a.roundCost - b.roundCost);

                if (keeperDetails.length > 0) {
                    // Calculate total keeper value (sum of individual keeper values)
                    const totalKeeperValue = keeperDetails.reduce((sum, k) => sum + k.value, 0);
                    
                    // Find the keeperConfig team key for this manager (needed for getTeamPicks and calculateTeamKeeperRoundCosts)
                    // teamPicksOwned uses keys from keeperConfig.teams, which may be 2025 or 2026 keys
                    let keeperConfigTeamKey = team.team_key; // default to current team key
                    if (keeperConfig && keeperConfig.teams) {
                        for (const [configKey, configTeam] of Object.entries(keeperConfig.teams)) {
                            const configManager = normalizeManagerName(configTeam.manager, 2026, configTeam.team_name, configKey);
                            if (configManager.toLowerCase() === managerName.toLowerCase()) {
                                keeperConfigTeamKey = configKey;
                                break;
                            }
                        }
                    }
                    
                    // Calculate pick value for this team (use keeperConfig key for picks lookup)
                    const teamPicks = getTeamPicks(keeperConfigTeamKey) || [];
                    const roundCostsForTeam = calculateTeamKeeperRoundCosts(keeperConfigTeamKey);
                    
                    console.log(`${managerName}: keeperConfigTeamKey=${keeperConfigTeamKey}, picks=${teamPicks.length}`);
                    
                    // Count used rounds
                    const usedRounds = {};
                    roundCostsForTeam.forEach(rc => {
                        usedRounds[rc.actualRoundCost] = (usedRounds[rc.actualRoundCost] || 0) + 1;
                    });
                    
                    // Count available picks at each round
                    const pickCounts = {};
                    teamPicks.forEach(pick => {
                        pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
                    });
                    
                    console.log(`${managerName} pick calc: usedRounds=`, usedRounds, 'pickCounts=', pickCounts);
                    
                    // Calculate total unused pick value
                    let totalPickValue = 0;
                    Object.keys(pickCounts).forEach(round => {
                        const roundNum = parseInt(round);
                        const available = pickCounts[roundNum] || 0;
                        const used = usedRounds[roundNum] || 0;
                        const unused = available - used;
                        if (unused > 0) {
                            const expectedPts = getExpectedPointsForRound(roundNum);
                            console.log(`  Round ${roundNum}: available=${available}, used=${used}, unused=${unused}, expectedPts=${expectedPts}`);
                            totalPickValue += expectedPts * unused;
                        }
                    });
                    
                    console.log(`${managerName} totalPickValue: ${totalPickValue}`);
                    
                    teamValues.push({
                        team_key: team.team_key,
                        keeper_config_key: keeperConfigTeamKey, // Key to use for getTeamPicks and keeperSelections
                        team_name: team.team_name,
                        manager: capitalizeManagerName(managerName || team.manager || 'Unknown'),
                        team_logo: fixTeamLogo(team.team_logo),
                        keepers: keeperDetails,
                        totalProjected: totalProjected,
                        totalExpected: totalExpected,
                        totalValue: totalKeeperValue,
                        totalPickValue: totalPickValue,
                        combinedTotal: totalKeeperValue + totalPickValue,
                        keeperCount: keeperDetails.length
                    });
                }
            }

            // Sort teams by combined total (keeper value + pick value)
            teamValues.sort((a, b) => b.combinedTotal - a.combinedTotal);

            // Sort prospects by projected points
            prospects.sort((a, b) => b.projectedPts - a.projectedPts);

            keeperValueData = {
                teams: teamValues,
                prospects: prospects,
                allKeepers: allKeepers
            };

            // Step 7: Render all components
            try {
                renderValueRankings(teamValues);
                // Apply initial sort by Total descending
                // Reset sort state first to ensure descending order
                valueRankingsSortColumn = '';
                sortValueRankings('total');
            } catch (e) {
                console.error('Error rendering value rankings:', e);
            }
            
            try {
                // Render Position Value chart
                positionValueData = null; // Reset to recalculate
                renderPositionValueChart();
            } catch (e) {
                console.error('Error rendering position value chart:', e);
            }
            
            try {
                renderTeamValueCards(teamValues);
            } catch (e) {
                console.error('Error rendering team value cards:', e);
            }
            
            try {
                renderProspectsSection(prospects);
            } catch (e) {
                console.error('Error rendering prospects section:', e);
            }
            
            try {
                const scatterWrapper = document.querySelector('.value-scatter-wrapper');
                if (scatterWrapper) scatterWrapper.style.display = 'block';
                renderValueScatterChart(allKeepers, prospects);
                renderValueVsCostScatterChart(allKeepers, prospects);
            } catch (e) {
                console.error('Error rendering scatter chart:', e);
            }

            loadingEl.style.display = 'none';
            contentEl.style.display = 'block';
        }

        function renderExpectedPointsChart() {
            const ctx = document.getElementById('expected-points-chart');
            if (!ctx) {
                console.log('Expected points chart canvas not found');
                return;
            }

            // Destroy existing chart
            if (expectedPointsChart) {
                expectedPointsChart.destroy();
            }

            const rounds = Object.keys(expectedPointsByRound).map(Number).sort((a, b) => a - b);
            const data = rounds.map(r => expectedPointsByRound[r]?.avg || 0);
            
            console.log('Rendering expected points chart with', rounds.length, 'rounds');
            
            // If no data yet, show a message
            if (rounds.length === 0) {
                const container = ctx.parentElement;
                if (container) {
                    container.innerHTML = '<p style="color: #666; text-align: center; padding: 2rem;">Loading historical draft data...</p><canvas id="expected-points-chart"></canvas>';
                }
                return;
            }
            
            // Create gradient for bars
            const chartArea = ctx.getContext('2d');
            const gradient = chartArea.createLinearGradient(0, 0, ctx.width, 0);
            gradient.addColorStop(0, 'rgba(0, 72, 186, 0.85)');    // Retro blue for early rounds
            gradient.addColorStop(0.5, 'rgba(26, 92, 214, 0.75)');  // Medium retro blue
            gradient.addColorStop(1, 'rgba(80, 140, 220, 0.65)');  // Light blue for late rounds
            
            // Create individual bar colors based on round
            const barColors = rounds.map((r, i) => {
                const ratio = i / (rounds.length - 1);
                const r1 = Math.round(0 + ratio * 80);
                const g1 = Math.round(72 + ratio * 68);
                const b1 = Math.round(186 + ratio * 34);
                return `rgba(${r1}, ${g1}, ${b1}, 0.8)`;
            });

            expectedPointsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: rounds.map(r => `${r}`),
                    datasets: [
                        {
                            label: 'Historical Average',
                            data: data,
                            backgroundColor: barColors,
                            borderRadius: 3,
                            order: 2
                        },
                        {
                            label: 'Model Prediction',
                            data: rounds.map(r => predictExpectedPoints(r)),
                            type: 'line',
                            borderColor: 'rgba(220, 53, 69, 0.9)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                padding: 8,
                                font: { size: 10 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const round = context.dataIndex + 1;
                                    if (context.dataset.label === 'Model Prediction') {
                                        return `Model: ${context.raw} pts`;
                                    }
                                    const stats = expectedPointsByRound[round];
                                    return [
                                        `Actual: ${stats?.avg || 0} pts`,
                                        `Sample: ${stats?.sampleSize || 0} picks`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            min: 100,
                            max: 400,
                            title: {
                                display: true,
                                text: 'Points',
                                font: { size: 10 }
                            },
                            ticks: { font: { size: 9 } }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Round',
                                font: { size: 10 }
                            },
                            ticks: { font: { size: 9 } }
                        }
                    }
                }
            });
        }

        // Position Value Chart
        let positionValueChart = null;
        let positionValueChartType = 'bar';
        let positionValueData = null;
        
        // Position colors (matching CSS variables)
        const positionColors = {
            'C':  { dark: '#4a148c', light: 'rgba(74, 20, 140, 0.3)' },
            '1B': { dark: '#1565c0', light: 'rgba(21, 101, 192, 0.3)' },
            '2B': { dark: '#e65100', light: 'rgba(230, 81, 0, 0.3)' },
            '3B': { dark: '#b71c1c', light: 'rgba(183, 28, 28, 0.3)' },
            'SS': { dark: '#9c7c00', light: 'rgba(200, 160, 0, 0.3)' },
            'OF': { dark: '#2e7d32', light: 'rgba(46, 125, 50, 0.3)' },
            'SP': { dark: '#7e57c2', light: 'rgba(126, 87, 194, 0.3)' },
            'RP': { dark: '#00838f', light: 'rgba(0, 131, 143, 0.3)' }
        };
        
        // Playable roster spots per position
        const playableSpots = {
            'C': 12, '1B': 15, '2B': 15, 'SS': 15, '3B': 15, 'OF': 45, 'SP': 90, 'RP': 12
        };
        
        function setPositionValueChartType(type) {
            positionValueChartType = type;
            
            // Update toggle buttons
            document.getElementById('pos-value-bar-btn').classList.toggle('active', type === 'bar');
            document.getElementById('pos-value-line-btn').classList.toggle('active', type === 'line');
            
            // Re-render chart
            renderPositionValueChart();
        }
        
        function calculatePositionValueData() {
            // First try to use averageProjectionsMap (averaged across all systems)
            // Fall back to currently loaded projections if averages not available
            
            let useAverages = Object.keys(averageProjectionsMap).length > 0;
            
            if (!useAverages && allProjectionBatters.length === 0 && allProjectionPitchers.length === 0) {
                console.log('No projection data available for position value chart');
                return null;
            }
            
            // Group players by position
            const positionPlayers = {
                'C': [], '1B': [], '2B': [], '3B': [], 'SS': [], 'OF': [], 'SP': [], 'RP': []
            };
            
            if (useAverages) {
                // Use averaged projections from all systems
                Object.entries(averageProjectionsMap).forEach(([name, data]) => {
                    if (!data.avgPoints || data.avgPoints <= 0) return;
                    
                    const position = data.position || '';
                    const positions = position.split(/[,\/]/).map(p => p.trim().toUpperCase());
                    const playerData = { name, points: data.avgPoints };
                    
                    // Add to appropriate position buckets based on type
                    if (data.type === 'batter') {
                        if (positions.includes('C')) positionPlayers['C'].push(playerData);
                        if (positions.includes('1B')) positionPlayers['1B'].push(playerData);
                        if (positions.includes('2B')) positionPlayers['2B'].push(playerData);
                        if (positions.includes('3B')) positionPlayers['3B'].push(playerData);
                        if (positions.includes('SS')) positionPlayers['SS'].push(playerData);
                        if (positions.includes('OF') || positions.includes('LF') || positions.includes('CF') || positions.includes('RF')) {
                            positionPlayers['OF'].push(playerData);
                        }
                    } else if (data.type === 'pitcher') {
                        if (positions.includes('SP')) positionPlayers['SP'].push(playerData);
                        if (positions.includes('RP')) positionPlayers['RP'].push(playerData);
                    }
                });
                
                console.log('Using averaged projections for position value chart');
            } else {
                // Fall back to currently loaded projection data
                allProjectionBatters.forEach(player => {
                    if (!player.projected_points || player.projected_points <= 0) return;
                    
                    const position = player.position || '';
                    const positions = position.split(/[,\/]/).map(p => p.trim().toUpperCase());
                    const playerData = { name: player.name, points: player.projected_points };
                    
                    if (positions.includes('C')) positionPlayers['C'].push(playerData);
                    if (positions.includes('1B')) positionPlayers['1B'].push(playerData);
                    if (positions.includes('2B')) positionPlayers['2B'].push(playerData);
                    if (positions.includes('3B')) positionPlayers['3B'].push(playerData);
                    if (positions.includes('SS')) positionPlayers['SS'].push(playerData);
                    if (positions.includes('OF') || positions.includes('LF') || positions.includes('CF') || positions.includes('RF')) {
                        positionPlayers['OF'].push(playerData);
                    }
                });
                
                allProjectionPitchers.forEach(player => {
                    if (!player.projected_points || player.projected_points <= 0) return;
                    
                    const position = player.position || '';
                    const positions = position.split(/[,\/]/).map(p => p.trim().toUpperCase());
                    const playerData = { name: player.name, points: player.projected_points };
                    
                    if (positions.includes('SP')) positionPlayers['SP'].push(playerData);
                    if (positions.includes('RP')) positionPlayers['RP'].push(playerData);
                });
                
                console.log('Using current projection system for position value chart');
            }
            
            // Calculate stats for each position
            const positionStats = {};
            
            Object.keys(playableSpots).forEach(pos => {
                const players = positionPlayers[pos];
                // Sort by points descending and take top N playable spots
                players.sort((a, b) => b.points - a.points);
                const topPlayers = players.slice(0, playableSpots[pos]);
                
                if (topPlayers.length === 0) {
                    positionStats[pos] = { avg: 0, stdDev: 0, players: [], count: 0 };
                    return;
                }
                
                // Calculate average
                const sum = topPlayers.reduce((acc, p) => acc + p.points, 0);
                const avg = sum / topPlayers.length;
                
                // Calculate standard deviation
                const squaredDiffs = topPlayers.map(p => Math.pow(p.points - avg, 2));
                const avgSquaredDiff = squaredDiffs.reduce((acc, v) => acc + v, 0) / topPlayers.length;
                const stdDev = Math.sqrt(avgSquaredDiff);
                
                positionStats[pos] = {
                    avg: Math.round(avg * 10) / 10,
                    stdDev: Math.round(stdDev * 10) / 10,
                    players: topPlayers,
                    count: topPlayers.length
                };
            });
            
            console.log('Position value data calculated:', Object.keys(positionStats).map(p => `${p}: ${positionStats[p].count} players, avg=${positionStats[p].avg}`));
            
            return positionStats;
        }
        
        function renderPositionValueChart() {
            const ctx = document.getElementById('position-value-chart');
            if (!ctx) return;
            
            // Calculate data if not already done
            if (!positionValueData) {
                positionValueData = calculatePositionValueData();
            }
            
            if (!positionValueData) return;
            
            // Destroy existing chart
            if (positionValueChart) {
                positionValueChart.destroy();
            }
            
            if (positionValueChartType === 'bar') {
                renderPositionValueBarChart(ctx, positionValueData);
            } else {
                renderPositionValueLineChart(ctx, positionValueData);
            }
        }
        
        function renderPositionValueBarChart(ctx, data) {
            // Sort positions by average descending
            const sortedPositions = Object.keys(data)
                .filter(pos => data[pos].count > 0)
                .sort((a, b) => data[b].avg - data[a].avg);
            
            const labels = sortedPositions;
            const averages = sortedPositions.map(pos => data[pos].avg);
            const stdDevs = sortedPositions.map(pos => data[pos].stdDev);
            const barColors = sortedPositions.map(pos => positionColors[pos].dark);
            const bgColors = sortedPositions.map(pos => positionColors[pos].light);
            
            // Create floating bar data for std dev range [avg - stdDev, avg + stdDev]
            const stdDevRanges = sortedPositions.map(pos => {
                const avg = data[pos].avg;
                const std = data[pos].stdDev;
                return [avg - std, avg + std];
            });
            
            // Custom plugin to draw bottom border on floating bars
            const floatingBarBottomBorder = {
                id: 'floatingBarBottomBorder',
                afterDatasetsDraw: function(chart) {
                    const ctx = chart.ctx;
                    const meta = chart.getDatasetMeta(0); // First dataset is the floating bar
                    
                    meta.data.forEach((bar, index) => {
                        const borderColor = sortedPositions[index] ? positionColors[sortedPositions[index]].dark : '#333';
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.strokeStyle = borderColor;
                        ctx.lineWidth = 1;
                        
                        // Draw line at the bottom of the floating bar
                        // For floating bars, bar.base is the bottom (lower value) y pixel position
                        const x = bar.x - bar.width / 2;
                        const y = bar.base; // base is the lower value of the floating bar
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + bar.width, y);
                        ctx.stroke();
                        ctx.restore();
                    });
                }
            };
            
            positionValueChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: '1 Std Dev Range',
                            data: stdDevRanges,
                            backgroundColor: bgColors,
                            borderColor: sortedPositions.map(pos => positionColors[pos].dark),
                            borderWidth: 1,
                            barPercentage: 0.8,
                            categoryPercentage: 0.85
                        },
                        {
                            label: 'Average Projection',
                            data: averages,
                            backgroundColor: barColors,
                            borderColor: barColors.map(c => c),
                            borderWidth: 1,
                            barPercentage: 0.45,
                            categoryPercentage: 0.85
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                padding: 10,
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const pos = context[0].label;
                                    return `${pos} (Top ${playableSpots[pos]} players)`;
                                },
                                label: function(context) {
                                    const pos = context.label;
                                    const posData = data[pos];
                                    if (context.dataset.label === 'Average Projection') {
                                        return `Average: ${posData.avg} pts`;
                                    } else {
                                        return `1 Range: ${Math.round(posData.avg - posData.stdDev)} - ${Math.round(posData.avg + posData.stdDev)} pts`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            stacked: false,
                            // Set min to be slightly below the lowest std dev range
                            min: Math.floor(Math.min(...stdDevRanges.map(r => r[0])) / 50) * 50 - 50,
                            title: {
                                display: true,
                                text: 'Projected Points',
                                font: { size: 11 }
                            },
                            ticks: { font: { size: 10 } }
                        },
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Position',
                                font: { size: 11 }
                            },
                            ticks: {
                                font: { size: 11, weight: 'bold' },
                                color: function(context) {
                                    const pos = sortedPositions[context.index];
                                    return positionColors[pos]?.dark || '#333';
                                }
                            }
                        }
                    }
                },
                plugins: [floatingBarBottomBorder]
            });
        }
        
        function renderPositionValueLineChart(ctx, data) {
            // Sort positions by highest projected player descending
            const sortedPositions = Object.keys(data)
                .filter(pos => data[pos].players && data[pos].players.length > 0)
                .sort((a, b) => {
                    const maxA = data[a].players[0]?.points || 0;
                    const maxB = data[b].players[0]?.points || 0;
                    return maxB - maxA;
                });
            
            // Create datasets for each position
            const datasets = sortedPositions.map((pos, idx) => {
                const players = data[pos].players;
                const numPlayers = players.length;
                
                // Create percentile data points (0 = worst, 100 = best)
                // X axis: percentile rank, Y axis: projected points
                const lineData = players.map((p, i) => ({
                    x: 100 - (i / (numPlayers - 1 || 1)) * 100, // 100% = best, 0% = worst
                    y: p.points,
                    player: p.name,
                    rank: i + 1
                }));
                
                return {
                    label: pos,
                    data: lineData,
                    borderColor: positionColors[pos].dark,
                    backgroundColor: positionColors[pos].light,
                    borderWidth: 2,
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    fill: false,
                    tension: 0.3,
                    order: idx
                };
            });
            
            positionValueChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                boxWidth: 16,
                                padding: 8,
                                font: { size: 11, weight: 'bold' },
                                color: function(context) {
                                    const pos = context.text;
                                    return positionColors[pos]?.dark || '#333';
                                },
                                generateLabels: function(chart) {
                                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                    return original.map(label => {
                                        label.fillStyle = positionColors[label.text]?.dark || label.fillStyle;
                                        label.strokeStyle = positionColors[label.text]?.dark || label.strokeStyle;
                                        return label;
                                    });
                                }
                            },
                            onHover: function(e, legendItem, legend) {
                                const chart = legend.chart;
                                const index = legendItem.datasetIndex;
                                chart.data.datasets.forEach((dataset, i) => {
                                    dataset.borderWidth = i === index ? 4 : 1;
                                    dataset.borderColor = i === index 
                                        ? positionColors[dataset.label]?.dark 
                                        : positionColors[dataset.label]?.light;
                                });
                                chart.update('none');
                            },
                            onLeave: function(e, legendItem, legend) {
                                const chart = legend.chart;
                                chart.data.datasets.forEach((dataset) => {
                                    dataset.borderWidth = 2;
                                    dataset.borderColor = positionColors[dataset.label]?.dark;
                                });
                                chart.update('none');
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const point = context[0].raw;
                                    return `${context[0].dataset.label} #${point.rank}`;
                                },
                                label: function(context) {
                                    const point = context.raw;
                                    return [
                                        point.player,
                                        `${Math.round(point.y)} projected pts`,
                                        `${Math.round(point.x)}th percentile`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Projected Points',
                                font: { size: 11 }
                            },
                            ticks: { font: { size: 10 } }
                        },
                        x: {
                            type: 'linear',
                            min: 0,
                            max: 100,
                            reverse: false,
                            title: {
                                display: true,
                                text: 'Percentile Rank (100% = Best)',
                                font: { size: 11 }
                            },
                            ticks: {
                                font: { size: 10 },
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderValueRankings(teamValues) {
            const tbody = document.getElementById('value-rankings-body');
            if (!tbody) return;
            
            // Build headshot lookup - use averageProjectionsMap which has headshots, fallback to current projections
            const headshotLookup = {};
            
            // First add from averageProjectionsMap
            Object.entries(averageProjectionsMap).forEach(([name, data]) => {
                if (data.headshot) {
                    headshotLookup[name] = data.headshot;
                }
            });
            
            // Fallback: also check current projection data
            [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                if (p.name && p.headshot_url) {
                    const nameLower = p.name.toLowerCase().trim();
                    if (!headshotLookup[nameLower]) {
                        headshotLookup[nameLower] = p.headshot_url;
                    }
                    // Also store without (Batter)/(Pitcher) suffix
                    const baseName = nameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                    if (baseName !== nameLower && !headshotLookup[baseName]) {
                        headshotLookup[baseName] = p.headshot_url;
                    }
                }
            });
            
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            tbody.innerHTML = teamValues.map((team, idx) => {
                // Keeper value is now total value (always positive), no need for prefix
                const keeperValueClass = 'value-positive';
                
                // Get top 3 best value players on this team
                const topPlayers = [...team.keepers]
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 3);
                
                const topPlayersHtml = topPlayers.map(player => {
                    const playerNameLower = player.player_name.toLowerCase().trim();
                    const baseNameLower = playerNameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                    const headshot = headshotLookup[playerNameLower] || headshotLookup[baseNameLower] || placeholderImg;
                    // Color based on surplus value
                    const playerValueClass = player.surplusValue > 0 ? 'value-positive' : player.surplusValue < 0 ? 'value-negative' : 'value-neutral';
                    const displayName = player.player_name.replace(/\s*\(Batter\)|\s*\(Pitcher\)/gi, '');
                    
                    return `
                        <div class="best-player-cell">
                            <img src="${headshot}" class="player-headshot-mini" alt="" onerror="this.src='${placeholderImg}'">
                            <div class="player-info">
                                <span class="player-name">${displayName}</span>
                                <span class="player-details">${getPositionBadge(player.position, player.player_name)} Rd ${player.roundCost}</span>
                            </div>
                            <span class="player-value ${playerValueClass}">${Math.round(player.value)}</span>
                        </div>
                    `;
                }).join('');
                
                // Get team's available picks and calculate which ones are NOT used for keepers
                // Use keeper_config_key for lookups (handles 2025 vs 2026 key mismatch)
                const lookupKey = team.keeper_config_key || team.team_key;
                const teamPicks = getTeamPicks(lookupKey) || [];
                const teamKeepers = keeperSelections[lookupKey] || [];
                const nonProspectKeepers = teamKeepers.filter(k => !k.isProspect);
                
                // Calculate which rounds are used by keepers
                const usedRounds = {};
                const roundCosts = calculateTeamKeeperRoundCosts(lookupKey);
                roundCosts.forEach(rc => {
                    usedRounds[rc.actualRoundCost] = (usedRounds[rc.actualRoundCost] || 0) + 1;
                });
                
                // Count available picks at each round
                const pickCounts = {};
                teamPicks.forEach(pick => {
                    pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
                });
                
                // Find unused picks (available picks minus keeper-used picks)
                const unusedPicks = [];
                Object.keys(pickCounts).forEach(round => {
                    const roundNum = parseInt(round);
                    const available = pickCounts[roundNum] || 0;
                    const used = usedRounds[roundNum] || 0;
                    const unused = available - used;
                    for (let i = 0; i < unused; i++) {
                        unusedPicks.push({
                            round: roundNum,
                            expectedPts: getExpectedPointsForRound(roundNum)
                        });
                    }
                });
                
                // Sort by expected points (highest value first) and take top 3
                unusedPicks.sort((a, b) => b.expectedPts - a.expectedPts);
                const topPicks = unusedPicks.slice(0, 3);
                
                // Calculate total pick value for team total
                const totalPickValue = unusedPicks.reduce((sum, p) => sum + p.expectedPts, 0);
                const draftValueClass = totalPickValue > 0 ? 'value-positive' : 'value-neutral';
                
                const combinedTotal = team.totalValue + totalPickValue;
                // Combined total is always positive now
                const combinedValueClass = 'value-positive';
                
                const topPicksHtml = topPicks.length > 0 ? topPicks.map(pick => `
                    <div class="pick-value-item">
                        <div class="pick-circle">${pick.round}</div>
                        <span class="pick-expected">${Math.round(pick.expectedPts)}</span>
                    </div>
                `).join('') : '<span style="color:#999;font-size:0.7rem;"></span>';

                return `
                    <tr data-keeper-value="${team.totalValue}" data-draft-value="${totalPickValue}" data-total="${combinedTotal}">
                        <td>
                            <div class="team-cell">
                                ${team.team_logo ? `<img src="${fixTeamLogo(team.team_logo)}" class="team-logo-small" alt="">` : ''}
                                <div>
                                    <div style="font-weight: 500;">${team.team_name}</div>
                                    <div style="font-size: 0.7rem; color: #666;">${team.manager}</div>
                                </div>
                            </div>
                        </td>
                        <td><div class="top-players-cell">${topPlayersHtml}</div></td>
                        <td class="value-cell ${keeperValueClass}">${Math.round(team.totalValue)}</td>
                        <td><div class="top-picks-cell">${topPicksHtml}</div></td>
                        <td class="value-cell ${draftValueClass}">${Math.round(totalPickValue)}</td>
                        <td class="value-cell ${combinedValueClass}">${Math.round(combinedTotal)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Sorting state for value rankings
        let valueRankingsSortColumn = 'total';
        let valueRankingsSortDirection = 'desc';
        
        function sortValueRankings(column) {
            const table = document.getElementById('value-rankings-table');
            const tbody = document.getElementById('value-rankings-body');
            if (!table || !tbody) return;
            
            // Toggle direction if same column, otherwise default to desc
            if (valueRankingsSortColumn === column) {
                valueRankingsSortDirection = valueRankingsSortDirection === 'desc' ? 'asc' : 'desc';
            } else {
                valueRankingsSortColumn = column;
                valueRankingsSortDirection = 'desc';
            }
            
            // Update header icons
            table.querySelectorAll('.sortable-header').forEach(th => {
                const icon = th.querySelector('.sort-icon');
                if (th.dataset.sort === column) {
                    th.classList.add('active');
                    icon.textContent = valueRankingsSortDirection === 'desc' ? '' : '';
                } else {
                    th.classList.remove('active');
                    icon.textContent = '';
                }
            });
            
            // Get rows and sort
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            rows.sort((a, b) => {
                let aVal, bVal;
                if (column === 'keeperValue') {
                    aVal = parseFloat(a.dataset.keeperValue) || 0;
                    bVal = parseFloat(b.dataset.keeperValue) || 0;
                } else if (column === 'draftValue') {
                    aVal = parseFloat(a.dataset.draftValue) || 0;
                    bVal = parseFloat(b.dataset.draftValue) || 0;
                } else {
                    aVal = parseFloat(a.dataset.total) || 0;
                    bVal = parseFloat(b.dataset.total) || 0;
                }
                return valueRankingsSortDirection === 'desc' ? bVal - aVal : aVal - bVal;
            });
            
            // Re-append rows in new order
            rows.forEach(row => {
                tbody.appendChild(row);
            });
        }

        function renderTeamValueCards(teamValues) {
            const container = document.getElementById('team-value-grid');
            if (!container) return;

            container.innerHTML = teamValues.map(team => {
                // Total value is now always positive (projected + surplus), so just use positive styling
                const valueClass = 'positive';

                const keepersHtml = team.keepers.map(k => {
                    // Color based on surplus (above/below expected), but display total value
                    const kValueClass = k.surplusValue > 0 ? 'value-positive' : k.surplusValue < 0 ? 'value-negative' : 'value-neutral';
                    
                    return `
                        <tr>
                            <td>
                                <div class="player-cell">
                                    ${getPositionBadge(k.position, k.player_name)}
                                    <span>${k.player_name}</span>
                                </div>
                            </td>
                            <td>Rd ${k.roundCost}</td>
                            <td>${Math.round(k.projectedPts)}</td>
                            <td>${Math.round(k.expectedPts)}</td>
                            <td class="${kValueClass}">${Math.round(k.value)}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <div class="team-value-card">
                        <div class="team-value-card-header">
                            <div class="team-info">
                                ${team.team_logo ? `<img src="${fixTeamLogo(team.team_logo)}" class="team-logo" alt="">` : ''}
                                <div>
                                    <div class="team-name">${team.team_name}</div>
                                    <div class="team-manager">${team.manager}</div>
                                </div>
                            </div>
                            <div class="total-value ${valueClass}">${Math.round(team.totalValue)}</div>
                        </div>
                        <div class="team-value-card-body">
                            <table class="team-value-table">
                                <thead>
                                    <tr>
                                        <th>Player</th>
                                        <th>Cost</th>
                                        <th>Proj</th>
                                        <th>Exp</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${keepersHtml}
                                </tbody>
                            </table>
                        </div>
                        <div class="team-value-card-footer">
                            <div>
                                <span class="label">Total Projected:</span>
                                <span class="value">${Math.round(team.totalProjected)} pts</span>
                            </div>
                            <div>
                                <span class="label">Expected:</span>
                                <span class="value">${Math.round(team.totalExpected)} pts</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderProspectsSection(prospects) {
            const section = document.getElementById('prospects-value-section');
            const grid = document.getElementById('prospects-value-grid');
            if (!section || !grid) return;

            // Filter out prospects with 0 projected points
            const displayProspects = prospects.filter(p => p.projectedPts > 0);

            if (displayProspects.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            grid.innerHTML = displayProspects.map(p => `
                <div class="prospect-value-item">
                    <div class="prospect-info">
                        ${p.team_logo ? `<img src="${p.team_logo}" class="prospect-team-logo" alt="">` : ''}
                        <span>${p.player_name}</span>
                    </div>
                    <span class="prospect-pts">+${Math.round(p.projectedPts)}</span>
                </div>
            `).join('');
        }

        function renderValueScatterChart(keepers, prospects) {
            const ctx = document.getElementById('value-scatter-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (valueScatterChart) {
                valueScatterChart.destroy();
            }

            // Prepare data points for regular keepers
            // Use surplusValue for color coding (above/below expected line)
            const keeperPoints = keepers.map(k => ({
                x: k.roundCost,
                y: k.projectedPts,
                player: k.player_name,
                team: k.team_name,
                value: k.value,
                surplusValue: k.surplusValue,
                expected: k.expectedPts
            }));

            // Prepare data points for prospects (x = 24 to put them after round 23)
            // Only include prospects with projected points > 0
            const prospectPoints = prospects.filter(p => p.projectedPts > 0).map(p => ({
                x: 24,
                y: p.projectedPts,
                player: p.player_name,
                team: p.team_name,
                value: p.projectedPts,
                surplusValue: p.projectedPts,
                expected: 0
            }));

            // Expected value line data (using smoothed model for clean curve)
            const expectedLine = [];
            for (let r = 1; r <= 23; r++) {
                expectedLine.push({
                    x: r,
                    y: getExpectedPointsForRound(r)
                });
            }

            valueScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Above Expected',
                            data: keeperPoints.filter(p => p.surplusValue > 0),
                            backgroundColor: 'rgba(40, 167, 69, 0.7)',
                            borderColor: 'rgba(40, 167, 69, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                        },
                        {
                            label: 'Below Expected',
                            data: keeperPoints.filter(p => p.surplusValue <= 0),
                            backgroundColor: 'rgba(220, 53, 69, 0.7)',
                            borderColor: 'rgba(220, 53, 69, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                        },
                        {
                            label: 'Prospects (Free)',
                            data: prospectPoints,
                            backgroundColor: 'rgba(23, 162, 184, 0.7)',
                            borderColor: 'rgba(23, 162, 184, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointStyle: 'triangle',
                        },
                        {
                            label: 'Expected Value',
                            data: expectedLine,
                            type: 'line',
                            borderColor: 'rgba(30, 60, 114, 0.5)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    if (!point.player) return `Expected: ${point.y} pts`;
                                    const valuePrefix = point.value > 0 ? '+' : '';
                                    return [
                                        `${point.player}`,
                                        `Team: ${point.team}`,
                                        `Projected: ${Math.round(point.y)} pts`,
                                        `Expected: ${Math.round(point.expected)} pts`,
                                        `Value: ${valuePrefix}${Math.round(point.value)}`
                                    ];
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Keeper Cost (Round)'
                            },
                            min: 0.5,
                            max: 25,
                            ticks: {
                                callback: function(value) {
                                    if (value === 24) return 'Free';
                                    if (value % 2 === 0 || value === 1) return value;
                                    return '';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Projected Points'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        function renderValueVsCostScatterChart(keepers, prospects) {
            const ctx = document.getElementById('value-vs-cost-scatter-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (valueVsCostScatterChart) {
                valueVsCostScatterChart.destroy();
            }

            // Prepare data points for regular keepers - Y axis is now VALUE
            const keeperPoints = keepers.map(k => ({
                x: k.roundCost,
                y: k.value,  // Total value (projected + surplus)
                player: k.player_name,
                team: k.team_name,
                value: k.value,
                surplusValue: k.surplusValue,
                projectedPts: k.projectedPts,
                expected: k.expectedPts
            }));

            // Prepare data points for prospects (x = 24 to put them after round 23)
            // For prospects, value = projected points (since they're free)
            const prospectPoints = prospects.filter(p => p.projectedPts > 0).map(p => ({
                x: 24,
                y: p.projectedPts,  // Value = projected points for prospects
                player: p.player_name,
                team: p.team_name,
                value: p.projectedPts,
                surplusValue: p.projectedPts,
                projectedPts: p.projectedPts,
                expected: 0
            }));

            // Expected value line - represents break-even (when projected = expected, value = expected)
            // Using smoothed model for clean curve
            const expectedLine = [];
            for (let r = 1; r <= 23; r++) {
                const exp = getExpectedPointsForRound(r);
                expectedLine.push({
                    x: r,
                    y: exp  // Break-even value when projected = expected
                });
            }

            valueVsCostScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Above Expected',
                            data: keeperPoints.filter(p => p.surplusValue > 0),
                            backgroundColor: 'rgba(40, 167, 69, 0.7)',
                            borderColor: 'rgba(40, 167, 69, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                        },
                        {
                            label: 'Below Expected',
                            data: keeperPoints.filter(p => p.surplusValue <= 0),
                            backgroundColor: 'rgba(220, 53, 69, 0.7)',
                            borderColor: 'rgba(220, 53, 69, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                        },
                        {
                            label: 'Prospects (Free)',
                            data: prospectPoints,
                            backgroundColor: 'rgba(23, 162, 184, 0.7)',
                            borderColor: 'rgba(23, 162, 184, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointStyle: 'triangle',
                        },
                        {
                            label: 'Break-Even Value',
                            data: expectedLine,
                            type: 'line',
                            borderColor: 'rgba(30, 60, 114, 0.5)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    if (!point.player) return `Break-even: ${point.y} pts`;
                                    return [
                                        `${point.player}`,
                                        `Team: ${point.team}`,
                                        `Total Value: ${Math.round(point.value)}`,
                                        `Projected: ${Math.round(point.projectedPts)} pts`,
                                        `Surplus: ${point.surplusValue > 0 ? '+' : ''}${Math.round(point.surplusValue)}`
                                    ];
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Keeper Cost (Round)'
                            },
                            min: 0.5,
                            max: 25,
                            ticks: {
                                callback: function(value) {
                                    if (value === 24) return 'Free';
                                    if (value % 2 === 0 || value === 1) return value;
                                    return '';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Keeper Value'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Initialize keeper value analysis when keepers are displayed
        function initializeKeeperValueAnalysis() {
            // Always run the analysis - it will show expected points chart
            // even if no keeper selections exist yet
            analyzeKeeperValues();
        }

        // ===== TRADE MANAGEMENT =====

        let tradeData = {
            trades: []
        };
        let currentTrade = {
            teamA: null,
            teamB: null,
            assetsA: [], // Assets Team A gives up
            assetsB: []  // Assets Team B gives up
        };
        let teamRosters = {}; // Cache of team rosters
        let teamPicksOwned = {}; // Track which picks each team owns
        let teamBudgets = {}; // Track each team's budget
        let tradesLoadedFromServer = false; // Track if we loaded from server

        async function initializeTradeManagement() {
            // Load manual budget adjustments (now async to check server first)
            await loadManualBudgetAdjustments();

            // First, try to load trades from the server JSON file
            try {
                const response = await fetch('data/keepers/trades_2026.json');
                if (response.ok) {
                    const serverTrades = await response.json();
                    tradeData = serverTrades;
                    tradesLoadedFromServer = true;
                    console.log(`Loaded ${tradeData.trades?.length || 0} trades from server`);
                }
            } catch (e) {
                console.log('No server trades file found, checking localStorage');
            }

            // If no server trades, check localStorage for commissioner's working copy
            if (!tradesLoadedFromServer || !tradeData.trades || tradeData.trades.length === 0) {
                const storedTrades = localStorage.getItem('keeper_trades_2026');
                if (storedTrades) {
                    const localTrades = JSON.parse(storedTrades);
                    // Merge: keep server trades and add any new local trades
                    if (localTrades.trades && localTrades.trades.length > 0) {
                        const serverIds = new Set((tradeData.trades || []).map(t => t.id));
                        const newLocalTrades = localTrades.trades.filter(t => !serverIds.has(t.id));
                        tradeData.trades = [...(tradeData.trades || []), ...newLocalTrades];
                    }
                }
            }

            // Ensure trades array exists
            if (!tradeData.trades) {
                tradeData.trades = [];
            }

            // Initialize team budgets and picks
            await initializeTeamAssets();

            // Display existing trades
            displayTrades();
        }

        async function initializeTeamAssets() {
            const totalRounds = getTotalDraftRounds();

            // Initialize each team with default budget and all their picks
            if (keeperConfig && keeperConfig.teams) {
                for (const teamKey of Object.keys(keeperConfig.teams)) {
                    // Default budget
                    teamBudgets[teamKey] = KEEPER_BUDGET;

                    // Default picks (team owns all their own picks)
                    teamPicksOwned[teamKey] = [];
                    for (let round = 1; round <= totalRounds; round++) {
                        teamPicksOwned[teamKey].push({
                            round: round,
                            originalOwner: teamKey
                        });
                    }
                }
            }

            // Apply trades to adjust budgets and picks
            applyTradesToAssets();
        }

        function applyTradesToAssets() {
            // Reset to defaults first
            const totalRounds = getTotalDraftRounds();

            if (keeperConfig && keeperConfig.teams) {
                for (const teamKey of Object.keys(keeperConfig.teams)) {
                    teamBudgets[teamKey] = KEEPER_BUDGET;
                    teamPicksOwned[teamKey] = [];
                    for (let round = 1; round <= totalRounds; round++) {
                        teamPicksOwned[teamKey].push({
                            round: round,
                            originalOwner: teamKey
                        });
                    }
                }
            }

            // Apply each trade
            tradeData.trades.forEach(trade => {
                // Process assets Team A gave to Team B
                trade.assetsA.forEach(asset => {
                    if (asset.type === 'money') {
                        teamBudgets[trade.teamA] -= asset.amount;
                        teamBudgets[trade.teamB] += asset.amount;
                    } else if (asset.type === 'pick') {
                        // Remove pick from Team A
                        const pickIndex = teamPicksOwned[trade.teamA].findIndex(p =>
                            p.round === asset.round && p.originalOwner === asset.originalOwner
                        );
                        if (pickIndex !== -1) {
                            const pick = teamPicksOwned[trade.teamA].splice(pickIndex, 1)[0];
                            teamPicksOwned[trade.teamB].push(pick);
                        }
                    }
                });

                // Process assets Team B gave to Team A
                trade.assetsB.forEach(asset => {
                    if (asset.type === 'money') {
                        teamBudgets[trade.teamB] -= asset.amount;
                        teamBudgets[trade.teamA] += asset.amount;
                    } else if (asset.type === 'pick') {
                        // Remove pick from Team B
                        const pickIndex = teamPicksOwned[trade.teamB].findIndex(p =>
                            p.round === asset.round && p.originalOwner === asset.originalOwner
                        );
                        if (pickIndex !== -1) {
                            const pick = teamPicksOwned[trade.teamB].splice(pickIndex, 1)[0];
                            teamPicksOwned[trade.teamA].push(pick);
                        }
                    }
                });
            });

            // Sort picks by round for each team
            for (const teamKey of Object.keys(teamPicksOwned)) {
                teamPicksOwned[teamKey].sort((a, b) => a.round - b.round);
            }
        }

        function getTeamBudget(teamKey) {
            // Base budget from trades
            const tradeBudget = teamBudgets[teamKey] || KEEPER_BUDGET;
            // Add manual adjustments
            const manualAdjustment = manualBudgetAdjustments[teamKey] || 0;
            return tradeBudget + manualAdjustment;
        }

        function getTeamPicks(teamKey) {
            return teamPicksOwned[teamKey] || [];
        }

        function displayTrades() {
            const container = document.getElementById('trades-list');
            const noTradesMsg = document.getElementById('no-trades-msg');

            if (!tradeData.trades || tradeData.trades.length === 0) {
                container.innerHTML = '<p class="no-trades" id="no-trades-msg">No trades recorded yet. Click "New Trade" to add one.</p>';
                return;
            }

            let html = '';
            tradeData.trades.forEach((trade, index) => {
                const teamAInfo = keeperConfig?.teams[trade.teamA] || { team_name: 'Unknown', manager: '' };
                const teamBInfo = keeperConfig?.teams[trade.teamB] || { team_name: 'Unknown', manager: '' };
                const tradeDate = new Date(trade.timestamp).toLocaleDateString();

                html += `
                    <div class="trade-card">
                        <div class="trade-card-header">
                            <span class="trade-card-date"> ${tradeDate}</span>
                            <div class="trade-card-actions">
                                <button onclick="deleteTrade(${index})" title="Delete trade"></button>
                            </div>
                        </div>
                        <div class="trade-card-body">
                            <div class="trade-card-side">
                                <div class="trade-card-team">
                                    ${teamAInfo.team_logo ? `<img src="${fixTeamLogo(teamAInfo.team_logo)}" alt="">` : ''}
                                    ${teamAInfo.team_name}
                                </div>
                                <div class="trade-card-assets">
                                    ${formatTradeAssets(trade.assetsA)}
                                </div>
                            </div>
                            <div class="trade-card-arrow"></div>
                            <div class="trade-card-side">
                                <div class="trade-card-team">
                                    ${teamBInfo.team_logo ? `<img src="${fixTeamLogo(teamBInfo.team_logo)}" alt="">` : ''}
                                    ${teamBInfo.team_name}
                                </div>
                                <div class="trade-card-assets">
                                    ${formatTradeAssets(trade.assetsB)}
                                </div>
                            </div>
                        </div>
                        ${trade.notes ? `<div class="trade-card-notes"> ${trade.notes}</div>` : ''}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function formatTradeAssets(assets) {
            if (!assets || assets.length === 0) {
                return '<span style="color: #888; font-style: italic;">Nothing</span>';
            }

            return assets.map(asset => {
                if (asset.type === 'player') {
                    return `<span class="trade-asset-tag player"> ${asset.name}</span>`;
                } else if (asset.type === 'pick') {
                    const originalOwner = keeperConfig?.teams[asset.originalOwner]?.team_name || 'Unknown';
                    const pickLabel = asset.originalOwner !== asset.fromTeam
                        ? `Round ${asset.round} (${originalOwner}'s pick)`
                        : `Round ${asset.round}`;
                    return `<span class="trade-asset-tag pick">${pickLabel}</span>`;
                } else if (asset.type === 'money') {
                    return `<span class="trade-asset-tag money"> $${asset.amount}</span>`;
                }
                return '';
            }).join('');
        }

        function openTradeBuilder() {
            // Reset current trade
            currentTrade = {
                teamA: null,
                teamB: null,
                assetsA: [],
                assetsB: []
            };

            // Populate team dropdowns
            populateTradeTeamSelects();

            // Reset UI
            document.getElementById('trade-team-a').value = '';
            document.getElementById('trade-team-b').value = '';
            document.getElementById('trade-team-a-info').style.display = 'none';
            document.getElementById('trade-team-b-info').style.display = 'none';
            document.getElementById('trade-add-asset-a').style.display = 'none';
            document.getElementById('trade-add-asset-b').style.display = 'none';
            document.getElementById('trade-assets-a').innerHTML = '';
            document.getElementById('trade-assets-b').innerHTML = '';
            document.getElementById('trade-notes').value = '';
            document.getElementById('trade-submit-btn').disabled = true;

            // Show modal
            document.getElementById('trade-modal').classList.add('active');
        }

        function closeTradeModal() {
            document.getElementById('trade-modal').classList.remove('active');
        }

        function populateTradeTeamSelects() {
            const selectA = document.getElementById('trade-team-a');
            const selectB = document.getElementById('trade-team-b');

            let options = '<option value="">-- Select Team --</option>';

            if (keeperConfig && keeperConfig.teams) {
                const sortedTeams = Object.entries(keeperConfig.teams)
                    .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

                sortedTeams.forEach(([teamKey, teamInfo]) => {
                    options += `<option value="${teamKey}">${teamInfo.team_name} (${teamInfo.manager})</option>`;
                });
            }

            selectA.innerHTML = options;
            selectB.innerHTML = options;
        }

        async function onTradeTeamSelect(side) {
            const teamKey = document.getElementById(`trade-team-${side}`).value;
            const infoEl = document.getElementById(`trade-team-${side}-info`);
            const addAssetEl = document.getElementById(`trade-add-asset-${side}`);
            const assetsEl = document.getElementById(`trade-assets-${side}`);

            if (!teamKey) {
                infoEl.style.display = 'none';
                addAssetEl.style.display = 'none';
                currentTrade[side === 'a' ? 'teamA' : 'teamB'] = null;
                return;
            }

            // Update current trade
            currentTrade[side === 'a' ? 'teamA' : 'teamB'] = teamKey;

            // Load team roster if not cached
            if (!teamRosters[teamKey]) {
                try {
                    const response = await fetch('data/historical/2025/player_stats.json');
                    if (response.ok) {
                        const allPlayers = await response.json();
                        teamRosters[teamKey] = allPlayers.filter(p => p.team_key === teamKey);
                    }
                } catch (e) {
                    console.log('Could not load roster');
                }
            }

            // Update budget display
            const budget = getTeamBudget(teamKey);
            document.getElementById(`trade-budget-${side}`).textContent = `$${budget}`;

            infoEl.style.display = 'block';
            addAssetEl.style.display = 'block';

            // Reset asset type selector
            document.getElementById(`trade-asset-type-${side}`).value = '';
            document.getElementById(`trade-asset-selector-${side}`).style.display = 'none';

            // Clear assets when team changes
            assetsEl.innerHTML = '';
            currentTrade[side === 'a' ? 'assetsA' : 'assetsB'] = [];

            updateTradeSubmitButton();
        }

        function onAssetTypeChange(side) {
            const assetType = document.getElementById(`trade-asset-type-${side}`).value;
            const selectorEl = document.getElementById(`trade-asset-selector-${side}`);
            const teamKey = currentTrade[side === 'a' ? 'teamA' : 'teamB'];

            if (!assetType || !teamKey) {
                selectorEl.style.display = 'none';
                return;
            }

            let selectorHtml = '';

            if (assetType === 'player') {
                const roster = teamRosters[teamKey] || [];
                selectorHtml = `
                    <select id="trade-player-select-${side}">
                        <option value="">-- Select Player --</option>
                        ${roster.map(p => `<option value="${p.name}">${p.name} (${p.primary_position})</option>`).join('')}
                    </select>
                    <button onclick="addTradeAsset('${side}', 'player')">Add</button>
                `;
            } else if (assetType === 'pick') {
                const picks = getTeamPicks(teamKey);
                selectorHtml = `
                    <select id="trade-pick-select-${side}">
                        <option value="">-- Select Pick --</option>
                        ${picks.map(p => {
                    const originalOwner = keeperConfig?.teams[p.originalOwner]?.team_name || 'Unknown';
                    const label = p.originalOwner !== teamKey
                        ? `Round ${p.round} (${originalOwner}'s pick)`
                        : `Round ${p.round}`;
                    return `<option value="${p.round}-${p.originalOwner}">${label}</option>`;
                }).join('')}
                    </select>
                    <button onclick="addTradeAsset('${side}', 'pick')">Add</button>
                `;
            } else if (assetType === 'money') {
                const budget = getTeamBudget(teamKey);
                selectorHtml = `
                    <input type="number" id="trade-money-input-${side}" min="1" max="${budget}" value="1" placeholder="$">
                    <span>/ $${budget}</span>
                    <button onclick="addTradeAsset('${side}', 'money')">Add</button>
                `;
            }

            selectorEl.innerHTML = selectorHtml;
            selectorEl.style.display = 'flex';
        }

        function addTradeAsset(side, type) {
            const teamKey = currentTrade[side === 'a' ? 'teamA' : 'teamB'];
            const assetsKey = side === 'a' ? 'assetsA' : 'assetsB';
            const assetsEl = document.getElementById(`trade-assets-${side}`);

            let asset = null;

            if (type === 'player') {
                const playerName = document.getElementById(`trade-player-select-${side}`).value;
                if (!playerName) return;

                // Check if already added
                if (currentTrade[assetsKey].some(a => a.type === 'player' && a.name === playerName)) {
                    alert('This player is already in the trade.');
                    return;
                }

                asset = { type: 'player', name: playerName };
            } else if (type === 'pick') {
                const pickValue = document.getElementById(`trade-pick-select-${side}`).value;
                if (!pickValue) return;

                const [round, originalOwner] = pickValue.split('-');

                // Check if already added
                if (currentTrade[assetsKey].some(a => a.type === 'pick' && a.round === parseInt(round) && a.originalOwner === originalOwner)) {
                    alert('This pick is already in the trade.');
                    return;
                }

                asset = { type: 'pick', round: parseInt(round), originalOwner: originalOwner, fromTeam: teamKey };
            } else if (type === 'money') {
                const amount = parseInt(document.getElementById(`trade-money-input-${side}`).value);
                if (!amount || amount < 1) return;

                // Check total money in trade doesn't exceed budget
                const currentMoney = currentTrade[assetsKey]
                    .filter(a => a.type === 'money')
                    .reduce((sum, a) => sum + a.amount, 0);
                const budget = getTeamBudget(teamKey);

                if (currentMoney + amount > budget) {
                    alert(`Cannot add $${amount}. Team only has $${budget - currentMoney} available.`);
                    return;
                }

                asset = { type: 'money', amount: amount };
            }

            if (asset) {
                currentTrade[assetsKey].push(asset);
                renderTradeAssets(side);

                // Reset selector
                document.getElementById(`trade-asset-type-${side}`).value = '';
                document.getElementById(`trade-asset-selector-${side}`).style.display = 'none';

                updateTradeSubmitButton();
            }
        }

        function removeTradeAsset(side, index) {
            const assetsKey = side === 'a' ? 'assetsA' : 'assetsB';
            currentTrade[assetsKey].splice(index, 1);
            renderTradeAssets(side);
            updateTradeSubmitButton();
        }

        function renderTradeAssets(side) {
            const assetsKey = side === 'a' ? 'assetsA' : 'assetsB';
            const assetsEl = document.getElementById(`trade-assets-${side}`);
            const teamKey = currentTrade[side === 'a' ? 'teamA' : 'teamB'];

            if (currentTrade[assetsKey].length === 0) {
                assetsEl.innerHTML = '<div style="color: #888; font-style: italic; padding: 1rem; text-align: center;">No assets added yet</div>';
                return;
            }

            assetsEl.innerHTML = currentTrade[assetsKey].map((asset, index) => {
                let icon, label;

                if (asset.type === 'player') {
                    icon = '';
                    label = asset.name;
                } else if (asset.type === 'pick') {
                    icon = '';
                    const originalOwner = keeperConfig?.teams[asset.originalOwner]?.team_name || 'Unknown';
                    label = asset.originalOwner !== teamKey
                        ? `Round ${asset.round} (${originalOwner}'s pick)`
                        : `Round ${asset.round}`;
                } else if (asset.type === 'money') {
                    icon = '';
                    label = `$${asset.amount}`;
                }

                return `
                    <div class="trade-asset-item">
                        <div class="asset-info">
                            <span class="asset-type-icon ${asset.type}">${icon}</span>
                            <span>${label}</span>
                        </div>
                        <button class="remove-asset" onclick="removeTradeAsset('${side}', ${index})"></button>
                    </div>
                `;
            }).join('');
        }

        function updateTradeSubmitButton() {
            const submitBtn = document.getElementById('trade-submit-btn');

            // Need both teams selected and at least one asset on either side
            const hasTeams = currentTrade.teamA && currentTrade.teamB && currentTrade.teamA !== currentTrade.teamB;
            const hasAssets = currentTrade.assetsA.length > 0 || currentTrade.assetsB.length > 0;

            submitBtn.disabled = !(hasTeams && hasAssets);
        }

        function submitTrade() {
            if (!currentTrade.teamA || !currentTrade.teamB) {
                alert('Please select both teams.');
                return;
            }

            if (currentTrade.teamA === currentTrade.teamB) {
                alert('Cannot trade with the same team.');
                return;
            }

            if (currentTrade.assetsA.length === 0 && currentTrade.assetsB.length === 0) {
                alert('Please add at least one asset to the trade.');
                return;
            }

            const teamAInfo = keeperConfig?.teams[currentTrade.teamA];
            const teamBInfo = keeperConfig?.teams[currentTrade.teamB];

            // Build confirmation message
            let confirmMsg = `Confirm this trade?\n\n`;
            confirmMsg += `${teamAInfo?.team_name || 'Team A'} sends:\n`;
            currentTrade.assetsA.forEach(a => {
                if (a.type === 'player') confirmMsg += `   ${a.name}\n`;
                else if (a.type === 'pick') confirmMsg += `   Round ${a.round} pick\n`;
                else if (a.type === 'money') confirmMsg += `   $${a.amount}\n`;
            });
            if (currentTrade.assetsA.length === 0) confirmMsg += `   (nothing)\n`;

            confirmMsg += `\n${teamBInfo?.team_name || 'Team B'} sends:\n`;
            currentTrade.assetsB.forEach(a => {
                if (a.type === 'player') confirmMsg += `   ${a.name}\n`;
                else if (a.type === 'pick') confirmMsg += `   Round ${a.round} pick\n`;
                else if (a.type === 'money') confirmMsg += `   $${a.amount}\n`;
            });
            if (currentTrade.assetsB.length === 0) confirmMsg += `   (nothing)\n`;

            if (!confirm(confirmMsg)) return;

            // Create trade record
            const trade = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                teamA: currentTrade.teamA,
                teamB: currentTrade.teamB,
                assetsA: [...currentTrade.assetsA],
                assetsB: [...currentTrade.assetsB],
                notes: document.getElementById('trade-notes').value.trim()
            };

            // Add to trades
            tradeData.trades.push(trade);

            // Save to localStorage
            localStorage.setItem('keeper_trades_2026', JSON.stringify(tradeData));

            // Reapply trades to update budgets/picks
            applyTradesToAssets();

            // Update displays
            displayTrades();
            displayLeagueKeepers(); // Refresh keeper display with new budgets

            // Close modal
            closeTradeModal();

            alert('Trade recorded successfully!');
        }

        function deleteTrade(index) {
            if (!confirm('Are you sure you want to delete this trade?')) return;

            tradeData.trades.splice(index, 1);
            localStorage.setItem('keeper_trades_2026', JSON.stringify(tradeData));

            // Reapply remaining trades
            applyTradesToAssets();

            // Update displays
            displayTrades();
            displayLeagueKeepers();
        }

        // Close trade modal on outside click
        document.getElementById('trade-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeTradeModal();
            }
        });

        // ===== TRADE EXPORT FUNCTIONS =====

        function exportTradesForSite() {
            // Generate clean JSON for the trades file
            const exportData = {
                _comment: "Fantasy Baseball Civil War - Keeper Trades for 2026 Season",
                _updated: new Date().toISOString(),
                trades: tradeData.trades.map(trade => ({
                    id: trade.id,
                    timestamp: trade.timestamp,
                    teamA: trade.teamA,
                    teamB: trade.teamB,
                    assetsA: trade.assetsA,
                    assetsB: trade.assetsB,
                    notes: trade.notes || ""
                }))
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            document.getElementById('export-json-content').value = jsonString;
            document.getElementById('export-trades-modal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('export-trades-modal').classList.remove('active');
        }

        function copyExportJson() {
            const textarea = document.getElementById('export-json-content');
            textarea.select();
            document.execCommand('copy');

            // Show feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadExportJson() {
            const jsonContent = document.getElementById('export-json-content').value;
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'trades_2026.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Close export modal on outside click
        document.getElementById('export-trades-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeExportModal();
            }
        });

        // ===== PROJECTION PLAYER DETAIL MODAL =====

        async function showProjectionPlayerDetail(playerName) {
            const modal = document.getElementById('projection-modal');
            const cardContainer = document.getElementById('projection-card-container');
            const posChartEl = document.getElementById('projection-pos-chart');
            const scatterChartEl = document.getElementById('projection-scatter-chart');
            const scatterTitleEl = document.getElementById('projection-scatter-title');

            // Find player in projection data
            const allPlayers = [...allProjectionBatters, ...allProjectionPitchers];
            const player = allPlayers.find(p => p.name === playerName);
            if (!player) return;

            const isBatter = player.type === 'batter';
            const stats = player.stats || {};

            // Placeholders
            const placeholderHeadshot = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            const headshot = player.headshot_url || placeholderHeadshot;
            const mlbLogoUrl = getMLBTeamLogo(player.team || '');
            const mlbTeamText = formatMLBTeamDisplay(player.team || '');
            const mlbLogoHtml = mlbLogoUrl
                ? `<img src="${mlbLogoUrl}" alt="" class="card-mlb-logo" onerror="this.outerHTML='<div class=\\'card-mlb-fa\\'>FA</div>'">`
                : `<div class="card-mlb-fa">FA</div>`;

            const projPoints = (player.projected_points || 0).toFixed(1);
            const positionDisplay = formatProjectionPosition(player.position, player.name);
            const positionRank = getProjectionPositionRank(player);
            const primaryPos = positionDisplay.split(',')[0].trim() || (isBatter ? 'B' : 'P');

            // Check if player is kept
            const keeperInfo = getPlayerKeeperInfo(player.name);
            let keeperLogoHtml = '';
            if (keeperInfo && keeperConfig?.teams[keeperInfo.teamKey]) {
                const keeperTeam = keeperConfig.teams[keeperInfo.teamKey];
                // Get fresh 2026 logo by manager name (pass teamKey for proper normalization)
                const freshLogo = await getCurrentTeamLogo(keeperTeam.manager, keeperInfo.teamKey) || keeperTeam.team_logo;
                if (freshLogo) {
                    keeperLogoHtml = `
                        <div class="card-keeper-logo-wrapper">
                            <img src="${fixTeamLogo(freshLogo)}" alt="" class="card-team-logo-corner" onerror="this.style.display='none'">
                            <div class="card-keeper-badge">K</div>
                        </div>`;
                }
            }

            // Load player history data
            if (Object.keys(playerHistoryData).length === 0) {
                try {
                    const historyResponse = await fetch('data/players/player_history.json');
                    if (historyResponse.ok) {
                        playerHistoryData = await historyResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load player history');
                }
            }

            // Build baseball card HTML - matching the player modal card style
            // Get action shot URL
            let mlbId = null;
            if (player.headshot_url) {
                const match = player.headshot_url.match(/\/people\/(\d+)\//);
                if (match) mlbId = match[1];
            }
            const actionShotUrl = mlbId 
                ? `https://img.mlbstatic.com/mlb-photos/image/upload/d_people:generic:action:hero:current.png/q_auto:best/v1/people/${mlbId}/action/hero/current`
                : null;

            let cardHTML = `
            <div class="baseball-card">
                <div class="card-inner">
                    <!-- Photo Section -->
                    <div class="card-front">
                        <div class="card-photo-wrapper">
                            <!-- MLB Logo - top left corner -->
                            <div class="card-mlb-logo">
                                ${mlbLogoUrl 
                                    ? `<img src="${mlbLogoUrl}" alt="${mlbTeamText}" onerror="this.outerHTML='FA';">` 
                                    : 'FA'}
                            </div>
                            
                            <!-- Keeper/Fantasy Logo - bottom right corner -->
                            ${keeperLogoHtml || ''}
                            
                            <div class="card-photo-container">
                                ${actionShotUrl 
                                    ? `<img src="${actionShotUrl}" alt="${player.name}" class="card-action-shot" onerror="this.className='card-headshot'; this.src='${headshot}';">` 
                                    : `<img src="${headshot}" alt="${player.name}" class="card-headshot" onerror="this.src='${placeholderHeadshot}';">`}
                            </div>
                        </div>
                        
                        <!-- Player Name Banner -->
                        <div class="card-name-banner">
                            <span class="card-year-badge">2026</span>
                            <span class="card-player-name">${player.name}</span>
                            <span class="card-position-badge">${primaryPos}</span>
                        </div>
                    </div>
                    
                    <!-- Stats Section -->
                    <div class="card-back">
                        <!-- Header with headshot -->
                        <div class="card-back-header">
                            <div class="card-back-number">${positionRank}</div>
                            <div class="card-back-info">
                                <div class="card-back-name">${player.name}</div>
                                <div class="card-back-team">${mlbTeamText}  ${positionDisplay}</div>
                            </div>
                            <img src="${headshot}" alt="" class="card-back-headshot" onerror="this.src='${placeholderHeadshot}';">
                        </div>
                        
                        <div class="card-stats-section">
                            <div class="card-stats-header">
                                <div class="card-stats-title">2026 Projected Statistics</div>
                            </div>
                            <div id="projection-modal-stats-content">`;

            if (isBatter) {
                const singles = (stats['1B'] || 0);
                cardHTML += `
                            <table class="card-stats-table">
                                <tr>
                                    <th>G</th><th>PA</th><th>H</th><th>HR</th><th>RBI</th><th>R</th><th>SB</th>
                                </tr>
                                <tr>
                                    <td>${player.games || 0}</td>
                                    <td>${stats.PA || 0}</td>
                                    <td>${stats.H || 0}</td>
                                    <td>${stats.HR || 0}</td>
                                    <td>${stats.RBI || 0}</td>
                                    <td>${stats.R || 0}</td>
                                    <td>${stats.SB || 0}</td>
                                </tr>
                                <tr>
                                    <th>BB</th><th>1B</th><th>2B</th><th>3B</th><th>AVG</th><th>OPS</th><th>PPG</th>
                                </tr>
                                <tr>
                                    <td>${stats.BB || 0}</td>
                                    <td>${singles}</td>
                                    <td>${stats['2B'] || 0}</td>
                                    <td>${stats['3B'] || 0}</td>
                                    <td>${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</td>
                                    <td>${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</td>
                                    <td>${player.ppg ? player.ppg.toFixed(2) : '-'}</td>
                                </tr>
                            </table>`;
            } else {
                cardHTML += `
                            <table class="card-stats-table">
                                <tr>
                                    <th>W</th><th>L</th><th>SV</th><th>G</th><th>GS</th><th>IP</th><th>K</th>
                                </tr>
                                <tr>
                                    <td>${stats.W || 0}</td>
                                    <td>${stats.L || 0}</td>
                                    <td>${stats.SV || 0}</td>
                                    <td>${stats.G || 0}</td>
                                    <td>${stats.GS || 0}</td>
                                    <td>${(stats.IP || 0).toFixed(1)}</td>
                                    <td>${stats.K || stats.SO || 0}</td>
                                </tr>
                                <tr>
                                    <th>BB</th><th>ER</th><th>H</th><th>ERA</th><th>WHIP</th><th>HLD</th><th>PPG</th>
                                </tr>
                                <tr>
                                    <td>${stats.BB || 0}</td>
                                    <td>${stats.ER || 0}</td>
                                    <td>${stats.H || 0}</td>
                                    <td>${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</td>
                                    <td>${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</td>
                                    <td>${stats.HLD || 0}</td>
                                    <td>${player.ppg ? player.ppg.toFixed(2) : '-'}</td>
                                </tr>
                            </table>`;
            }

            cardHTML += `</div></div>`; // Close stats content and section

            // Fantasy points row
            cardHTML += `
                        <div class="card-points-row">
                            <span class="card-points-label">Projected Points</span>
                            <span class="card-points-value">${projPoints}</span>
                            <span class="card-points-rank">${positionRank}</span>
                        </div>`;

            // Get draft info from 2025 data
            let draftText = 'Undrafted';
            const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const playerHistory = playerHistoryData[normalizedName];
            
            // Check if drafted in 2025
            if (playerHistory && playerHistory.seasons) {
                const season2025 = playerHistory.seasons.find(s => s.year === 2025);
                if (season2025 && season2025.draft_round && season2025.draft_pick) {
                    draftText = `Round ${season2025.draft_round}, Pick #${season2025.draft_pick}`;
                }
            }

            // Draft info row
            cardHTML += `
                        <div class="card-draft-row">
                            <span class="card-draft-label">2025 Draft:</span>
                            <span class="card-draft-value">${draftText}</span>
                        </div>`;

            // League history section
            if (playerHistory && playerHistory.seasons && playerHistory.seasons.length > 0) {
                const historyLogos = {};
                const historyRanks = {};

                for (const season of playerHistory.seasons) {
                    const teams = await getTeamData(season.year);
                    if (teams) {
                        const team = teams.find(t => t.team_name === season.team_name);
                        if (team) {
                            historyLogos[`${season.year}_${season.team_name}`] = fixTeamLogo(team.team_logo);
                        }
                    }

                    const yearPlayers = await getPlayerStatsData(season.year);
                    if (yearPlayers) {
                        const posType = isBatter ? 'B' : 'P';
                        const sameType = yearPlayers
                            .filter(p => p.position_type === posType)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const overallRank = sameType.findIndex(p => p.name === playerName) + 1;

                        const samePos = yearPlayers
                            .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const posRank = samePos.findIndex(p => p.name === playerName) + 1;

                        historyRanks[season.year] = {
                            overall: overallRank > 0 ? overallRank : '-',
                            position: posRank > 0 ? `${primaryPos}${posRank}` : '-'
                        };
                    } else {
                        historyRanks[season.year] = { overall: '-', position: '-' };
                    }
                }

                cardHTML += `
                        <div class="card-history-wrapper">
                            <div class="card-history-title">League History</div>`;

                playerHistory.seasons.sort((a, b) => b.year - a.year).forEach(season => {
                    const logo = historyLogos[`${season.year}_${season.team_name}`] || '';
                    const ranks = historyRanks[season.year] || { overall: '-', position: '-' };
                    cardHTML += `
                            <div class="card-history-row">
                                <span class="card-history-year">${season.year}</span>
                                ${logo ? `<img src="${logo}" class="card-history-logo" alt="">` : ''}
                                <span class="card-history-manager">${season.manager || ''}</span>
                                <span class="card-history-pts">${(season.fantasy_points || 0).toFixed(0)} pts</span>
                                <span class="card-history-rank">${ranks.position}</span>
                            </div>`;
                });

                cardHTML += `</div>`;
            }

            cardHTML += `
                    </div>
                </div>
            </div>`;

            cardContainer.innerHTML = cardHTML;

            // 2. SHOW MODAL FIRST (Fixes width calculation)
            modal.classList.add('active');
            document.body.classList.add('modal-open');

            // 3. Render Charts (Now they can see the real width)
            renderPositionRankChart(player, posChartEl);

            // Set title and render scatter
            scatterTitleEl.textContent = (player.type === 'batter') ? 'Points vs PA' : 'Points vs IP';
            renderScatterChart(player, scatterChartEl, (player.type === 'batter'));
        }

        function renderPositionRankChart(selectedPlayer, container) {
            const isBatter = selectedPlayer.type === 'batter';
            const allPlayers = isBatter ? [...allProjectionBatters] : [...allProjectionPitchers];

            // Get primary position
            const posDisplay = formatProjectionPosition(selectedPlayer.position, selectedPlayer.name);
            const primaryPos = posDisplay.split(',')[0].trim();

            // Filter players
            let positionPlayers;
            if (['LF', 'CF', 'RF', 'OF'].includes(primaryPos.toUpperCase())) {
                positionPlayers = allPlayers.filter(p => {
                    const pos = (p.position || '').toUpperCase();
                    return pos.includes('LF') || pos.includes('CF') || pos.includes('RF') || pos.includes('OF');
                });
            } else if (['SP', 'RP'].includes(primaryPos.toUpperCase())) {
                positionPlayers = allPlayers.filter(p => {
                    const pos = (p.position || '').toUpperCase();
                    return pos.includes(primaryPos.toUpperCase());
                });
            } else {
                positionPlayers = allPlayers.filter(p => {
                    const pos = (p.position || '').toUpperCase();
                    return pos.includes(primaryPos.toUpperCase());
                });
            }

            // Sort by projected points
            positionPlayers.sort((a, b) => (a.projected_points || 0) - (b.projected_points || 0));

            // LIMIT: 75 for SP, 50 for others
            const limit = primaryPos.toUpperCase() === 'SP' ? 75 : 50;
            const topPlayers = positionPlayers.slice(-limit);

            // Dimensions
            const width = container.clientWidth || 320;
            const height = 180;
            // Reduced right padding to 10 to fill box better
            const padding = { top: 15, right: 10, bottom: 25, left: 45 };

            // Y-Scale
            const minPts = Math.min(...topPlayers.map(p => p.projected_points || 0));
            const maxPts = Math.max(...topPlayers.map(p => p.projected_points || 0));
            const tickInterval = 50;
            const niceMin = Math.floor(minPts / tickInterval) * tickInterval;
            const niceMax = Math.ceil(maxPts / tickInterval) * tickInterval;
            const range = niceMax - niceMin || 1;
            const scaleY = (val) => padding.top + (height - padding.top - padding.bottom) - ((val - niceMin) / range * (height - padding.top - padding.bottom));

            // SVG setup
            let svg = `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" style="display: block;">`;

            // Draw Axis/Grid
            svg += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" class="chart-axis"/>`;
            for (let val = niceMin; val <= niceMax; val += tickInterval) {
                const y = scaleY(val);
                svg += `<line x1="${padding.left - 5}" y1="${y}" x2="${padding.left}" y2="${y}" class="chart-axis"/>`;
                svg += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" class="chart-axis-label">${val}</text>`;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="chart-grid"/>`;
            }
            svg += `<text x="12" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})" class="chart-axis-label" style="font-weight: bold;">Proj Pts</text>`;
            svg += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" class="chart-axis"/>`;

            // NEW Spacing Logic: Spread fully edge-to-edge
            const chartWidth = width - padding.left - padding.right;
            const count = topPlayers.length;
            const dotSpacing = count > 1 ? chartWidth / (count - 1) : 0;

            // Draw Dots (Background)
            topPlayers.forEach((player, i) => {
                if (player.name === selectedPlayer.name) return;
                // Use i directly to start at 0 (left) and end at width (right)
                const x = padding.left + (dotSpacing * i);
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                const isKeeper = getPlayerKeeperInfo(player.name) !== null;
                const keeperClass = isKeeper ? 'keeper-dot' : '';
                svg += `<circle cx="${x}" cy="${y}" r="5" class="chart-dot ${keeperClass}" data-name="${player.name}" data-pts="${pts}"/>`;
            });

            // Draw Selected Dot (Foreground)
            topPlayers.forEach((player, i) => {
                if (player.name !== selectedPlayer.name) return;
                const x = padding.left + (dotSpacing * i);
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                svg += `<circle cx="${x}" cy="${y}" r="8" class="chart-dot highlighted" data-name="${player.name}" data-pts="${pts}"/>`;
            });

            svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle" class="chart-axis-label" style="font-weight: bold;">${primaryPos.toUpperCase()} Rankings</text>`;
            svg += '</svg>';
            svg += `<div class="chart-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 100;"></div>`;

            container.innerHTML = svg;
            container.style.position = 'relative';

            // Tooltip listeners
            const tooltip = container.querySelector('.chart-tooltip');
            container.querySelectorAll('.chart-dot').forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const name = dot.getAttribute('data-name');
                    const pts = dot.getAttribute('data-pts');
                    tooltip.textContent = `${name}: ${pts} pts`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mousemove', (e) => {
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            });
        }

        function renderScatterChart(selectedPlayer, container, isBatter) {
            const allPlayers = isBatter ? [...allProjectionBatters] : [...allProjectionPitchers];

            const getXValue = (p) => isBatter ? (p.stats?.PA || 0) : (p.stats?.IP || 0);
            const validPlayers = allPlayers.filter(p => getXValue(p) > 0);

            // Chart dimensions
            const width = container.clientWidth || 320;
            const height = 180;
            const padding = { top: 15, right: 10, bottom: 30, left: 45 };

            const xValues = validPlayers.map(p => getXValue(p));
            const yValues = validPlayers.map(p => p.projected_points || 0);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);

            // CHANGED: Y-Axis interval set to 100
            const yTickInterval = 100;
            const niceMinY = Math.floor(minY / yTickInterval) * yTickInterval;
            const niceMaxY = Math.ceil(maxY / yTickInterval) * yTickInterval;
            const rangeY = niceMaxY - niceMinY || 1;

            // CHANGED: X-Axis now uses tight "Min to Max" range (with tiny buffer for dots)
            const xTickInterval = 100;
            const bufferX = (maxX - minX) * 0.02; // 2% buffer so dots don't get cut off
            const niceMinX = Math.floor(minX - bufferX);
            const niceMaxX = Math.ceil(maxX + bufferX);
            const rangeX = niceMaxX - niceMinX || 1;

            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            const scaleX = (val) => padding.left + ((val - niceMinX) / rangeX * chartWidth);
            const scaleY = (val) => padding.top + chartHeight - ((val - niceMinY) / rangeY * chartHeight);

            let svg = `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" style="display: block;">`;

            // Draw Y-Axis (Vertical)
            svg += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" class="chart-axis"/>`;

            // Draw Y-Axis Ticks & Grid (Every 100)
            for (let val = niceMinY; val <= niceMaxY; val += yTickInterval) {
                const y = scaleY(val);
                svg += `<line x1="${padding.left - 5}" y1="${y}" x2="${padding.left}" y2="${y}" class="chart-axis"/>`;
                svg += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" class="chart-axis-label">${val}</text>`;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="chart-grid"/>`;
            }

            svg += `<text x="12" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})" class="chart-axis-label" style="font-weight: bold;">Proj Pts</text>`;

            // Draw X-Axis (Baseline)
            svg += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" class="chart-axis"/>`;

            // CHANGED: Draw X-Axis Ticks (Every 100, starting at first multiple of 100)
            const firstXTick = Math.ceil(niceMinX / xTickInterval) * xTickInterval;

            for (let val = firstXTick; val <= niceMaxX; val += xTickInterval) {
                const x = scaleX(val);
                // Ensure tick is within visible chart area
                if (x >= padding.left && x <= width - padding.right) {
                    svg += `<line x1="${x}" y1="${height - padding.bottom}" x2="${x}" y2="${height - padding.bottom + 5}" class="chart-axis"/>`;
                    svg += `<text x="${x}" y="${height - padding.bottom + 15}" text-anchor="middle" class="chart-axis-label">${Math.round(val)}</text>`;
                }
            }

            // Plot Dots
            validPlayers.forEach(player => {
                if (player.name === selectedPlayer.name) return;
                const x = scaleX(getXValue(player));
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                const xVal = isBatter ? getXValue(player) : getXValue(player).toFixed(1);
                const isKeeper = getPlayerKeeperInfo(player.name) !== null;
                const keeperClass = isKeeper ? 'keeper-dot' : '';
                svg += `<circle cx="${x}" cy="${y}" r="4" class="chart-dot ${keeperClass}" data-name="${player.name}" data-pts="${pts}" data-x="${xVal}"/>`;
            });

            // Plot Selected Player Dot (On Top)
            validPlayers.forEach(player => {
                if (player.name !== selectedPlayer.name) return;
                const x = scaleX(getXValue(player));
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                const xVal = isBatter ? getXValue(player) : getXValue(player).toFixed(1);
                svg += `<circle cx="${x}" cy="${y}" r="8" class="chart-dot highlighted" data-name="${player.name}" data-pts="${pts}" data-x="${xVal}"/>`;
            });

            svg += `<text x="${width / 2}" y="${height - 3}" text-anchor="middle" class="chart-axis-label" style="font-weight: bold;">${isBatter ? 'Plate Appearances' : 'Innings Pitched'}</text>`;
            svg += '</svg>';
            svg += `<div class="chart-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 100;"></div>`;

            container.innerHTML = svg;
            container.style.position = 'relative';

            // Re-attach listeners
            const tooltip = container.querySelector('.chart-tooltip');
            const xLabel = isBatter ? 'PA' : 'IP';
            container.querySelectorAll('.chart-dot').forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const name = dot.getAttribute('data-name');
                    const pts = dot.getAttribute('data-pts');
                    const xVal = dot.getAttribute('data-x');
                    tooltip.textContent = `${name}: ${pts} pts, ${xVal} ${xLabel}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mousemove', (e) => {
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            });
        }

        function closeProjectionModal() {
            document.getElementById('projection-modal').classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Close projection modal on outside click
        document.getElementById('projection-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeProjectionModal();
            }
        });

        // ===== SPORTSBOOK FUNCTIONS =====
        let sportsbookUser = null;
        let sportsbookTeamData = [];
        let sportsbookBetSlip = [];
        let sportsbookBetsRef = null;
        let sportsbookBalancesRef = null;
        
        const PRESEASON_BUDGET = 50;
        const WEEKLY_BUDGET_ADD = 10;
        
        // Initialize sportsbook when section is shown
        async function initializeSportsbook() {
            // Load team data from current season
            try {
                const response = await fetch('data/current_season/teams.json');
                if (response.ok) {
                    sportsbookTeamData = await response.json();
                }
            } catch (e) {
                console.log('Could not load teams for sportsbook:', e);
            }
            
            // Setup Firebase refs
            if (firebaseDb) {
                sportsbookBetsRef = firebaseDb.ref('sportsbook_bets');
                sportsbookBalancesRef = firebaseDb.ref('sportsbook_balances');
            }
        }
        
        function openSportsbookLogin() {
            const modal = document.getElementById('sportsbook-login-modal');
            const grid = document.getElementById('sportsbook-team-grid');
            
            // Populate team grid
            grid.innerHTML = sportsbookTeamData.map(team => `
                <div class="sportsbook-team-option" 
                     onclick="selectSportsbookTeam('${team.team_key}')"
                     data-team-key="${team.team_key}"
                     data-tooltip="${team.team_name} - ${normalizeManagerName(team.manager, 2026, team.team_name, team.team_key)}">
                    <img src="${fixTeamLogo(team.team_logo) || 'league_logo.png'}" alt="${team.team_name}">
                    <span class="team-name">${normalizeManagerName(team.manager, 2026, team.team_name, team.team_key)}</span>
                </div>
            `).join('');
            
            // Reset state
            document.getElementById('sportsbook-password-section').classList.remove('active');
            document.getElementById('sportsbook-login-error').style.display = 'none';
            
            modal.classList.add('active');
        }
        
        function closeSportsbookLogin() {
            document.getElementById('sportsbook-login-modal').classList.remove('active');
        }
        
        // ===== BETTING STATS MODAL =====
        let betStatsChartMode = 'logos'; // 'logos' or 'colors'
        let currentBetStatsType = null;
        let currentBetStatsData = null;
        
        function showBetStats(betType) {
            currentBetStatsType = betType;
            const modal = document.getElementById('bet-stats-modal');
            const title = document.getElementById('bet-stats-title');
            const body = document.getElementById('bet-stats-body');
            
            const betTypeLabels = {
                'champion': 'FBCW Champion',
                'wins': 'Most Wins',
                'points': 'Most Points',
                'last': 'Last Place'
            };
            
            title.textContent = `${betTypeLabels[betType] || betType} - Betting Stats`;
            
            // Load bets from Firebase and calculate stats
            loadBetStatsForType(betType).then(stats => {
                currentBetStatsData = stats;
                renderBetStats(stats, betType);
            });
            
            modal.classList.add('active');
        }
        
        async function loadBetStatsForType(betType) {
            const stats = {
                totalUnits: 0,
                totalBets: 0,
                teamBreakdown: {} // { teamKey: { teamName, logo, units, bets } }
            };
            
            // Initialize Firebase ref if needed
            if (!sportsbookBetsRef && firebaseDb) {
                sportsbookBetsRef = firebaseDb.ref('sportsbook_bets');
            }
            
            if (!sportsbookBetsRef) {
                console.log('No sportsbookBetsRef available');
                return stats;
            }
            
            // Build a mapping from 2025 team keys to current team data (for old bets)
            const teamKey2025ToManager = {
                '458.l.4156.t.1': 'Josh B',
                '458.l.4156.t.2': 'Ryan',
                '458.l.4156.t.3': 'Coleman',
                '458.l.4156.t.4': 'Riley',
                '458.l.4156.t.5': 'Dalton',
                '458.l.4156.t.6': 'Robert',
                '458.l.4156.t.7': 'Tyler',
                '458.l.4156.t.8': 'Dylan',
                '458.l.4156.t.9': 'Red',
                '458.l.4156.t.10': 'Logan S',
                '458.l.4156.t.11': 'Rich',
                '458.l.4156.t.12': 'Nate'
            };
            
            // Build manager to current team data mapping
            const managerToTeamData = {};
            sportsbookTeamData.forEach(team => {
                const manager = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                managerToTeamData[manager.toLowerCase()] = team;
            });
            
            try {
                const snapshot = await sportsbookBetsRef.once('value');
                const allBets = snapshot.val();
                
                console.log('Loaded bets for stats:', allBets);
                
                if (!allBets) return stats;
                
                // Bets are stored as a flat list with push keys
                Object.values(allBets).forEach(bet => {
                    if (!bet) return;
                    
                    // Check if this bet matches the type (champion, wins, points, last)
                    if (bet.betType === betType) {
                        stats.totalUnits += bet.wager || 0;
                        stats.totalBets++;
                        
                        // selection contains the team key that was bet on (may be 2025 or 2026 key)
                        const selectedTeamKey = bet.selection;
                        
                        // Try to find team info - first by direct key match (2026), then by manager name (2025)
                        let teamInfo = sportsbookTeamData.find(t => t.team_key === selectedTeamKey);
                        
                        if (!teamInfo) {
                            // Try to find by manager name using 2025 key mapping
                            const manager = teamKey2025ToManager[selectedTeamKey];
                            if (manager) {
                                teamInfo = managerToTeamData[manager.toLowerCase()];
                            }
                        }
                        
                        // Use manager name as the grouping key to combine 2025 and 2026 bets
                        const managerKey = teamInfo 
                            ? normalizeManagerName(teamInfo.manager, 2026, teamInfo.team_name, teamInfo.team_key).toLowerCase()
                            : (teamKey2025ToManager[selectedTeamKey] || selectedTeamKey).toLowerCase();
                        
                        if (!stats.teamBreakdown[managerKey]) {
                            stats.teamBreakdown[managerKey] = {
                                teamName: teamInfo?.team_name || bet.selectionName || selectedTeamKey,
                                logo: fixTeamLogo(teamInfo?.team_logo) || 'league_logo.png',
                                manager: teamInfo ? normalizeManagerName(teamInfo.manager, 2026, teamInfo.team_name, teamInfo.team_key) : managerKey,
                                units: 0,
                                bets: 0
                            };
                        }
                        stats.teamBreakdown[managerKey].units += bet.wager || 0;
                        stats.teamBreakdown[managerKey].bets++;
                    }
                });
                
                console.log('Calculated stats:', stats);
            } catch (e) {
                console.log('Error loading bet stats:', e);
            }
            
            return stats;
        }
        
        function renderBetStats(stats, betType) {
            const body = document.getElementById('bet-stats-body');
            
            if (stats.totalBets === 0) {
                body.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #666;">
                        <p>No bets placed on this market yet.</p>
                    </div>
                `;
                return;
            }
            
            // Sort teams by units bet
            const sortedTeams = Object.entries(stats.teamBreakdown)
                .map(([key, data]) => ({ teamKey: key, ...data }))
                .sort((a, b) => b.units - a.units);
            
            // Generate colors for pie chart - 12 distinct, easily viewable colors
            const pieColors = [
                '#e6194b', // Red
                '#3cb44b', // Green
                '#ffe119', // Yellow
                '#4363d8', // Blue
                '#f58231', // Orange
                '#911eb4', // Purple
                '#42d4f4', // Cyan
                '#f032e6', // Magenta
                '#bfef45', // Lime
                '#fabed4', // Pink
                '#469990', // Teal
                '#dcbeff'  // Lavender
            ];
            
            body.innerHTML = `
                <div class="bet-stats-summary">
                    <div class="bet-stats-box">
                        <div class="bet-stats-box-value">${stats.totalUnits}</div>
                        <div class="bet-stats-box-label">Total Units Wagered</div>
                    </div>
                    <div class="bet-stats-box">
                        <div class="bet-stats-box-value">${stats.totalBets}</div>
                        <div class="bet-stats-box-label">Total Bets Placed</div>
                    </div>
                </div>
                
                <div class="bet-stats-chart-toggle">
                    <button class="bet-stats-chart-btn ${betStatsChartMode === 'logos' ? 'active' : ''}" onclick="setBetStatsChartMode('logos')">Logos</button>
                    <button class="bet-stats-chart-btn ${betStatsChartMode === 'colors' ? 'active' : ''}" onclick="setBetStatsChartMode('colors')">Colors</button>
                </div>
                
                <div class="bet-stats-chart-container">
                    <svg class="bet-stats-pie" viewBox="0 0 200 200" id="bet-stats-pie-svg">
                        ${generatePieChart(sortedTeams, stats.totalUnits, pieColors)}
                    </svg>
                </div>
                
                <div class="bet-stats-legend">
                    ${sortedTeams.map((team, i) => `
                        <div class="bet-stats-legend-item">
                            ${betStatsChartMode === 'logos' 
                                ? `<img class="bet-stats-legend-logo" src="${team.logo}" alt="${team.teamName}">`
                                : `<div class="bet-stats-legend-color" style="background: ${pieColors[i % pieColors.length]};"></div>`
                            }
                            <span>${team.teamName}: ${((team.units / stats.totalUnits) * 100).toFixed(1)}%</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        function generatePieChart(teams, totalUnits, colors) {
            if (teams.length === 0 || totalUnits === 0) {
                return '<circle cx="100" cy="100" r="80" fill="#eee"/><text x="100" y="105" text-anchor="middle" fill="#999" font-size="14">No data</text>';
            }
            
            const cx = 100, cy = 100, r = 80;
            
            // Special case: only one team has all the bets - draw a full circle
            if (teams.length === 1 || teams[0].units === totalUnits) {
                const team = teams[0];
                if (betStatsChartMode === 'logos') {
                    return `
                        <defs>
                            <pattern id="pattern-single" patternUnits="objectBoundingBox" width="1" height="1">
                                <image href="${team.logo}" x="0" y="0" width="200" height="200" preserveAspectRatio="xMidYMid slice"/>
                            </pattern>
                        </defs>
                        <circle cx="${cx}" cy="${cy}" r="${r}" fill="url(#pattern-single)" stroke="white" stroke-width="2"/>
                    `;
                } else {
                    return `<circle cx="${cx}" cy="${cy}" r="${r}" fill="${colors[0]}" stroke="white" stroke-width="2"/>`;
                }
            }
            
            let currentAngle = -90; // Start from top
            let paths = '';
            
            teams.forEach((team, i) => {
                const percentage = team.units / totalUnits;
                const angle = percentage * 360;
                
                // Skip if angle is too small to render
                if (angle < 0.1) return;
                
                // For angles very close to 360, cap at 359.9 to avoid arc issues
                const drawAngle = Math.min(angle, 359.9);
                const largeArc = drawAngle > 180 ? 1 : 0;
                
                const startAngleRad = (currentAngle * Math.PI) / 180;
                const endAngleRad = ((currentAngle + drawAngle) * Math.PI) / 180;
                
                const x1 = cx + r * Math.cos(startAngleRad);
                const y1 = cy + r * Math.sin(startAngleRad);
                const x2 = cx + r * Math.cos(endAngleRad);
                const y2 = cy + r * Math.sin(endAngleRad);
                
                if (betStatsChartMode === 'logos') {
                    // Create clip path for logo slice
                    const pathId = `slice-${i}`;
                    const patternId = `pattern-${i}`;
                    
                    paths += `
                        <defs>
                            <clipPath id="clip-${pathId}">
                                <path d="M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2} Z"/>
                            </clipPath>
                            <pattern id="${patternId}" patternUnits="objectBoundingBox" width="1" height="1">
                                <image href="${team.logo}" x="0" y="0" width="200" height="200" preserveAspectRatio="xMidYMid slice"/>
                            </pattern>
                        </defs>
                        <path d="M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2} Z" 
                              fill="url(#${patternId})" 
                              stroke="white" stroke-width="2"
                              clip-path="url(#clip-${pathId})"/>
                    `;
                } else {
                    paths += `
                        <path d="M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 ${largeArc} 1 ${x2} ${y2} Z" 
                              fill="${colors[i % colors.length]}" 
                              stroke="white" stroke-width="2"/>
                    `;
                }
                
                currentAngle += angle;
            });
            
            return paths;
        }
        
        function setBetStatsChartMode(mode) {
            betStatsChartMode = mode;
            if (currentBetStatsData) {
                renderBetStats(currentBetStatsData, currentBetStatsType);
            }
        }
        
        function closeBetStatsModal() {
            document.getElementById('bet-stats-modal').classList.remove('active');
        }
        
        // Team totals info popup
        function showTeamTotalStats(teamKey, teamName, betTypePrefix) {
            const modal = document.getElementById('bet-stats-modal');
            const title = document.getElementById('bet-stats-title');
            const body = document.getElementById('bet-stats-body');
            
            title.textContent = `${teamName} - O/U Stats`;
            
            loadTeamTotalStatsData(teamKey, betTypePrefix).then(stats => {
                renderTeamTotalStats(stats, teamName);
            });
            
            modal.classList.add('active');
        }
        
        async function loadTeamTotalStatsData(teamKey, betTypePrefix) {
            const stats = {
                totalUnits: 0,
                overUnits: 0,
                underUnits: 0,
                overBets: 0,
                underBets: 0
            };
            
            // Initialize Firebase ref if needed
            if (!sportsbookBetsRef && firebaseDb) {
                sportsbookBetsRef = firebaseDb.ref('sportsbook_bets');
            }
            
            if (!sportsbookBetsRef) {
                console.log('No sportsbookBetsRef available');
                return stats;
            }
            
            // Build mappings between 2025 and 2026 keys via manager name
            const teamKey2025ToManager = {
                '458.l.4156.t.1': 'Josh B',
                '458.l.4156.t.2': 'Ryan',
                '458.l.4156.t.3': 'Coleman',
                '458.l.4156.t.4': 'Riley',
                '458.l.4156.t.5': 'Dalton',
                '458.l.4156.t.6': 'Robert',
                '458.l.4156.t.7': 'Tyler',
                '458.l.4156.t.8': 'Dylan',
                '458.l.4156.t.9': 'Red',
                '458.l.4156.t.10': 'Logan S',
                '458.l.4156.t.11': 'Rich',
                '458.l.4156.t.12': 'Nate'
            };
            
            // Find the manager for the current team
            const currentTeam = sportsbookTeamData.find(t => t.team_key === teamKey);
            const currentManager = currentTeam 
                ? normalizeManagerName(currentTeam.manager, 2026, currentTeam.team_name, currentTeam.team_key).toLowerCase()
                : null;
            
            // Find the 2025 key for this manager
            let team2025Key = null;
            if (currentManager) {
                for (const [key2025, manager] of Object.entries(teamKey2025ToManager)) {
                    if (manager.toLowerCase() === currentManager) {
                        team2025Key = key2025;
                        break;
                    }
                }
            }
            
            console.log('Looking for bets for team:', teamKey);
            console.log('Manager:', currentManager, '2025 key:', team2025Key);
            console.log('Bet type prefix:', betTypePrefix);
            
            try {
                const snapshot = await sportsbookBetsRef.once('value');
                const allBets = snapshot.val();
                
                if (!allBets) return stats;
                
                // Bets are stored as a flat list
                Object.entries(allBets).forEach(([betId, bet]) => {
                    if (!bet || !bet.betType) return;
                    
                    const bt = bet.betType;
                    
                    // Check for over bets - match against both 2025 and 2026 keys
                    if (bt.startsWith(`${betTypePrefix}_over_`)) {
                        const betTeamKey = bt.substring(`${betTypePrefix}_over_`.length);
                        
                        // Check if this matches current team key OR the 2025 key
                        const matchesTeam = betTeamKey === teamKey || 
                            betTeamKey === team2025Key ||
                            betTeamKey.replace(/[.#$\[\]]/g, '_') === teamKey.replace(/[.#$\[\]]/g, '_') ||
                            (team2025Key && betTeamKey.replace(/[.#$\[\]]/g, '_') === team2025Key.replace(/[.#$\[\]]/g, '_'));
                        
                        if (matchesTeam) {
                            stats.overUnits += bet.wager || 0;
                            stats.overBets++;
                            stats.totalUnits += bet.wager || 0;
                            console.log(' Found OVER bet:', bt, 'wager:', bet.wager);
                        }
                    }
                    // Check for under bets - match against both 2025 and 2026 keys
                    else if (bt.startsWith(`${betTypePrefix}_under_`)) {
                        const betTeamKey = bt.substring(`${betTypePrefix}_under_`.length);
                        
                        // Check if this matches current team key OR the 2025 key
                        const matchesTeam = betTeamKey === teamKey || 
                            betTeamKey === team2025Key ||
                            betTeamKey.replace(/[.#$\[\]]/g, '_') === teamKey.replace(/[.#$\[\]]/g, '_') ||
                            (team2025Key && betTeamKey.replace(/[.#$\[\]]/g, '_') === team2025Key.replace(/[.#$\[\]]/g, '_'));
                        
                        if (matchesTeam) {
                            stats.underUnits += bet.wager || 0;
                            stats.underBets++;
                            stats.totalUnits += bet.wager || 0;
                            console.log(' Found UNDER bet:', bt, 'wager:', bet.wager);
                        }
                    }
                });
                
                console.log('Final team total stats:', stats);
            } catch (e) {
                console.log('Error loading team total stats:', e);
            }
            
            return stats;
        }
        
        function renderTeamTotalStats(stats, teamName) {
            const body = document.getElementById('bet-stats-body');
            
            if (stats.totalUnits === 0) {
                body.innerHTML = `
                    <div style="text-align: center; padding: 2rem; color: #666;">
                        <p>No bets placed on ${teamName}'s totals yet.</p>
                    </div>
                `;
                return;
            }
            
            const overPct = ((stats.overUnits / stats.totalUnits) * 100).toFixed(1);
            const underPct = ((stats.underUnits / stats.totalUnits) * 100).toFixed(1);
            
            body.innerHTML = `
                <div class="bet-stats-summary">
                    <div class="bet-stats-box">
                        <div class="bet-stats-box-value">${stats.totalUnits}</div>
                        <div class="bet-stats-box-label">Total Units</div>
                    </div>
                    <div class="bet-stats-box">
                        <div class="bet-stats-box-value">${stats.overBets + stats.underBets}</div>
                        <div class="bet-stats-box-label">Total Bets</div>
                    </div>
                </div>
                
                <div style="margin-top: 1.5rem;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-weight: 600;">
                        <span style="color: #28a745;">Over: ${overPct}%</span>
                        <span style="color: #dc3545;">Under: ${underPct}%</span>
                    </div>
                    <div class="ou-stats-bar">
                        <div class="ou-stats-over" style="width: ${overPct}%;">${stats.overUnits}u</div>
                        <div class="ou-stats-under" style="width: ${underPct}%;">${stats.underUnits}u</div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.85rem; color: #666;">
                        <span>${stats.overBets} bet${stats.overBets !== 1 ? 's' : ''}</span>
                        <span>${stats.underBets} bet${stats.underBets !== 1 ? 's' : ''}</span>
                    </div>
                </div>
            `;
        }
        
        let selectedSportsbookTeam = null;
        
        function selectSportsbookTeam(teamKey) {
            selectedSportsbookTeam = teamKey;
            
            // Update selection visuals
            document.querySelectorAll('.sportsbook-team-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.teamKey === teamKey);
            });
            
            // Find team info
            const team = sportsbookTeamData.find(t => t.team_key === teamKey);
            if (team) {
                document.getElementById('sportsbook-selected-team-name').textContent = team.team_name;
                document.getElementById('sportsbook-password-section').classList.add('active');
                document.getElementById('sportsbook-password').value = '';
                
                // Scroll modal content to bottom to show all buttons
                const modalContent = document.querySelector('.sportsbook-login-content');
                if (modalContent) {
                    setTimeout(() => {
                        modalContent.scrollTo({
                            top: modalContent.scrollHeight,
                            behavior: 'smooth'
                        });
                    }, 100);
                }
                
                // Delay focus slightly and use preventScroll to avoid additional scrolling
                // Also prevents iOS zoom by not immediately focusing
                setTimeout(() => {
                    const passwordInput = document.getElementById('sportsbook-password');
                    // Only focus on desktop to avoid mobile keyboard issues
                    if (window.innerWidth > 768) {
                        passwordInput.focus({ preventScroll: true });
                    }
                }, 300);
            }
        }
        
        function sportsbookBackToTeamSelect() {
            selectedSportsbookTeam = null;
            document.querySelectorAll('.sportsbook-team-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.getElementById('sportsbook-password-section').classList.remove('active');
            document.getElementById('sportsbook-login-error').style.display = 'none';
        }
        
        async function authenticateSportsbook() {
            if (!selectedSportsbookTeam) {
                return;
            }
            
            if (!keeperConfig) {
                document.getElementById('sportsbook-login-error').textContent = 'Configuration not loaded. Please try again.';
                document.getElementById('sportsbook-login-error').style.display = 'block';
                return;
            }
            
            const password = document.getElementById('sportsbook-password').value;
            
            // Find team from current season data
            const team = sportsbookTeamData.find(t => t.team_key === selectedSportsbookTeam);
            if (!team) {
                document.getElementById('sportsbook-login-error').textContent = 'Team not found.';
                document.getElementById('sportsbook-login-error').style.display = 'block';
                return;
            }
            
            const managerName = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
            
            // Find team config by manager name (works across season key changes)
            // First try direct key lookup, then fall back to manager name search
            let teamConfig = keeperConfig.teams?.[selectedSportsbookTeam];
            
            if (!teamConfig) {
                // Search by manager name in keeperConfig.teams
                const configEntry = Object.entries(keeperConfig.teams || {}).find(([key, config]) => {
                    const configManager = normalizeManagerName(config.manager, 2026, config.team_name, key);
                    return configManager === managerName;
                });
                if (configEntry) {
                    teamConfig = configEntry[1];
                }
            }
            
            if (!teamConfig) {
                document.getElementById('sportsbook-login-error').textContent = 'Team configuration not found. Please contact the commissioner.';
                document.getElementById('sportsbook-login-error').style.display = 'block';
                return;
            }
            
            // Hash the entered password and compare (same as keeper system)
            const enteredHash = await hashPassword(password);
            
            if (enteredHash !== teamConfig.password_hash) {
                document.getElementById('sportsbook-login-error').textContent = 'Incorrect password. Hint: [YourName][YearJoined]';
                document.getElementById('sportsbook-login-error').style.display = 'block';
                return;
            }
            
            // Authentication successful
            sportsbookUser = {
                visitorId: managerName, // Use manager name as primary identifier (persists across seasons)
                teamKey: selectedSportsbookTeam, // Current season team key (for display only)
                teamName: team?.team_name || 'Unknown',
                teamLogo: fixTeamLogo(team?.team_logo) || 'league_logo.png',
                manager: managerName
            };
            
            closeSportsbookLogin();
            await loadSportsbookData();
            showSportsbookLoggedIn();
        }
        
        async function loadSportsbookData() {
            if (!sportsbookUser || !firebaseDb) return;
            
            // Load user's balance using manager name (persists across seasons)
            const sanitizedKey = sanitizeFirebaseKey(sportsbookUser.manager);
            try {
                const balanceSnapshot = await sportsbookBalancesRef.child(sanitizedKey).once('value');
                let balance = balanceSnapshot.val();
                
                if (balance === null) {
                    // Initialize new user with preseason budget
                    balance = { total: PRESEASON_BUDGET, lastWeeklyAdd: 0, manager: sportsbookUser.manager };
                    await sportsbookBalancesRef.child(sanitizedKey).set(balance);
                }
                
                document.getElementById('sportsbook-balance').textContent = balance.total || PRESEASON_BUDGET;
            } catch (e) {
                console.log('Could not load sportsbook balance:', e);
                document.getElementById('sportsbook-balance').textContent = PRESEASON_BUDGET;
            }
            
            // Load season bets
            await loadSeasonBets();
            
            // Load bet history
            await loadBetHistory();
        }
        
        function showSportsbookLoggedIn() {
            document.getElementById('sportsbook-not-logged-in').style.display = 'none';
            document.getElementById('sportsbook-logged-in').style.display = 'block';
            
            document.getElementById('sportsbook-user-logo').src = sportsbookUser.teamLogo;
        }
        
        function logoutSportsbook() {
            sportsbookUser = null;
            sportsbookBetSlip = [];
            updateBetSlip();
            
            document.getElementById('sportsbook-not-logged-in').style.display = 'block';
            document.getElementById('sportsbook-logged-in').style.display = 'none';
        }
        
        function switchSportsbookTab(tab) {
            // Update buttons
            document.querySelectorAll('.sportsbook-tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(tab));
            });
            
            // Show/hide content
            document.getElementById('sportsbook-tab-sportsbook').classList.toggle('active', tab === 'sportsbook');
            document.getElementById('sportsbook-tab-history').classList.toggle('active', tab === 'history');
        }
        
        function switchSportsbookSubtab(subtab) {
            // Update buttons
            document.querySelectorAll('.sportsbook-subtab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(subtab));
            });
            
            // Show/hide content
            document.getElementById('sportsbook-season-bets').classList.toggle('active', subtab === 'season');
            document.getElementById('sportsbook-weekly-bets').classList.toggle('active', subtab === 'weekly');
            
            if (subtab === 'weekly') {
                loadWeeklyMatchupBets();
            }
        }
        
        async function loadSeasonBets() {
            // Calculate odds based on team values and manager factors
            const teamData = await calculateTeamValuesForOdds();
            
            // Load manager historical data for factors
            const managerFactors = await loadManagerHistoricalFactors();
            
            // Load historical league averages for team totals projections
            const historicalAverages = await loadHistoricalLeagueAverages();
            
            // Apply manager factors to team data
            teamData.forEach(team => {
                const factor = managerFactors[team.rawManager] || managerFactors[team.manager] || { pointsFactor: 1, winsFactor: 1, championFactor: 1 };
                team.pointsFactor = factor.pointsFactor;
                team.winsFactor = factor.winsFactor;
                team.championFactor = factor.championFactor || 1;
                // Store raw ratios for projections
                team.rawWinPctRatio = factor.rawWinPctRatio || 1;
                team.rawPointsRatio = factor.rawPointsRatio || 1;
            });
            
            // Render team totals (over/under bets)
            renderTeamTotals(teamData, historicalAverages);
            
            // Generate odds for each bet type with appropriate sorting and factors
            renderSeasonBetGrid('season-bet-champion', teamData, 'champion');
            renderSeasonBetGrid('season-bet-wins', teamData, 'wins');
            renderSeasonBetGrid('season-bet-points', teamData, 'points');
            renderSeasonBetGrid('season-bet-last', teamData, 'last');
        }
        
        async function loadHistoricalLeagueAverages() {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            let totalWins = 0;
            let totalPoints = 0;
            let teamSeasons = 0;
            
            for (const season of seasons) {
                try {
                    let response;
                    if (season === 2026) {
                        response = await fetch('data/historical/2025/standings.json');
                    } else {
                        response = await fetch(`data/historical/${season}/final_standings.json`);
                    }
                    
                    if (response.ok) {
                        const standings = await response.json();
                        standings.forEach(team => {
                            const wins = team.wins || team.Wins || 0;
                            const points = team.points_for || team.total_points || team['Points For'] || 0;
                            totalWins += wins;
                            totalPoints += points;
                            teamSeasons++;
                        });
                    }
                } catch (e) {
                    // Skip seasons that fail
                }
            }
            
            return {
                avgWins: teamSeasons > 0 ? totalWins / teamSeasons : 10,
                avgPoints: teamSeasons > 0 ? totalPoints / teamSeasons : 8000
            };
        }
        
        function renderTeamTotals(teamData, historicalAverages) {
            const container = document.getElementById('team-totals-grid');
            if (!container) return;
            
            // Calculate team value stats for scaling
            const values = teamData.map(t => t.value);
            const avgValue = values.reduce((a, b) => a + b, 0) / values.length;
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            const valueRange = maxValue - minValue;
            
            // Calculate projections for all teams first
            const teamsWithProjections = teamData.map(team => {
                // Normalize value to a 0-1 scale
                const valueRatio = valueRange > 0 ? (team.value - minValue) / valueRange : 0.5;
                
                // Base wins projection: scale from ~6 to ~14 based on value
                const baseWins = 6 + (valueRatio * 8);
                // Apply manager win% factor (0.97-1.03 range)
                const projectedWins = baseWins * team.winsFactor;
                // Round to nearest 0.5, ensure ends in .5
                let winLine = Math.round(projectedWins * 2) / 2;
                if (Number.isInteger(winLine)) winLine += 0.5;
                
                // Calculate projected points based on team value and manager points factor
                // Realistic range: ~5800 to ~7600 based on historical data
                const basePoints = 5800 + (valueRatio * 1800);
                // Apply manager points factor
                const projectedPoints = basePoints * team.pointsFactor;
                // Round to nearest 50, then add 0.5
                const pointsLine = Math.round(projectedPoints / 50) * 50 + 0.5;
                
                // Calculate over/under odds
                const winOdds = calculateOverUnderOdds(projectedWins, winLine);
                const pointsOdds = calculateOverUnderOdds(projectedPoints, pointsLine);
                
                return { ...team, winLine, pointsLine, winOdds, pointsOdds, projectedWins, projectedPoints };
            });
            
            // Sort by wins for wins column (descending by win line)
            const teamsByWins = [...teamsWithProjections].sort((a, b) => b.winLine - a.winLine || b.value - a.value);
            
            // Sort by points for points column (descending by points line)
            const teamsByPoints = [...teamsWithProjections].sort((a, b) => b.pointsLine - a.pointsLine || b.value - a.value);
            
            // Create two-column layout
            container.innerHTML = `
                <div class="team-totals-columns">
                    <div class="team-totals-column">
                        <div class="totals-column-header">Season Wins</div>
                        ${teamsByWins.map(team => `
                            <div class="team-total-row">
                                <div class="team-total-info">
                                    <img class="team-total-logo" src="${team.teamLogo || 'league_logo.png'}" alt="${team.teamName}">
                                    <div class="team-total-details">
                                        <div class="team-total-name">${team.teamName}<span class="team-total-info-btn" onclick="event.stopPropagation(); showTeamTotalStats('${team.teamKey}', '${team.teamName}', 'wins')" title="View betting stats">i</span></div>
                                        <div class="team-total-manager">${team.manager}</div>
                                    </div>
                                </div>
                                <div class="team-total-line">${team.winLine} W</div>
                                <div class="team-total-odds">
                                    <div class="total-bet-arrow over" 
                                         onclick="addToBetSlip('wins_over_${team.teamKey}', '${team.teamKey}', '${team.teamName} O${team.winLine} W', '${team.winOdds.over}', 'season')">
                                        <span>O ${team.winOdds.over}</span>
                                    </div>
                                    <div class="total-bet-arrow under"
                                         onclick="addToBetSlip('wins_under_${team.teamKey}', '${team.teamKey}', '${team.teamName} U${team.winLine} W', '${team.winOdds.under}', 'season')">
                                        <span>U ${team.winOdds.under}</span>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="team-totals-column">
                        <div class="totals-column-header">Season Points</div>
                        ${teamsByPoints.map(team => `
                            <div class="team-total-row">
                                <div class="team-total-info">
                                    <img class="team-total-logo" src="${team.teamLogo || 'league_logo.png'}" alt="${team.teamName}">
                                    <div class="team-total-details">
                                        <div class="team-total-name">${team.teamName}<span class="team-total-info-btn" onclick="event.stopPropagation(); showTeamTotalStats('${team.teamKey}', '${team.teamName}', 'points')" title="View betting stats">i</span></div>
                                        <div class="team-total-manager">${team.manager}</div>
                                    </div>
                                </div>
                                <div class="team-total-line">${team.pointsLine.toLocaleString()}</div>
                                <div class="team-total-odds">
                                    <div class="total-bet-arrow over"
                                         onclick="addToBetSlip('points_over_${team.teamKey}', '${team.teamKey}', '${team.teamName} O${team.pointsLine} pts', '${team.pointsOdds.over}', 'season')">
                                        <span>O ${team.pointsOdds.over}</span>
                                    </div>
                                    <div class="total-bet-arrow under"
                                         onclick="addToBetSlip('points_under_${team.teamKey}', '${team.teamKey}', '${team.teamName} U${team.pointsLine} pts', '${team.pointsOdds.under}', 'season')">
                                        <span>U ${team.pointsOdds.under}</span>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        function calculateOverUnderOdds(projected, line) {
            // Calculate how far the line is from the projection
            const diff = line - projected;
            const percentDiff = Math.abs(diff / projected);
            
            // If line is very close to projection, odds are near even (-110/-110)
            // If line is above projection, over is harder (higher + odds), under is easier (lower - odds)
            // If line is below projection, under is harder, over is easier
            
            // Base odds around -110 (standard juice)
            let overOdds, underOdds;
            
            if (Math.abs(percentDiff) < 0.02) {
                // Very close - standard juice
                overOdds = -110;
                underOdds = -110;
            } else if (diff > 0) {
                // Line is above projection - over is harder
                const adjustment = Math.min(percentDiff * 500, 150);
                overOdds = Math.round(100 + adjustment);
                underOdds = Math.round(-110 - adjustment * 0.5);
            } else {
                // Line is below projection - under is harder
                const adjustment = Math.min(percentDiff * 500, 150);
                underOdds = Math.round(100 + adjustment);
                overOdds = Math.round(-110 - adjustment * 0.5);
            }
            
            // Format odds
            const formatOdds = (odds) => odds > 0 ? `+${odds}` : `${odds}`;
            
            return {
                over: formatOdds(overOdds),
                under: formatOdds(underOdds)
            };
        }
        
        async function loadManagerHistoricalFactors() {
            const factors = {};
            
            try {
                // Load historical standings to calculate manager averages
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                const managerStats = {};
                
                for (const season of seasons) {
                    try {
                        let response;
                        if (season === 2026) {
                            response = await fetch('data/historical/2025/standings.json');
                        } else {
                            response = await fetch(`data/historical/${season}/final_standings.json`);
                        }
                        
                        if (response.ok) {
                            const standings = await response.json();
                            standings.forEach(team => {
                                const manager = team.manager || team.Manager;
                                const points = team.points_for || team.total_points || team['Points For'] || 0;
                                const wins = team.wins || team.Wins || 0;
                                const losses = team.losses || team.Losses || 0;
                                const totalGames = wins + losses;
                                
                                if (!managerStats[manager]) {
                                    managerStats[manager] = { totalPoints: 0, totalWins: 0, totalGames: 0, seasons: 0 };
                                }
                                managerStats[manager].totalPoints += points;
                                managerStats[manager].totalWins += wins;
                                managerStats[manager].totalGames += totalGames;
                                managerStats[manager].seasons++;
                            });
                        }
                    } catch (e) {
                        // Skip seasons that fail to load
                    }
                }
                
                // Calculate points per season and win percentage per manager
                const pointsPerSeason = {};
                const winPcts = {};
                let leagueAvgPointsPerSeason = 0;
                let leagueAvgWinPct = 0;
                let managerCount = 0;
                
                Object.entries(managerStats).forEach(([manager, stats]) => {
                    if (stats.seasons > 0) {
                        pointsPerSeason[manager] = stats.totalPoints / stats.seasons;
                        winPcts[manager] = stats.totalGames > 0 ? stats.totalWins / stats.totalGames : 0.5;
                        leagueAvgPointsPerSeason += pointsPerSeason[manager];
                        leagueAvgWinPct += winPcts[manager];
                        managerCount++;
                    }
                });
                
                if (managerCount > 0) {
                    leagueAvgPointsPerSeason /= managerCount;
                    leagueAvgWinPct /= managerCount;
                }
                
                // Calculate factors with sample size weighting
                Object.entries(managerStats).forEach(([manager, stats]) => {
                    if (stats.seasons > 0) {
                        const pointsRatio = leagueAvgPointsPerSeason > 0 ? pointsPerSeason[manager] / leagueAvgPointsPerSeason : 1;
                        const winPctRatio = leagueAvgWinPct > 0 ? winPcts[manager] / leagueAvgWinPct : 1;
                        
                        // Sample size weight: more seasons = more confidence
                        // 1 season = 20% weight, 3 seasons = 50% weight, 5+ seasons = 80% weight
                        const sampleWeight = Math.min(0.8, 0.1 + (stats.seasons * 0.14));
                        
                        // Regress toward 1.0 based on sample size
                        const regressedPointsRatio = 1 + (pointsRatio - 1) * sampleWeight;
                        const regressedWinPctRatio = 1 + (winPctRatio - 1) * sampleWeight;
                        
                        // Combined ratio for champion (average of win% and points)
                        const combinedRatio = (regressedWinPctRatio + regressedPointsRatio) / 2;
                        
                        // Range 0.97 to 1.03 for wins and points
                        const winsFactor = 0.97 + (Math.min(Math.max(regressedWinPctRatio, 0.85), 1.15) - 0.85) * 0.2;
                        const pointsFactor = 0.97 + (Math.min(Math.max(regressedPointsRatio, 0.85), 1.15) - 0.85) * 0.2;
                        
                        // Wider range for champion (0.95 to 1.05) using combined factor
                        const championFactor = 0.95 + (Math.min(Math.max(combinedRatio, 0.85), 1.15) - 0.85) * 0.333;
                        
                        factors[manager] = {
                            pointsFactor: pointsFactor,
                            winsFactor: winsFactor,
                            championFactor: championFactor,
                            rawWinPctRatio: regressedWinPctRatio,
                            rawPointsRatio: regressedPointsRatio,
                            seasons: stats.seasons,
                            winPct: winPcts[manager],
                            pointsPerSeason: pointsPerSeason[manager]
                        };
                    }
                });
                
            } catch (e) {
                console.log('Could not load manager historical factors:', e);
            }
            
            return factors;
        }
        
        async function calculateTeamValuesForOdds() {
            const teamValues = [];
            
            // Try to load team value rankings from the value suite calculation
            let valueRankingsData = {};
            
            // First try to get values from the rendered value rankings table
            try {
                const valueTable = document.getElementById('value-rankings-table');
                if (valueTable) {
                    const rows = valueTable.querySelectorAll('tbody tr');
                    if (rows.length > 0) {
                        rows.forEach(row => {
                            // Use data-total attribute for the combined total value
                            const totalValue = parseFloat(row.dataset.total) || 0;
                            
                            // Get team name from the nested div structure
                            const teamNameDiv = row.querySelector('td:first-child .team-cell div div');
                            const teamName = teamNameDiv ? teamNameDiv.textContent.trim() : '';
                            
                            if (teamName && totalValue > 0) {
                                valueRankingsData[teamName] = totalValue;
                            }
                        });
                        console.log('Loaded values from table:', valueRankingsData);
                    }
                }
            } catch (e) {
                console.log('Could not read value rankings table:', e);
            }
            
            // If we couldn't get values from the table, calculate them directly
            if (Object.keys(valueRankingsData).length === 0) {
                console.log('Value table not available, calculating directly...');
                valueRankingsData = await calculateTeamValuesDirectly();
            }
            
            console.log('Team values loaded:', valueRankingsData);
            
            for (const team of sportsbookTeamData) {
                const teamName = team.team_name;
                const value = valueRankingsData[teamName] || 5000;
                
                teamValues.push({
                    teamKey: team.team_key,
                    teamName: team.team_name,
                    teamLogo: fixTeamLogo(team.team_logo),
                    manager: normalizeManagerName(team.manager, 2026, team.team_name, team.team_key),
                    rawManager: team.manager,
                    value: value,
                    pointsFactor: 1,
                    winsFactor: 1
                });
            }
            
            return teamValues;
        }
        
        async function calculateTeamValuesDirectly() {
            const teamValues = {};
            
            try {
                // Load keepers from Firebase (same source as Value Suite)
                let allKeepers = {};
                
                if (firebaseDb) {
                    try {
                        const keepersRef = firebaseDb.ref('keepers_2026');
                        const snapshot = await keepersRef.once('value');
                        allKeepers = snapshot.val() || {};
                        console.log('Loaded keepers from Firebase:', Object.keys(allKeepers).length, 'teams');
                    } catch (e) {
                        console.log('Could not load keepers from Firebase:', e);
                    }
                }
                
                // If Firebase didn't work, try local file
                if (Object.keys(allKeepers).length === 0) {
                    try {
                        const keepersResponse = await fetch('data/keepers.json');
                        if (keepersResponse.ok) {
                            allKeepers = await keepersResponse.json();
                            console.log('Loaded keepers from local file');
                        }
                    } catch (e) {
                        console.log('Could not load keepers from local file:', e);
                    }
                }
                
                // Build a mapping from manager name to keepers (handles 2025 vs 2026 key mismatch)
                // Firebase keys are sanitized 2025 keys like "458_l_4156_t_1"
                const managerToKeepers = {};
                const teamKey2025ToManager = {
                    '458_l_4156_t_1': 'Josh B',
                    '458_l_4156_t_2': 'Ryan',
                    '458_l_4156_t_3': 'Coleman',
                    '458_l_4156_t_4': 'Riley',
                    '458_l_4156_t_5': 'Dalton',
                    '458_l_4156_t_6': 'Robert',
                    '458_l_4156_t_7': 'Tyler',
                    '458_l_4156_t_8': 'Dylan',
                    '458_l_4156_t_9': 'Red',
                    '458_l_4156_t_10': 'Logan S',
                    '458_l_4156_t_11': 'Rich',
                    '458_l_4156_t_12': 'Nate'
                };
                
                for (const [sanitizedKey, keepers] of Object.entries(allKeepers)) {
                    const manager = teamKey2025ToManager[sanitizedKey];
                    if (manager) {
                        managerToKeepers[manager.toLowerCase()] = keepers;
                    }
                }
                console.log('Manager to keepers mapping:', Object.keys(managerToKeepers));
                
                // Load projections
                let projections = {};
                try {
                    const projResponse = await fetch('data/projections/averaged_projections.json');
                    if (projResponse.ok) {
                        const projData = await projResponse.json();
                        (projData.batters || []).forEach(p => {
                            const name = (p.name || p.Name || '').toLowerCase().trim();
                            projections[name] = p.projected_points || p.Projected_Points || 0;
                        });
                        (projData.pitchers || []).forEach(p => {
                            const name = (p.name || p.Name || '').toLowerCase().trim();
                            projections[name] = p.projected_points || p.Projected_Points || 0;
                        });
                        console.log('Loaded projections:', Object.keys(projections).length, 'players');
                    }
                } catch (e) {
                    console.log('Could not load projections:', e);
                }
                
                // Calculate value for each team
                for (const team of sportsbookTeamData) {
                    // Look up keepers by manager name (handles key mismatch between seasons)
                    const managerName = normalizeManagerName(team.manager, 2026, team.team_name, team.team_key);
                    const teamKeepers = managerToKeepers[managerName.toLowerCase()] || allKeepers[team.team_key] || [];
                    let keeperValue = 0;
                    let draftValue = 0;
                    
                    // Calculate actual round costs for this team (accounting for bumping)
                    let actualRoundCosts = [];
                    if (typeof calculateTeamKeeperRoundCosts === 'function') {
                        actualRoundCosts = calculateTeamKeeperRoundCosts(team.team_key) || [];
                    }
                    const actualRoundMap = {};
                    actualRoundCosts.forEach(rc => {
                        if (rc.player_name) {
                            actualRoundMap[rc.player_name.toLowerCase()] = rc.actualRoundCost;
                        }
                    });
                    
                    // Track rounds used by keepers (count per round, not just Set)
                    const usedRounds = {};
                    if (Array.isArray(teamKeepers)) {
                        teamKeepers.forEach(keeper => {
                            const playerName = (keeper.player_name || keeper.name || keeper.Name || '').toLowerCase().trim();
                            const projectedPts = projections[playerName] || 0;
                            
                            // Use actual round cost (after bumping) if available, otherwise fall back to base cost
                            const baseRoundCost = keeper.round_cost || keeper.cost || keeper.round || keeper.roundCost || 22;
                            const actualRoundCost = actualRoundMap[playerName] ?? baseRoundCost;
                            const roundCost = actualRoundCost;
                            
                            const expectedPts = getExpectedPointsForRound(roundCost);
                            
                            // Track used rounds (using actual round cost)
                            usedRounds[roundCost] = (usedRounds[roundCost] || 0) + 1;
                            
                            // Value = projected + surplus (same as Value Suite)
                            const surplusValue = projectedPts - expectedPts;
                            const playerValue = projectedPts + surplusValue;
                            keeperValue += playerValue;
                        });
                    }
                    
                    // Get team's draft picks using the global function if available
                    let teamPicks = [];
                    if (typeof getTeamPicks === 'function') {
                        teamPicks = getTeamPicks(team.team_key) || [];
                    }
                    
                    // If getTeamPicks didn't return anything, default to owning all 22 picks
                    if (teamPicks.length === 0) {
                        for (let round = 1; round <= 22; round++) {
                            teamPicks.push({ round: round, originalOwner: team.team_key });
                        }
                    }
                    
                    // Count picks per round
                    const pickCounts = {};
                    teamPicks.forEach(pick => {
                        pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
                    });
                    
                    // Find unused picks (available picks minus keeper-used picks)
                    const unusedPicks = [];
                    Object.keys(pickCounts).forEach(round => {
                        const roundNum = parseInt(round);
                        const available = pickCounts[roundNum] || 0;
                        const used = usedRounds[roundNum] || 0;
                        const unused = available - used;
                        for (let i = 0; i < unused; i++) {
                            const expectedPts = getExpectedPointsForRound(roundNum);
                            unusedPicks.push({
                                round: roundNum,
                                expectedPts: expectedPts
                            });
                        }
                    });
                    
                    // Calculate total draft pick value
                    draftValue = unusedPicks.reduce((sum, p) => sum + p.expectedPts, 0);
                    
                    const totalValue = keeperValue + draftValue;
                    teamValues[team.team_name] = Math.max(totalValue, 1000);
                    console.log(`${team.team_name}: keeperValue=${keeperValue.toFixed(0)}, draftValue=${draftValue.toFixed(0)}, total=${totalValue.toFixed(0)}`);
                }
            } catch (e) {
                console.log('Error calculating team values:', e);
            }
            
            return teamValues;
        }
        
        function calculateAdjustedValue(team, betType) {
            const value = team.value;
            const pf = team.pointsFactor || 1;
            const wf = team.winsFactor || 1;
            const cf = team.championFactor || 1;
            
            // Manager factors are tiny adjustments - team value dominates
            switch (betType) {
                case 'champion':
                    // Champion: Team value with combined manager factor (win% + points avg)
                    // Uses wider range (0.975-1.025)
                    return value * cf;
                    
                case 'wins':
                    // Most Wins: Team value with win percentage factor only
                    // Uses tighter range (0.98-1.02)
                    return value * wf;
                    
                case 'points':
                    // Most Points: Team value with points per season factor
                    return value * pf;
                    
                case 'last':
                    // Last Place: Inverted - low value = best odds
                    return 1 / (value * pf);
                    
                default:
                    return value;
            }
        }
        
        function calculateOdds(team, allTeams, betType) {
            // Calculate adjusted values for all teams
            const adjustedValues = allTeams.map(t => ({
                team: t,
                adjusted: calculateAdjustedValue(t, betType)
            }));
            
            // Debug: log values to see what's happening
            console.log('Team values for', betType + ':', adjustedValues.map(t => ({
                name: t.team.teamName,
                value: t.team.value,
                adjusted: t.adjusted
            })).sort((a, b) => b.adjusted - a.adjusted));
            
            // Calculate total adjusted value
            const totalAdjusted = adjustedValues.reduce((sum, t) => sum + t.adjusted, 0);
            const teamAdjusted = calculateAdjustedValue(team, betType);
            
            // Calculate implied probability based on share of total value
            const probability = teamAdjusted / totalAdjusted;
            
            // Convert to American odds
            if (probability >= 0.5) {
                // Favorite: negative odds
                const odds = -Math.round((probability / (1 - probability)) * 100);
                return odds;
            } else {
                // Underdog: positive odds
                const odds = Math.round(((1 - probability) / probability) * 100);
                return '+' + odds;
            }
        }
        
        function renderSeasonBetGrid(containerId, teams, betType) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Sort teams by adjusted value (best odds first)
            const sortedTeams = [...teams].sort((a, b) => {
                const aVal = calculateAdjustedValue(a, betType);
                const bVal = calculateAdjustedValue(b, betType);
                return bVal - aVal; // Higher adjusted value = better odds = listed first
            });
            
            container.innerHTML = sortedTeams.map(team => {
                const odds = calculateOdds(team, teams, betType);
                const isUnderdog = typeof odds === 'string' && odds.startsWith('+');
                
                return `
                    <div class="season-bet-card" 
                         onclick="addToBetSlip('${betType}', '${team.teamKey}', '${team.teamName}', '${odds}', 'season')"
                         data-team-key="${team.teamKey}">
                        <img class="season-bet-logo" src="${team.teamLogo || 'league_logo.png'}" alt="${team.teamName}">
                        <div class="season-bet-card-info">
                            <div class="season-bet-team">${team.teamName}</div>
                            <div class="season-bet-manager">${team.manager}</div>
                        </div>
                        <div class="season-bet-odds ${isUnderdog ? 'underdog' : ''}">${odds}</div>
                    </div>
                `;
            }).join('');
        }
        
        async function loadWeeklyMatchupBets() {
            const weekSelect = document.getElementById('sportsbook-week-select');
            const container = document.getElementById('weekly-matchup-bets');
            
            // Try to load weekly stats to get matchups
            try {
                const response = await fetch('data/2026/weekly_stats.json');
                if (!response.ok) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No weekly matchups available yet.</p>';
                    return;
                }
                
                const weeklyStats = await response.json();
                const currentWeek = weeklyStats.currentWeek || 1;
                
                // Populate week selector
                if (weekSelect.options.length === 0) {
                    const weeks = Object.keys(weeklyStats.weeks || {}).map(Number).sort((a, b) => a - b);
                    weeks.forEach(week => {
                        const option = document.createElement('option');
                        option.value = week;
                        option.textContent = `Week ${week}`;
                        if (week === currentWeek) option.selected = true;
                        weekSelect.appendChild(option);
                    });
                }
                
                const selectedWeek = parseInt(weekSelect.value) || currentWeek;
                const weekData = weeklyStats.weeks?.[selectedWeek] || weeklyStats.weeks?.[String(selectedWeek)];
                
                if (!weekData?.matchups) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">No matchups found for this week.</p>';
                    return;
                }
                
                // Build team info lookup
                const teamInfoLookup = {};
                sportsbookTeamData.forEach(team => {
                    teamInfoLookup[team.team_key] = {
                        name: team.team_name,
                        manager: normalizeManagerName(team.manager, 2026, team.team_name, team.team_key),
                        logo: fixTeamLogo(team.team_logo) || 'league_logo.png'
                    };
                });
                
                // Render matchups
                container.innerHTML = weekData.matchups.map(matchup => {
                    const team1 = teamInfoLookup[matchup.team1_key] || { name: 'Unknown', logo: 'league_logo.png' };
                    const team2 = teamInfoLookup[matchup.team2_key] || { name: 'Unknown', logo: 'league_logo.png' };
                    
                    const proj1 = matchup.team1_projected || 0;
                    const proj2 = matchup.team2_projected || 0;
                    
                    // Calculate odds based on projected points
                    const odds1 = calculateMatchupOdds(proj1, proj2);
                    const odds2 = calculateMatchupOdds(proj2, proj1);
                    
                    return `
                        <div class="matchup-bet-card">
                            <div class="matchup-bet-vs">
                                <div class="matchup-bet-team" 
                                     onclick="addToBetSlip('weekly_${selectedWeek}', '${matchup.team1_key}', '${team1.name}', '${odds1}', 'weekly', '${team2.name}')"
                                     data-team-key="${matchup.team1_key}">
                                    <img class="matchup-bet-team-logo" src="${team1.logo}" alt="${team1.name}">
                                    <div class="matchup-bet-team-name">${team1.name}</div>
                                    <div class="matchup-bet-projected">Proj: ${proj1.toFixed(1)}</div>
                                    <div class="matchup-bet-team-odds ${odds1.toString().startsWith('+') ? 'underdog' : ''}">${odds1}</div>
                                </div>
                                <div class="matchup-bet-vs-label">VS</div>
                                <div class="matchup-bet-team"
                                     onclick="addToBetSlip('weekly_${selectedWeek}', '${matchup.team2_key}', '${team2.name}', '${odds2}', 'weekly', '${team1.name}')"
                                     data-team-key="${matchup.team2_key}">
                                    <img class="matchup-bet-team-logo" src="${team2.logo}" alt="${team2.name}">
                                    <div class="matchup-bet-team-name">${team2.name}</div>
                                    <div class="matchup-bet-projected">Proj: ${proj2.toFixed(1)}</div>
                                    <div class="matchup-bet-team-odds ${odds2.toString().startsWith('+') ? 'underdog' : ''}">${odds2}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
            } catch (e) {
                console.log('Could not load weekly matchups:', e);
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 2rem;">Could not load weekly matchups.</p>';
            }
        }
        
        function calculateMatchupOdds(teamProj, oppProj) {
            if (teamProj === 0 && oppProj === 0) return '-110';
            
            const total = teamProj + oppProj;
            const probability = teamProj / total;
            
            if (probability >= 0.5) {
                // Favorite
                const odds = -Math.round((probability / (1 - probability)) * 100);
                return Math.max(odds, -500); // Cap at -500
            } else {
                // Underdog
                const odds = Math.round(((1 - probability) / probability) * 100);
                return '+' + Math.min(odds, 500); // Cap at +500
            }
        }
        
        function addToBetSlip(betType, teamKey, teamName, odds, category, opponent = null) {
            // Check if already in slip
            const existingIndex = sportsbookBetSlip.findIndex(b => b.betType === betType && b.teamKey === teamKey);
            if (existingIndex >= 0) {
                // Remove if already selected
                sportsbookBetSlip.splice(existingIndex, 1);
            } else {
                // Add new bet
                sportsbookBetSlip.push({
                    betType,
                    teamKey,
                    teamName,
                    odds,
                    category,
                    opponent,
                    wager: 0
                });
            }
            
            updateBetSlip();
        }
        
        function updateBetSlip() {
            const slip = document.getElementById('bet-slip');
            const content = document.getElementById('bet-slip-content');
            
            if (sportsbookBetSlip.length === 0) {
                slip.classList.remove('active');
                return;
            }
            
            slip.classList.add('active');
            
            content.innerHTML = sportsbookBetSlip.map((bet, idx) => {
                const betTypeLabel = getBetTypeLabel(bet.betType);
                const payout = calculatePayout(bet.wager, bet.odds);
                
                return `
                    <div class="bet-slip-item">
                        <div class="bet-slip-item-header">
                            <span class="bet-slip-item-team">${bet.teamName}</span>
                            <span class="bet-slip-item-odds">${bet.odds}</span>
                        </div>
                        <div class="bet-slip-item-type">${betTypeLabel}${bet.opponent ? ' vs ' + bet.opponent : ''}</div>
                        <div class="bet-slip-item-wager">
                            <label>Wager:</label>
                            <div class="bet-slip-wager-stepper">
                                <button type="button" class="bet-slip-wager-btn minus" onclick="adjustBetWager(${idx}, -1, '${bet.odds}')"></button>
                                <input type="number" inputmode="numeric" pattern="[0-9]*" min="0" value="${bet.wager}" 
                                       oninput="updateBetWager(${idx}, this.value, '${bet.odds}')"
                                       id="wager-input-${idx}">
                                <button type="button" class="bet-slip-wager-btn plus" onclick="adjustBetWager(${idx}, 1, '${bet.odds}')">+</button>
                            </div>
                            <span class="bet-slip-item-payout" id="payout-${idx}">Win: ${payout}</span>
                            <button class="bet-slip-item-remove" onclick="removeBetFromSlip(${idx})"></button>
                        </div>
                    </div>
                `;
            }).join('');
            
            updateBetSlipTotals();
        }
        
        function getBetTypeLabel(betType) {
            if (betType === 'champion') return ' FBCW Champion';
            if (betType === 'wins') return ' Most Wins';
            if (betType === 'points') return ' Most Points';
            if (betType === 'last') return ' Last Place';
            if (betType.startsWith('wins_over_')) return ' Wins Over';
            if (betType.startsWith('wins_under_')) return ' Wins Under';
            if (betType.startsWith('points_over_')) return ' Points Over';
            if (betType.startsWith('points_under_')) return ' Points Under';
            if (betType.startsWith('weekly_')) return ' Week ' + betType.split('_')[1];
            return betType;
        }
        
        function calculatePayout(wager, odds) {
            if (!wager || wager <= 0) return 0;
            
            const oddsNum = typeof odds === 'string' ? parseInt(odds.replace('+', '')) : odds;
            
            if (odds.toString().startsWith('+') || oddsNum > 0) {
                // Underdog: wager * (odds/100)
                return (wager + (wager * Math.abs(oddsNum) / 100)).toFixed(1);
            } else {
                // Favorite: wager / (odds/100)
                return (wager + (wager * 100 / Math.abs(oddsNum))).toFixed(1);
            }
        }
        
        function updateBetWager(idx, value, odds) {
            const wager = parseFloat(value) || 0;
            sportsbookBetSlip[idx].wager = wager;
            
            // Update payout display in real-time
            const payoutEl = document.getElementById(`payout-${idx}`);
            if (payoutEl) {
                const payout = calculatePayout(wager, odds);
                payoutEl.textContent = `Win: ${payout}`;
            }
            
            updateBetSlipTotals();
        }
        
        function adjustBetWager(idx, delta, odds) {
            const input = document.getElementById(`wager-input-${idx}`);
            if (!input) return;
            
            let currentValue = parseInt(input.value) || 0;
            let newValue = currentValue + delta;
            
            // Don't go below 0
            if (newValue < 0) newValue = 0;
            
            input.value = newValue;
            updateBetWager(idx, newValue, odds);
        }
        
        function removeBetFromSlip(idx) {
            sportsbookBetSlip.splice(idx, 1);
            updateBetSlip();
        }
        
        function closeBetSlip() {
            document.getElementById('bet-slip').classList.remove('active');
        }
        
        function updateBetSlipTotals() {
            const totalWager = sportsbookBetSlip.reduce((sum, bet) => sum + (bet.wager || 0), 0);
            const totalPayout = sportsbookBetSlip.reduce((sum, bet) => {
                return sum + parseFloat(calculatePayout(bet.wager, bet.odds) || 0);
            }, 0);
            
            document.getElementById('bet-slip-total-wager').textContent = totalWager + ' units';
            document.getElementById('bet-slip-potential-payout').textContent = totalPayout.toFixed(1) + ' units';
            
            const balance = parseFloat(document.getElementById('sportsbook-balance').textContent) || 0;
            const submitBtn = document.getElementById('bet-slip-submit');
            submitBtn.disabled = totalWager <= 0 || totalWager > balance;
        }
        
        // Helper function to sanitize team keys for Firebase paths
        function sanitizeFirebaseKey(key) {
            // Replace characters not allowed in Firebase paths: . # $ [ ]
            return key.replace(/[.#$\[\]]/g, '_');
        }
        
        async function submitBets() {
            if (!sportsbookUser) {
                alert('Please log in first.');
                return;
            }
            
            if (!firebaseDb) {
                alert('Database connection not available. Please refresh the page.');
                return;
            }
            
            // Ensure refs are set up
            if (!sportsbookBetsRef) {
                sportsbookBetsRef = firebaseDb.ref('sportsbook_bets');
            }
            if (!sportsbookBalancesRef) {
                sportsbookBalancesRef = firebaseDb.ref('sportsbook_balances');
            }
            
            const totalWager = sportsbookBetSlip.reduce((sum, bet) => sum + (bet.wager || 0), 0);
            const balance = parseFloat(document.getElementById('sportsbook-balance').textContent) || 0;
            
            if (totalWager > balance) {
                alert('Insufficient balance!');
                return;
            }
            
            if (totalWager <= 0) {
                alert('Please enter a wager amount.');
                return;
            }
            
            // Use manager name as identifier (persists across seasons)
            const sanitizedUserKey = sanitizeFirebaseKey(sportsbookUser.manager);
            
            try {
                // Record each bet
                const timestamp = new Date().toISOString();
                for (const bet of sportsbookBetSlip) {
                    if (bet.wager > 0) {
                        await sportsbookBetsRef.push({
                            manager: sportsbookUser.manager, // Primary identifier
                            managerSanitized: sanitizedUserKey,
                            betType: bet.betType,
                            selection: bet.teamKey,
                            selectionName: bet.teamName,
                            opponent: bet.opponent || null,
                            odds: String(bet.odds),
                            wager: bet.wager,
                            potentialPayout: parseFloat(calculatePayout(bet.wager, bet.odds)),
                            status: 'pending',
                            timestamp: timestamp,
                            season: 2026 // Track which season the bet was placed
                        });
                    }
                }
                
                // Update balance using manager name
                const newBalance = balance - totalWager;
                await sportsbookBalancesRef.child(sanitizedUserKey).update({ 
                    total: newBalance,
                    manager: sportsbookUser.manager
                });
                document.getElementById('sportsbook-balance').textContent = newBalance;
                
                // Clear bet slip
                sportsbookBetSlip = [];
                updateBetSlip();
                
                // Reload bet history
                await loadBetHistory();
                
                alert('Bets placed successfully!');
                
            } catch (e) {
                console.error('Error placing bets:', e);
                console.error('Error details:', e.message, e.code);
                alert('Error placing bets: ' + (e.message || 'Please try again.'));
            }
        }
        
        async function loadBetHistory() {
            if (!sportsbookUser || !firebaseDb) return;
            
            // Ensure ref is set up
            if (!sportsbookBetsRef) {
                sportsbookBetsRef = firebaseDb.ref('sportsbook_bets');
            }
            
            const tbody = document.getElementById('bet-history-body');
            const emptyEl = document.getElementById('bet-history-empty');
            const sanitizedKey = sanitizeFirebaseKey(sportsbookUser.manager);
            
            try {
                // Query by manager name (persists across seasons)
                const snapshot = await sportsbookBetsRef.orderByChild('managerSanitized').equalTo(sanitizedKey).once('value');
                const bets = snapshot.val();
                
                if (!bets) {
                    tbody.innerHTML = '';
                    emptyEl.style.display = 'block';
                    return;
                }
                
                emptyEl.style.display = 'none';
                
                // Convert to array and sort by date desc
                const betArray = Object.entries(bets).map(([key, bet]) => ({ key, ...bet }));
                betArray.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                tbody.innerHTML = betArray.map(bet => {
                    const date = new Date(bet.timestamp);
                    const dateStr = date.toLocaleDateString();
                    const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    
                    return `
                        <tr>
                            <td>${dateStr}</td>
                            <td>${timeStr}</td>
                            <td>${getBetTypeLabel(bet.betType)}</td>
                            <td>${bet.selectionName}</td>
                            <td>${bet.opponent || '-'}</td>
                            <td>${bet.odds}</td>
                            <td>${bet.wager} units</td>
                            <td>${bet.potentialPayout} units</td>
                            <td><span class="bet-status ${bet.status}">${bet.status.charAt(0).toUpperCase() + bet.status.slice(1)}</span></td>
                        </tr>
                    `;
                }).join('');
                
            } catch (e) {
                console.log('Could not load bet history:', e);
                tbody.innerHTML = '';
                emptyEl.style.display = 'block';
            }
        }

        // ===== HOMEPAGE FUNCTIONS =====
        let homepageDataLoaded = false;
        let homePlayersData = [];
        let homeTeamsData = [];
        let homeStandingsData = [];
        let homeTransactionsData = [];
        let homeScoresData = [];
        let homeRostersData = null;
        
        function scrollMatchupTicker(direction) {
            const container = document.getElementById('home-matchup-ticker');
            const items = container.querySelectorAll('.matchup-ticker-item');
            if (items.length === 0) return;
            
            // Get the width of one item plus the gap
            const itemWidth = items[0].offsetWidth;
            const gap = 16; // 1rem = 16px
            
            // On mobile (<=700px), scroll 1 item at a time; on desktop, scroll 3
            const isMobile = window.innerWidth <= 700;
            const itemsToScroll = isMobile ? 1 : 3;
            
            const scrollAmount = (itemWidth + gap) * itemsToScroll;
            container.scrollBy({ left: direction * scrollAmount, behavior: 'smooth' });
        }
        
        function scrollTransactionsTicker(direction) {
            const container = document.getElementById('home-transactions-list');
            const scrollAmount = 320;
            container.scrollBy({ left: direction * scrollAmount, behavior: 'smooth' });
        }
        
        async function loadHomepageData() {
            if (homepageDataLoaded) return;
            
            try {
                // Load teams data
                const teamsResponse = await fetch('data/current_season/teams.json');
                if (teamsResponse.ok) {
                    homeTeamsData = await teamsResponse.json();
                }
                
                // Load standings
                const standingsResponse = await fetch('data/current_season/standings.json');
                if (standingsResponse.ok) {
                    homeStandingsData = await standingsResponse.json();
                }
                
                // Load transactions
                const transResponse = await fetch('data/current_season/transactions.json');
                if (transResponse.ok) {
                    homeTransactionsData = await transResponse.json();
                }
                
                // Load all scores for matchup ticker - try all_scores.json first, then individual week files
                homeScoresData = [];
                try {
                    const scoresResponse = await fetch('data/current_season/all_scores.json');
                    if (scoresResponse.ok) {
                        homeScoresData = await scoresResponse.json();
                    }
                } catch (e) {
                    console.log('No all_scores.json');
                }
                
                // If all_scores is empty or incomplete, load individual week files
                const weeksInScores = new Set(homeScoresData.map(s => s.week));
                if (weeksInScores.size < 21) {
                    const weekPromises = [];
                    for (let week = 1; week <= 24; week++) {
                        if (!weeksInScores.has(week)) {
                            weekPromises.push(
                                fetch(`data/current_season/week_${week}_scores.json`)
                                    .then(r => r.ok ? r.json() : [])
                                    .catch(() => [])
                            );
                        }
                    }
                    const weekResults = await Promise.all(weekPromises);
                    weekResults.forEach(weekData => {
                        if (weekData && weekData.length > 0) {
                            homeScoresData = homeScoresData.concat(weekData);
                        }
                    });
                }
                
                // Load player data for top players (use most recent historical data if no current season)
                try {
                    const playersResponse = await fetch('data/historical/2025/all_players.json');
                    if (playersResponse.ok) {
                        homePlayersData = await playersResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load player data for homepage');
                }
                
                homepageDataLoaded = true;
                
                // Render all homepage components
                renderMatchupTicker();
                renderHomeStandings();
                renderHomeTopTeams();
                renderHomeTopPlayers();
                renderHomeTransactions();
                
                // Load top scoring day for Green Monster ticker
                loadTopScoringDay();
                
            } catch (e) {
                console.log('Error loading homepage data:', e);
            }
        }
        
        // Store current matchups data for popup
        let currentMatchupsData = [];
        let currentMatchupWeek = 1;
        
        function renderMatchupTicker() {
            const container = document.getElementById('home-matchup-ticker');
            const weekLabel = document.getElementById('home-matchup-week');
            
            if (!homeScoresData || homeScoresData.length === 0) {
                container.innerHTML = '<div class="homepage-placeholder">No matchups available yet. Season starts soon!</div>';
                return;
            }
            
            // Find the current week - use Week 1 if all scores are 0, otherwise use most recent week with scores
            const weeks = [...new Set(homeScoresData.map(s => s.week))].sort((a, b) => a - b);
            
            // Find the latest week that has actual scores (non-zero)
            let currentWeek = 1;
            for (let i = weeks.length - 1; i >= 0; i--) {
                const weekScores = homeScoresData.filter(s => s.week === weeks[i]);
                const hasScores = weekScores.some(s => (s.points || s.team_score || 0) > 0);
                if (hasScores) {
                    currentWeek = weeks[i];
                    break;
                }
            }
            
            // If no week has scores yet (preseason), show Week 1
            if (currentWeek === 1 || !weeks.includes(currentWeek)) {
                currentWeek = Math.min(...weeks);
            }
            
            currentMatchupWeek = currentWeek;
            weekLabel.textContent = `Week ${currentWeek}`;
            
            // Get matchups for current week (pair up team1 and team2 scores)
            const weekScores = homeScoresData.filter(s => s.week === currentWeek);
            const matchups = [];
            const processed = new Set();
            
            for (const score of weekScores) {
                const matchupKey = [score.team_key, score.opponent_key].sort().join('-');
                if (processed.has(matchupKey)) continue;
                processed.add(matchupKey);
                
                const opponentScore = weekScores.find(s => s.team_key === score.opponent_key);
                
                const team1 = homeTeamsData.find(t => t.team_key === score.team_key) || {};
                const team2 = homeTeamsData.find(t => t.team_key === score.opponent_key) || {};
                
                // Normalize manager names
                const manager1 = normalizeManagerName(team1.manager || score.manager || '', 2026, team1.team_name, score.team_key);
                const manager2 = normalizeManagerName(team2.manager || opponentScore?.manager || '', 2026, team2.team_name, score.opponent_key);
                
                // Get score - handle different field names
                const team1Score = score.points || score.team_score || 0;
                const team2Score = opponentScore?.points || opponentScore?.team_score || score.opponent_score || 0;
                
                matchups.push({
                    team1: {
                        name: team1.team_name || score.team_name || 'Team 1',
                        manager: manager1,
                        logo: fixTeamLogo(team1.team_logo) || 'league_logo.png',
                        score: team1Score,
                        team_key: score.team_key
                    },
                    team2: {
                        name: team2.team_name || (opponentScore?.team_name) || 'Team 2',
                        manager: manager2,
                        logo: fixTeamLogo(team2.team_logo) || 'league_logo.png',
                        score: team2Score,
                        team_key: score.opponent_key
                    },
                    week: currentWeek
                });
            }
            
            // Store for popup use
            currentMatchupsData = matchups;
            
            if (matchups.length === 0) {
                container.innerHTML = '<div class="homepage-placeholder">No matchups available yet.</div>';
                return;
            }
            
            container.innerHTML = matchups.map((m, idx) => {
                const team1Winner = m.team1.score > m.team2.score;
                const team2Winner = m.team2.score > m.team1.score;
                
                return `
                    <div class="matchup-ticker-item" onclick="openMatchupPopup(${idx})">
                        <div class="matchup-team">
                            <img src="${m.team1.logo}" class="matchup-team-logo" alt="${m.team1.name}" onerror="this.src='league_logo.png'">
                            <div class="matchup-team-name">${m.team1.name}</div>
                            <div class="matchup-team-manager">${capitalizeManagerName(m.team1.manager)}</div>
                        </div>
                        <div class="matchup-score-box">
                            <div class="matchup-score ${team1Winner ? 'winner' : ''}">${m.team1.score.toFixed(1)}</div>
                            <div class="matchup-vs">vs</div>
                            <div class="matchup-score ${team2Winner ? 'winner' : ''}">${m.team2.score.toFixed(1)}</div>
                        </div>
                        <div class="matchup-team">
                            <img src="${m.team2.logo}" class="matchup-team-logo" alt="${m.team2.name}" onerror="this.src='league_logo.png'">
                            <div class="matchup-team-name">${m.team2.name}</div>
                            <div class="matchup-team-manager">${capitalizeManagerName(m.team2.manager)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Matchup Popup Functions
        async function openMatchupPopup(matchupIdx) {
            const matchup = currentMatchupsData[matchupIdx];
            if (!matchup) return;
            
            const overlay = document.getElementById('matchup-popup-overlay');
            const weekSpan = document.getElementById('matchup-popup-week');
            const scoreboard = document.getElementById('matchup-popup-scoreboard');
            const body = document.getElementById('matchup-popup-body');
            
            weekSpan.textContent = matchup.week;
            
            const team1Winner = matchup.team1.score > matchup.team2.score;
            const team2Winner = matchup.team2.score > matchup.team1.score;
            
            // Render scoreboard
            scoreboard.innerHTML = `
                <div class="matchup-popup-team ${team1Winner ? 'winner' : ''}">
                    <img src="${matchup.team1.logo}" class="matchup-popup-team-logo" alt="" onerror="this.src='league_logo.png'">
                    <div class="matchup-popup-team-name">${matchup.team1.name}</div>
                    <div class="matchup-popup-team-manager">${capitalizeManagerName(matchup.team1.manager)}</div>
                    <div class="matchup-popup-team-score">${matchup.team1.score.toFixed(1)}</div>
                </div>
                <div class="matchup-popup-vs">VS</div>
                <div class="matchup-popup-team ${team2Winner ? 'winner' : ''}">
                    <img src="${matchup.team2.logo}" class="matchup-popup-team-logo" alt="" onerror="this.src='league_logo.png'">
                    <div class="matchup-popup-team-name">${matchup.team2.name}</div>
                    <div class="matchup-popup-team-manager">${capitalizeManagerName(matchup.team2.manager)}</div>
                    <div class="matchup-popup-team-score">${matchup.team2.score.toFixed(1)}</div>
                </div>
            `;
            
            // Load player and transaction data for this week
            body.innerHTML = '<div style="text-align: center; padding: 2rem; grid-column: 1/-1;">Loading player data...</div>';
            overlay.classList.add('active');
            
            try {
                // Load roster data for the week
                const rosterData = await loadWeekRosterData(matchup.week);
                const transactionData = await loadWeekTransactionData(matchup.week);
                
                // Render both team sections
                body.innerHTML = `
                    <div class="matchup-popup-team-section">
                        ${renderTeamPopupSection(matchup.team1, rosterData, transactionData)}
                    </div>
                    <div class="matchup-popup-team-section">
                        ${renderTeamPopupSection(matchup.team2, rosterData, transactionData)}
                    </div>
                `;
            } catch (e) {
                console.log('Error loading popup data:', e);
                body.innerHTML = `
                    <div class="matchup-popup-team-section">
                        ${renderTeamPopupSectionBasic(matchup.team1)}
                    </div>
                    <div class="matchup-popup-team-section">
                        ${renderTeamPopupSectionBasic(matchup.team2)}
                    </div>
                `;
            }
        }
        
        function closeMatchupPopup(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('matchup-popup-overlay').classList.remove('active');
        }
        
        async function loadWeekRosterData(week) {
            try {
                const response = await fetch(`data/current_season/week_${week}_rosters.json`);
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.log('Could not load roster data for week', week);
            }
            return null;
        }
        
        async function loadWeekTransactionData(week) {
            try {
                // Use the transactions we already have loaded
                if (homeTransactionsData && homeTransactionsData.length > 0) {
                    // Filter to adds from the current week
                    // Transactions have a timestamp, need to determine if it falls within the week
                    return homeTransactionsData.filter(t => t.type === 'add' || t.type === 'add/drop');
                }
            } catch (e) {
                console.log('Error processing transaction data');
            }
            return [];
        }
        
        function renderTeamPopupSection(team, rosterData, transactionData) {
            // Get roster for this team
            let teamRoster = [];
            if (rosterData) {
                teamRoster = rosterData.filter(p => p.team_key === team.team_key);
            }
            
            // Sort by fantasy points and split by position type
            const batters = teamRoster.filter(p => !['SP', 'RP', 'P'].includes(p.selected_position)).sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            const pitchers = teamRoster.filter(p => ['SP', 'RP', 'P'].includes(p.selected_position)).sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            
            // Get adds for this team this week
            const teamAdds = transactionData ? transactionData.filter(t => {
                // Check if this transaction involves this team
                const players = t.players || [];
                return players.some(p => p.destination_team_key === team.team_key && p.type === 'add');
            }) : [];
            
            // Count streams (SP adds) and regular adds
            let streamCount = 0;
            let regularAddCount = 0;
            const addedPlayers = [];
            
            teamAdds.forEach(t => {
                const players = t.players || [];
                players.forEach(p => {
                    if (p.destination_team_key === team.team_key && p.type === 'add') {
                        const pos = p.position || '';
                        if (pos === 'SP') {
                            streamCount++;
                        } else {
                            regularAddCount++;
                        }
                        addedPlayers.push({
                            name: p.name,
                            position: pos,
                            points: 0 // Would need to look up from roster
                        });
                    }
                });
            });
            
            // Cap at max values
            streamCount = Math.min(streamCount, 3);
            regularAddCount = Math.min(regularAddCount, 2);
            
            // Calculate points from added players
            let addedPoints = 0;
            addedPlayers.forEach(ap => {
                const rosterPlayer = teamRoster.find(r => r.name === ap.name);
                if (rosterPlayer) {
                    ap.points = rosterPlayer.fantasy_points || 0;
                    addedPoints += ap.points;
                }
            });
            
            return `
                <div class="matchup-popup-section-header">
                    <span class="matchup-popup-section-title">${team.name}</span>
                    <div class="add-tracker">
                        <div class="add-tracker-group">
                            <span class="add-tracker-label">Streams:</span>
                            ${[0, 1, 2].map(i => `<div class="add-dot stream ${i < streamCount ? 'used' : ''}"></div>`).join('')}
                        </div>
                        <div class="add-tracker-group">
                            <span class="add-tracker-label">Adds:</span>
                            ${[0, 1].map(i => `<div class="add-dot regular ${i < regularAddCount ? 'used' : ''}"></div>`).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="matchup-popup-players-section">
                    <div class="matchup-popup-players-title">Top 5 Batters</div>
                    ${batters.slice(0, 5).map(p => renderPopupPlayer(p)).join('') || '<div style="color:#999;font-size:0.75rem;">No data available</div>'}
                </div>
                
                <div class="matchup-popup-players-section">
                    <div class="matchup-popup-players-title">Top 5 Pitchers</div>
                    ${pitchers.slice(0, 5).map(p => renderPopupPlayer(p)).join('') || '<div style="color:#999;font-size:0.75rem;">No data available</div>'}
                </div>
                
                ${addedPlayers.length > 0 ? `
                <div class="matchup-popup-adds-section">
                    <div class="matchup-popup-adds-header">
                        <span class="matchup-popup-adds-title">Weekly Adds</span>
                        <span class="matchup-popup-adds-total">+${addedPoints.toFixed(1)} pts</span>
                    </div>
                    ${addedPlayers.map(p => `
                        <div class="matchup-popup-add-item">
                            <span class="add-indicator">+</span>
                            <span class="matchup-popup-player-pos ${p.position}">${p.position}</span>
                            <span>${p.name}</span>
                            <span style="margin-left:auto;font-weight:600;">${p.points.toFixed(1)}</span>
                        </div>
                    `).join('')}
                </div>
                ` : ''}
            `;
        }
        
        function renderTeamPopupSectionBasic(team) {
            return `
                <div class="matchup-popup-section-header">
                    <span class="matchup-popup-section-title">${team.name}</span>
                    <div class="add-tracker">
                        <div class="add-tracker-group">
                            <span class="add-tracker-label">Streams:</span>
                            ${[0, 1, 2].map(() => `<div class="add-dot stream"></div>`).join('')}
                        </div>
                        <div class="add-tracker-group">
                            <span class="add-tracker-label">Adds:</span>
                            ${[0, 1].map(() => `<div class="add-dot regular"></div>`).join('')}
                        </div>
                    </div>
                </div>
                
                <div class="matchup-popup-players-section">
                    <div class="matchup-popup-players-title">Top 5 Batters</div>
                    <div style="color:#999;font-size:0.75rem;padding:0.5rem 0;">Roster data not available</div>
                </div>
                
                <div class="matchup-popup-players-section">
                    <div class="matchup-popup-players-title">Top 5 Pitchers</div>
                    <div style="color:#999;font-size:0.75rem;padding:0.5rem 0;">Roster data not available</div>
                </div>
            `;
        }
        
        function renderPopupPlayer(player) {
            const pos = player.selected_position || player.position || '?';
            const headshot = player.headshot_url || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><rect fill="%23e0e0e0" width="100" height="100"/></svg>';
            const points = player.fantasy_points || 0;
            
            return `
                <div class="matchup-popup-player">
                    <img src="${headshot}" class="matchup-popup-player-headshot" alt="" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23e0e0e0%22 width=%22100%22 height=%22100%22/></svg>'">
                    <span class="matchup-popup-player-pos ${pos}">${pos}</span>
                    <span class="matchup-popup-player-name">${player.name}</span>
                    <span class="matchup-popup-player-pts">${points.toFixed(1)}</span>
                </div>
            `;
        }
        
        // Green Monster Top Scoring Day
        async function loadTopScoringDay() {
            try {
                // Load the top scoring day record (single record, not daily history)
                const response = await fetch('data/current_season/top_scoring_day.json');
                if (!response.ok) return;
                
                const topDay = await response.json();
                if (!topDay || !topDay.score || topDay.score === 0) return;
                
                // Find team logo
                const team = homeTeamsData.find(t => t.team_key === topDay.team_key);
                const logo = team ? fixTeamLogo(team.team_logo) : 'league_logo.png';
                
                // Format date with leading zeros (MM/DD)
                let month = '00';
                let day = '00';
                if (topDay.date) {
                    if (topDay.date.includes('-')) {
                        const date = new Date(topDay.date);
                        month = String(date.getMonth() + 1).padStart(2, '0');
                        day = String(date.getDate()).padStart(2, '0');
                    } else if (topDay.date.includes('/')) {
                        const parts = topDay.date.split('/');
                        month = parts[0].padStart(2, '0');
                        day = parts[1].padStart(2, '0');
                    }
                }
                
                // Format score with 2 decimal places and leading zeros (XXX.XX format)
                const scoreStr = topDay.score.toFixed(2).padStart(6, '0');
                
                // Build date digits HTML - MM/DD aligned with score
                const dateHtml = renderMonsterDate(month, day);
                
                // Build score digits HTML - each digit gets its own tile
                const scoreHtml = renderMonsterScore(scoreStr);
                
                // Update display
                document.getElementById('green-monster-logo').src = logo;
                document.getElementById('green-monster-date').innerHTML = dateHtml;
                document.getElementById('green-monster-score').innerHTML = scoreHtml;
                document.getElementById('green-monster-ticker').style.display = 'flex';
            } catch (e) {
                console.log('Could not load top scoring day data');
            }
        }
        
        function renderMonsterDate(month, day) {
            // Format: [M][M] [/] [D][D] - aligns with score XXX.XX
            return month.split('').map(char => 
                `<span class="monster-digit date-digit">${char}</span>`
            ).join('') +
            `<span class="monster-digit date-separator">/</span>` +
            day.split('').map(char => 
                `<span class="monster-digit date-digit">${char}</span>`
            ).join('');
        }
        
        function renderMonsterScore(scoreStr) {
            return scoreStr.split('').map(char => {
                if (char === '.') {
                    return `<span class="monster-digit decimal">.</span>`;
                }
                return `<span class="monster-digit score-digit">${char}</span>`;
            }).join('');
        }
        
        function renderHomeStandings() {
            const tbody = document.getElementById('home-standings-body');
            
            if (!homeStandingsData || homeStandingsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" class="homepage-placeholder">Standings will appear once the season starts.</td></tr>';
                return;
            }
            
            // Sort by rank
            const sorted = [...homeStandingsData].sort((a, b) => (a.rank || 999) - (b.rank || 999));
            
            tbody.innerHTML = sorted.map((team, idx) => {
                // Use normalizeManagerName to handle Josh B and Logan S
                const rawManager = team.manager || '';
                const manager = normalizeManagerName(rawManager, 2026, team.team_name, team.team_key);
                const hatFilename = getManagerHatFilename(manager);
                const rank = team.rank || (idx + 1);
                const record = `${team.wins || 0}-${team.losses || 0}`;
                const rankClass = rank === 1 ? 'gold' : rank === 2 ? 'silver' : rank === 3 ? 'bronze' : '';
                const teamKey = team.team_key || '';
                
                return `
                    <tr>
                        <td>
                            <div class="mini-standings-team" style="cursor: pointer;" onclick="openRosterModal('${teamKey}')">
                                <span class="mini-standings-rank ${rankClass}">${rank}</span>
                                <img src="data/hats/${hatFilename}" class="mini-standings-hat" alt="${manager}" onerror="this.style.display='none'">
                                <span class="mini-standings-manager">${capitalizeManagerName(manager)}</span>
                            </div>
                        </td>
                        <td>${record}</td>
                        <td>${(team.points_for || 0).toFixed(0)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function renderHomeTopTeams() {
            const tbody = document.getElementById('home-top-teams-body');
            const dateSpan = document.getElementById('home-top-teams-date');
            
            // Set the date to yesterday (or today if no data)
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const dateStr = `${yesterday.getMonth() + 1}/${yesterday.getDate()}`;
            if (dateSpan) dateSpan.textContent = dateStr;
            
            // For now, use standings data sorted by points_for as proxy for "top teams"
            // In-season this would be daily/weekly team scores
            if (!homeStandingsData || homeStandingsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" class="homepage-placeholder">Top teams will appear once the season starts.</td></tr>';
                return;
            }
            
            // Sort by points_for (highest first)
            const sorted = [...homeStandingsData].sort((a, b) => (b.points_for || 0) - (a.points_for || 0));
            
            tbody.innerHTML = sorted.map((team, idx) => {
                const teamData = homeTeamsData.find(t => t.team_key === team.team_key) || {};
                const logo = fixTeamLogo(teamData.team_logo) || 'league_logo.png';
                const rawManager = team.manager || teamData.manager || '';
                const manager = normalizeManagerName(rawManager, 2026, team.team_name, team.team_key);
                
                return `
                    <tr>
                        <td>
                            <div class="top-teams-team">
                                <span class="top-teams-rank">${idx + 1}</span>
                                <img src="${logo}" class="top-teams-logo" alt="" onerror="this.src='league_logo.png'">
                                <div class="top-teams-info">
                                    <div class="top-teams-name">${team.team_name || 'Unknown'}</div>
                                    <div class="top-teams-manager">${capitalizeManagerName(manager)}</div>
                                </div>
                            </div>
                        </td>
                        <td>${(team.points_for || 0).toFixed(0)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function renderHomeTopPlayers() {
            const tbody = document.getElementById('home-top-players-body');
            
            // If we have actual player data (season has started), show top scorers
            if (homePlayersData && homePlayersData.length > 0) {
                // Sort by total points and take top 12
                const sorted = [...homePlayersData].sort((a, b) => (b.total_points || 0) - (a.total_points || 0)).slice(0, 12);
                
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
                
                tbody.innerHTML = sorted.map((player, idx) => {
                    const headshot = player.headshot_url || placeholderImg;
                    const rankClass = idx === 0 ? 'gold' : idx === 1 ? 'silver' : idx === 2 ? 'bronze' : '';
                    const teamName = player.team_name || 'FA';
                    const manager = player.manager ? capitalizeManagerName(player.manager) : '';
                    
                    return `
                        <tr>
                            <td>
                                <div class="top-players-player">
                                    <span class="top-players-rank ${rankClass}">${idx + 1}</span>
                                    <img src="${headshot}" class="top-players-headshot" alt="" onerror="this.src='${placeholderImg}'">
                                    <div class="top-players-info">
                                        <div class="top-players-name">${player.name || 'Unknown'}</div>
                                        <div class="top-players-team">${teamName}${manager ? ` - ${manager}` : ''}</div>
                                    </div>
                                </div>
                            </td>
                            <td>${(player.total_points || 0).toFixed(0)}</td>
                        </tr>
                    `;
                }).join('');
                return;
            }
            
            // Preseason: Load and show top projected player at each position from ATC
            loadProjectedTopPlayers(tbody);
        }
        
        async function loadProjectedTopPlayers(tbody) {
            tbody.innerHTML = '<tr><td colspan="2" class="homepage-placeholder">Loading projections...</td></tr>';
            
            try {
                const response = await fetch('data/projections/projections_atc.json');
                if (!response.ok) throw new Error('Could not load projections');
                
                const data = await response.json();
                const batters = data.batters || [];
                const pitchers = data.pitchers || [];
                
                console.log('Loaded projections - batters:', batters.length, 'pitchers:', pitchers.length);
                if (batters.length > 0) {
                    console.log('Sample batter positions:', batters.slice(0, 10).map(b => b.position));
                }
                
                // Positions to show (one player each)
                const positions = ['C', '1B', '2B', '3B', 'SS', 'OF', 'SP', 'RP'];
                const topByPosition = [];
                
                for (const pos of positions) {
                    let candidates;
                    if (pos === 'SP' || pos === 'RP') {
                        candidates = pitchers.filter(p => p.position === pos);
                    } else if (pos === 'OF') {
                        // OF can be OF, LF, CF, RF, or contain OF
                        candidates = batters.filter(p => {
                            const playerPos = (p.position || '').toUpperCase();
                            return playerPos === 'OF' || playerPos === 'LF' || playerPos === 'CF' || playerPos === 'RF' || playerPos.includes('OF');
                        });
                    } else {
                        // Match position exactly or check if it's included (e.g., "1B/DH" contains "1B")
                        candidates = batters.filter(p => {
                            const playerPos = (p.position || '').toUpperCase();
                            return playerPos === pos || playerPos.includes(pos);
                        });
                    }
                    
                    console.log(`Position ${pos}: found ${candidates.length} candidates`);
                    
                    // Sort by projected points and take the top one
                    candidates.sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));
                    if (candidates.length > 0) {
                        topByPosition.push({ ...candidates[0], display_position: pos });
                    }
                }
                
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
                
                tbody.innerHTML = topByPosition.map(player => {
                    const headshot = player.headshot_url || placeholderImg;
                    const pos = player.display_position;
                    const mlbTeam = player.mlb_team || player.team || player.Team || '';
                    const mlbLogoUrl = mlbTeam ? getMLBTeamLogo(mlbTeam) : '';
                    const mlbTeamDisplay = mlbTeam ? formatMLBTeamDisplay(mlbTeam) : '';
                    
                    return `
                        <tr>
                            <td>
                                <div class="top-players-player">
                                    <span class="position-badge pos-${pos}">${pos}</span>
                                    <img src="${headshot}" class="top-players-headshot" alt="" onerror="this.src='${placeholderImg}'">
                                    <div class="top-players-info">
                                        <div class="top-players-name">${player.name || 'Unknown'}</div>
                                        <div class="top-players-mlb-team">
                                            ${mlbLogoUrl ? `<img src="${mlbLogoUrl}" class="top-players-mlb-logo" alt="${mlbTeamDisplay}" onerror="this.style.display='none'">` : ''}
                                            <span>${mlbTeamDisplay}</span>
                                        </div>
                                    </div>
                                </div>
                            </td>
                            <td class="projected-pts">${(player.projected_points || 0).toFixed(0)}*</td>
                        </tr>
                    `;
                }).join('');
                
            } catch (e) {
                console.log('Error loading projected top players:', e);
                tbody.innerHTML = '<tr><td colspan="2" class="homepage-placeholder">Top players will appear once the season starts.</td></tr>';
            }
        }
        
        function renderHomeTransactions() {
            const container = document.getElementById('home-transactions-list');
            
            if (!homeTransactionsData || homeTransactionsData.length === 0) {
                container.innerHTML = '<div class="homepage-placeholder">No transactions yet this season.</div>';
                return;
            }
            
            // Show most recent 15 transactions for horizontal scroll
            const recent = homeTransactionsData.slice(0, 15);
            
            container.innerHTML = recent.map(trans => {
                const type = trans.type || 'add';
                const timestamp = trans.timestamp ? new Date(trans.timestamp * 1000) : new Date();
                const timeAgo = getTimeAgo(timestamp);
                
                let icon = '+';
                let typeClass = 'trans-add';
                let description = '';
                
                if (type === 'add') {
                    icon = '+';
                    typeClass = 'trans-add';
                    const player = trans.players?.[0];
                    description = `<span class="transaction-player">${player?.player_name || 'Unknown'}</span> added by ${player?.destination_team_name || 'Unknown'}`;
                } else if (type === 'drop') {
                    icon = '';
                    typeClass = 'trans-drop';
                    const player = trans.players?.[0];
                    description = `<span class="transaction-player">${player?.player_name || 'Unknown'}</span> dropped by ${player?.source_team_name || 'Unknown'}`;
                } else if (type === 'add/drop') {
                    icon = '';
                    typeClass = 'trans-add-drop';
                    const addPlayer = trans.players?.find(p => p.transaction_type === 'add');
                    const dropPlayer = trans.players?.find(p => p.transaction_type === 'drop');
                    description = `<span class="transaction-player">${addPlayer?.player_name || 'Unknown'}</span> added, ${dropPlayer?.player_name || 'Unknown'} dropped`;
                } else if (type === 'trade') {
                    icon = '';
                    typeClass = 'trans-trade';
                    const teams = new Set();
                    trans.players?.forEach(p => {
                        if (p.source_team_name) teams.add(p.source_team_name);
                        if (p.destination_team_name) teams.add(p.destination_team_name);
                    });
                    const teamNames = [...teams].slice(0, 2);
                    const playerCount = trans.players?.length || 0;
                    description = `Trade: ${playerCount} player${playerCount !== 1 ? 's' : ''} between ${teamNames.join(' & ')}`;
                }
                
                return `
                    <div class="transaction-item ${typeClass}">
                        <div class="transaction-icon">${icon}</div>
                        <div class="transaction-content">
                            <div class="transaction-details">${description}</div>
                        </div>
                        <div class="transaction-time">${timeAgo}</div>
                    </div>
                `;
            }).join('');
        }
        
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // ===== ROSTER MODAL FUNCTIONS =====
        
        function getPositionBadgeClass(position) {
            if (!position) return 'pos-util';
            const pos = position.toUpperCase();
            if (pos === 'C') return 'pos-c';
            if (pos === '1B') return 'pos-1b';
            if (pos === '2B') return 'pos-2b';
            if (pos === '3B') return 'pos-3b';
            if (pos === 'SS') return 'pos-ss';
            if (pos === 'OF' || pos === 'LF' || pos === 'CF' || pos === 'RF') return 'pos-of';
            if (pos === 'DH' || pos === 'UTIL') return 'pos-util';
            if (pos === 'SP') return 'pos-sp';
            if (pos === 'RP') return 'pos-rp';
            if (pos === 'P') return 'pos-sp';
            if (pos === 'BN') return 'pos-util';
            return 'pos-util';
        }
        
        // 2026 Roster positions (4 UTIL, 4 BN)
        const ROSTER_BATTER_SLOTS = [
            { pos: 'C', label: 'Catcher', count: 1 },
            { pos: '1B', label: 'First Base', count: 1 },
            { pos: '2B', label: 'Second Base', count: 1 },
            { pos: '3B', label: 'Third Base', count: 1 },
            { pos: 'SS', label: 'Shortstop', count: 1 },
            { pos: 'OF', label: 'Outfield', count: 3 },
            { pos: 'Util', label: 'Utility', count: 4 }
        ];
        
        const ROSTER_PITCHER_SLOTS = [
            { pos: 'SP', label: 'Starting Pitcher', count: 3 },
            { pos: 'RP', label: 'Relief Pitcher', count: 1 },
            { pos: 'P', label: 'Pitcher', count: 2 },
            { pos: 'BN', label: 'Bench', count: 4 }
        ];
        
        async function loadRostersData() {
            if (homeRostersData) return homeRostersData;
            
            try {
                const response = await fetch('data/current_season/rosters.json');
                if (response.ok) {
                    homeRostersData = await response.json();
                    return homeRostersData;
                }
            } catch (e) {
                console.log('Could not load rosters data');
            }
            return null;
        }
        
        async function openRosterModal(teamKey) {
            // Load rosters data if not already loaded
            const rostersData = await loadRostersData();
            
            // Find team data from various sources
            let teamRoster = rostersData?.teams?.[teamKey];
            const teamData = homeTeamsData.find(t => t.team_key === teamKey) || {};
            const standingsData = homeStandingsData.find(t => t.team_key === teamKey) || {};
            
            // Get team info
            const rawManager = teamData.manager || standingsData.manager || '';
            const manager = normalizeManagerName(rawManager, 2026, teamData.team_name || standingsData.team_name, teamKey);
            const teamName = teamData.team_name || standingsData.team_name || 'Unknown Team';
            const teamLogo = fixTeamLogo(teamData.team_logo) || '';
            
            // Update header
            document.getElementById('roster-modal-logo').src = teamLogo;
            document.getElementById('roster-modal-team-name').textContent = teamName;
            document.getElementById('roster-modal-manager').textContent = capitalizeManagerName(manager);
            
            // Get players from roster or fall back to keepers
            let players = teamRoster?.players || [];
            
            // If no roster data, try to show keepers as placeholders
            if (players.length === 0) {
                players = await getKeeperPlayersForTeam(teamKey, manager);
            }
            
            // Build roster display
            const bodyEl = document.getElementById('roster-modal-body');
            bodyEl.innerHTML = buildRosterModalContent(players, teamKey);
            
            // Show modal
            document.getElementById('roster-modal-overlay').classList.add('active');
            document.body.classList.add('modal-open');
        }
        
        async function getKeeperPlayersForTeam(teamKey, manager) {
            const keeperPlayers = [];
            
            try {
                // First, try to load ATC projection data for headshots
                let projBatters = [];
                let projPitchers = [];
                
                // Check if projections are already loaded (from preseason tools)
                if (typeof allProjectionBatters !== 'undefined' && allProjectionBatters.length > 0) {
                    projBatters = allProjectionBatters;
                    projPitchers = allProjectionPitchers || [];
                } else {
                    // Load ATC projections for headshots
                    try {
                        const projResponse = await fetch('data/projections/projections_atc.json');
                        if (projResponse.ok) {
                            const projData = await projResponse.json();
                            projBatters = projData.batters || [];
                            projPitchers = projData.pitchers || [];
                        }
                    } catch (e) {
                        console.log('Could not load ATC projections for roster modal');
                    }
                }
                
                const allProj = [...projBatters, ...projPitchers];
                
                // Initialize Firebase if not already done
                if (typeof firebase !== 'undefined' && !firebaseInitialized) {
                    try {
                        if (typeof firebaseConfig !== 'undefined') {
                            firebaseApp = firebase.initializeApp(firebaseConfig);
                            firebaseDb = firebase.database();
                            firebaseInitialized = true;
                            console.log('Firebase initialized for roster modal');
                        }
                    } catch (e) {
                        // Firebase might already be initialized
                        if (e.code === 'app/duplicate-app') {
                            firebaseDb = firebase.database();
                            firebaseInitialized = true;
                        } else {
                            console.log('Firebase init error:', e);
                        }
                    }
                }
                
                // Try to get keepers from Firebase - match by manager name since team_keys changed between seasons
                if (typeof firebaseDb !== 'undefined' && firebaseDb) {
                    console.log('Fetching all keepers from Firebase for manager:', manager);
                    const snapshot = await firebaseDb.ref('keepers_2026').once('value');
                    const allKeepersData = snapshot.val();
                    console.log('Firebase all keepers data:', allKeepersData);
                    
                    if (allKeepersData) {
                        // Find the team's keepers by matching manager name
                        // The keys are sanitized 2025 team_keys, but we need to find by manager
                        let teamKeepers = null;
                        
                        // First, try to load keeper_config to map team_keys to managers
                        let keeperConfigData = null;
                        try {
                            const configResponse = await fetch('data/keepers/keeper_config.json');
                            if (configResponse.ok) {
                                keeperConfigData = await configResponse.json();
                            }
                        } catch (e) {
                            console.log('Could not load keeper_config.json');
                        }
                        
                        // Normalize the manager name for comparison
                        const normalizedManager = manager.toLowerCase().trim();
                        
                        // Search through all keepers entries
                        for (const [sanitizedKey, keepers] of Object.entries(allKeepersData)) {
                            // Convert sanitized key back to original format
                            const originalKey = unsanitizeFirebaseKey(sanitizedKey);
                            
                            // Try to find manager name from keeper_config
                            let entryManager = null;
                            if (keeperConfigData?.teams?.[originalKey]) {
                                entryManager = keeperConfigData.teams[originalKey].manager;
                            }
                            
                            // Also check if the keepers array has manager info
                            if (!entryManager && keepers && keepers.length > 0 && keepers[0]?.manager) {
                                entryManager = keepers[0].manager;
                            }
                            
                            // Match by manager name (handles Josh/Josh B, Logan/Logan S etc)
                            if (entryManager) {
                                const normalizedEntryManager = entryManager.toLowerCase().trim();
                                // Check for exact match or partial match (e.g., "josh" matches "josh b")
                                if (normalizedEntryManager === normalizedManager ||
                                    normalizedEntryManager.startsWith(normalizedManager.split(' ')[0]) && 
                                    normalizedManager.startsWith(normalizedEntryManager.split(' ')[0])) {
                                    teamKeepers = keepers;
                                    console.log('Found keepers for manager:', manager, 'via config key:', originalKey);
                                    break;
                                }
                            }
                        }
                        
                        if (teamKeepers) {
                            // Convert to array if needed
                            const keepersArray = Array.isArray(teamKeepers) ? teamKeepers : Object.values(teamKeepers);
                            
                            for (const keeper of keepersArray) {
                                if (!keeper || !keeper.player_name) continue;
                                
                                // Find projection data for headshot, position, and MLB team
                                const projData = allProj.find(p => 
                                    p.name && keeper.player_name &&
                                    p.name.toLowerCase().trim() === keeper.player_name.toLowerCase().trim()
                                );
                                
                                // Debug logging
                                if (projData) {
                                    console.log('Found projection for', keeper.player_name, '- mlb_team:', projData.mlb_team, '- team:', projData.team, '- Team:', projData.Team);
                                } else {
                                    console.log('No projection found for', keeper.player_name);
                                }
                                
                                const position = keeper.position || projData?.position || '';
                                const isPitcher = ['SP', 'RP', 'P'].includes(position);
                                const projectedPoints = projData?.projected_points || 0;
                                // Try multiple possible field names for MLB team
                                const mlbTeam = projData?.mlb_team || projData?.team || projData?.Team || '';
                                
                                keeperPlayers.push({
                                    name: keeper.player_name,
                                    primary_position: position,
                                    position_type: isPitcher ? 'P' : 'B',
                                    eligible_positions: [position],
                                    headshot_url: projData?.headshot_url || '',
                                    mlb_team: mlbTeam,
                                    acquisition_type: 'Keeper',
                                    fantasy_points: 0,  // Actual points (0 until season starts)
                                    projected_points: projectedPoints,  // ATC projected points
                                    position_rank: null,
                                    isKeeper: true,
                                    isProspect: projectedPoints === 0  // Flag prospects
                                });
                            }
                        } else {
                            console.log('No keepers found for manager:', manager);
                        }
                    }
                } else if (typeof keeperSelections !== 'undefined' && keeperSelections && keeperSelections[teamKey]) {
                    // Fall back to in-memory keeperSelections if Firebase isn't available
                    const teamKeepers = keeperSelections[teamKey] || [];
                    for (const keeper of teamKeepers) {
                        if (!keeper || !keeper.player_name) continue;
                        
                        const projData = allProj.find(p => 
                            p.name && keeper.player_name &&
                            p.name.toLowerCase().trim() === keeper.player_name.toLowerCase().trim()
                        );
                        
                        const position = keeper.position || projData?.position || '';
                        const isPitcher = ['SP', 'RP', 'P'].includes(position);
                        const projectedPoints = projData?.projected_points || 0;
                        // Try multiple possible field names for MLB team
                        const mlbTeam = projData?.mlb_team || projData?.team || projData?.Team || '';
                        
                        keeperPlayers.push({
                            name: keeper.player_name,
                            primary_position: position,
                            position_type: isPitcher ? 'P' : 'B',
                            eligible_positions: [position],
                            headshot_url: projData?.headshot_url || '',
                            mlb_team: mlbTeam,
                            acquisition_type: 'Keeper',
                            fantasy_points: 0,
                            projected_points: projectedPoints,
                            position_rank: null,
                            isKeeper: true,
                            isProspect: projectedPoints === 0
                        });
                    }
                } else {
                    console.log('Firebase not available and no keeper selections in memory');
                }
            } catch (e) {
                console.log('Error loading keepers for roster modal:', e);
            }
            
            return keeperPlayers;
        }
        
        function buildRosterModalContent(players, teamKey) {
            // Separate batters and pitchers, excluding prospects
            const batters = players.filter(p => (p.position_type === 'B' || 
                (!p.position_type && !['SP', 'RP', 'P'].includes(p.primary_position))) && !p.isProspect);
            const pitchers = players.filter(p => (p.position_type === 'P' || 
                ['SP', 'RP', 'P'].includes(p.primary_position)) && !p.isProspect);
            
            // Get prospects separately
            const batterProspects = players.filter(p => (p.position_type === 'B' || 
                (!p.position_type && !['SP', 'RP', 'P'].includes(p.primary_position))) && p.isProspect);
            const pitcherProspects = players.filter(p => (p.position_type === 'P' || 
                ['SP', 'RP', 'P'].includes(p.primary_position)) && p.isProspect);
            
            // Sort all groups by projected points (or actual points if available) descending
            const sortByPoints = (a, b) => {
                const aPoints = (a.fantasy_points || 0) > 0 ? a.fantasy_points : (a.projected_points || 0);
                const bPoints = (b.fantasy_points || 0) > 0 ? b.fantasy_points : (b.projected_points || 0);
                return bPoints - aPoints;
            };
            batters.sort(sortByPoints);
            pitchers.sort(sortByPoints);
            batterProspects.sort(sortByPoints);
            pitcherProspects.sort(sortByPoints);
            
            // Placeholder headshot
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
            
            // Build batters section
            let battersHtml = '<div class="roster-section"><div class="roster-section-header"><h4>Batters</h4></div>';
            
            for (const slot of ROSTER_BATTER_SLOTS) {
                battersHtml += `<div class="roster-position-group"><div class="roster-position-label">${slot.label}</div>`;
                
                for (let i = 0; i < slot.count; i++) {
                    // Find a player for this slot (already sorted by points, so will pick best available)
                    const player = findPlayerForSlot(batters, slot.pos, i);
                    
                    if (player) {
                        // Mark player as used
                        player._used = true;
                        battersHtml += buildPlayerRow(player, placeholderImg);
                    } else {
                        battersHtml += buildEmptySlot(slot.pos);
                    }
                }
                battersHtml += '</div>';
            }
            
            // Add batter prospects section if any
            if (batterProspects.length > 0) {
                battersHtml += '<div class="roster-position-group roster-prospects-group"><div class="roster-position-label">Prospects</div>';
                for (const prospect of batterProspects) {
                    battersHtml += buildPlayerRow(prospect, placeholderImg);
                }
                battersHtml += '</div>';
            }
            
            battersHtml += '</div>';
            
            // Build pitchers section (including bench)
            let pitchersHtml = '<div class="roster-section"><div class="roster-section-header"><h4>Pitchers & Bench</h4></div>';
            
            for (const slot of ROSTER_PITCHER_SLOTS) {
                pitchersHtml += `<div class="roster-position-group"><div class="roster-position-label">${slot.label}</div>`;
                
                for (let i = 0; i < slot.count; i++) {
                    let player;
                    if (slot.pos === 'BN') {
                        // Bench slots - use remaining pitchers (already sorted)
                        player = pitchers.find(p => !p._used);
                    } else {
                        player = findPlayerForSlot(pitchers, slot.pos, i);
                    }
                    
                    if (player) {
                        player._used = true;
                        pitchersHtml += buildPlayerRow(player, placeholderImg);
                    } else {
                        pitchersHtml += buildEmptySlot(slot.pos);
                    }
                }
                pitchersHtml += '</div>';
            }
            
            // Add pitcher prospects section if any
            if (pitcherProspects.length > 0) {
                pitchersHtml += '<div class="roster-position-group roster-prospects-group"><div class="roster-position-label">Prospects</div>';
                for (const prospect of pitcherProspects) {
                    pitchersHtml += buildPlayerRow(prospect, placeholderImg);
                }
                pitchersHtml += '</div>';
            }
            
            pitchersHtml += '</div>';
            
            return battersHtml + pitchersHtml;
        }
        
        function findPlayerForSlot(players, position, index) {
            // Find unused players that can fill this position
            const eligible = players.filter(p => {
                if (p._used) return false;
                
                const positions = p.eligible_positions || [p.primary_position];
                const selectedPos = p.selected_position || '';
                
                // Util can be filled by any batter
                if (position === 'Util') return true;
                // P can be filled by SP or RP
                if (position === 'P') return positions.some(pos => ['SP', 'RP', 'P'].includes(pos));
                
                return positions.includes(position) || selectedPos === position;
            });
            
            // Sort by selected_position match first, then by fantasy points
            eligible.sort((a, b) => {
                const aSelected = a.selected_position === position ? 1 : 0;
                const bSelected = b.selected_position === position ? 1 : 0;
                if (bSelected !== aSelected) return bSelected - aSelected;
                return (b.fantasy_points || 0) - (a.fantasy_points || 0);
            });
            
            return eligible[0] || null;
        }
        
        function buildPlayerRow(player, placeholderImg) {
            const headshot = player.headshot_url || placeholderImg;
            const position = player.primary_position || '';
            const actualPoints = player.fantasy_points || 0;
            const projectedPoints = player.projected_points || 0;
            const rank = player.position_rank;
            const isKeeper = player.isKeeper || player.acquisition_type === 'Keeper';
            const mlbTeam = player.mlb_team || '';
            
            // Use actual points if available, otherwise projected points
            const displayPoints = actualPoints > 0 ? actualPoints : projectedPoints;
            const isProjected = actualPoints === 0 && projectedPoints > 0;
            
            // MLB team logo - use helper function for proper abbreviation handling
            const mlbLogoUrl = mlbTeam ? getMLBTeamLogo(mlbTeam) : '';
            const mlbTeamDisplay = mlbTeam ? formatMLBTeamDisplay(mlbTeam) : '';
            
            return `
                <div class="roster-player-row${player.isProspect ? ' prospect' : ''}">
                    <span class="position-badge pos-${position}">${position}</span>
                    <img src="${headshot}" class="roster-player-headshot" alt="" onerror="this.src='${placeholderImg}'">
                    <div class="roster-player-info">
                        <div class="roster-player-name-row">
                            <span class="roster-player-name">${player.name || 'Unknown'}</span>
                            ${isKeeper ? '<span class="keeper-badge">K</span>' : ''}
                        </div>
                        ${mlbTeamDisplay ? `
                        <div class="roster-player-mlb-team">
                            ${mlbLogoUrl ? `<img src="${mlbLogoUrl}" class="roster-mlb-logo" alt="${mlbTeamDisplay}" onerror="this.style.display='none'">` : ''}
                            <span>${mlbTeamDisplay}</span>
                        </div>` : ''}
                    </div>
                    <div class="roster-player-stats">
                        <div class="roster-player-points${isProjected ? ' projected' : ''}">${displayPoints > 0 ? displayPoints.toFixed(1) : '-'}${isProjected ? '*' : ''}</div>
                        ${rank ? `<div class="roster-player-rank">#${rank}</div>` : ''}
                    </div>
                </div>
            `;
        }
        
        function buildEmptySlot(position) {
            return `
                <div class="roster-player-row empty">
                    <span class="position-badge pos-${position}">${position}</span>
                    <div class="roster-player-headshot" style="background: #e0e0e0;"></div>
                    <div class="roster-player-info">
                        <div class="roster-player-name-row">
                            <span class="roster-player-name">Empty Slot</span>
                        </div>
                    </div>
                    <div class="roster-player-stats">
                        <div class="roster-player-points">-</div>
                    </div>
                </div>
            `;
        }
        
        function closeRosterModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('roster-modal-overlay').classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // ===== PROSPECT PAVILION FUNCTIONS =====
        let prospectsData = [];
        let prospectOwnershipData = {};
        
        async function loadProspects() {
            try {
                // Load prospect rankings
                const response = await fetch('data/prospects/prospects.json');
                if (!response.ok) throw new Error('Could not load prospects data');
                
                const data = await response.json();
                prospectsData = data.prospects || [];
                
                // Load ownership data (keepers)
                await loadProspectOwnership();
                
                // Render the table
                renderProspectTable();
                
            } catch (e) {
                console.log('Error loading prospects:', e);
                document.getElementById('prospect-table-body').innerHTML = 
                    '<tr><td colspan="5" class="prospect-loading">Could not load prospect data.</td></tr>';
            }
        }
        
        async function loadProspectOwnership() {
            try {
                // Load from keeper selections in Firebase or local data
                // First try to get 2026 rosters/keepers
                if (typeof firebaseDb !== 'undefined' && firebaseDb) {
                    const snapshot = await firebaseDb.ref('keepers_2026').once('value');
                    const keepersData = snapshot.val();
                    
                    if (keepersData) {
                        // Load keeper config for team info
                        const configResponse = await fetch('data/keepers/keeper_config.json');
                        const keeperConfig = configResponse.ok ? await configResponse.json() : null;
                        
                        // Build ownership map: player name -> owner info
                        for (const [teamKey, keepers] of Object.entries(keepersData)) {
                            const originalKey = unsanitizeFirebaseKey(teamKey);
                            const teamInfo = keeperConfig?.teams?.[originalKey];
                            
                            if (teamInfo && keepers) {
                                const keepersArray = Array.isArray(keepers) ? keepers : Object.values(keepers);
                                for (const keeper of keepersArray) {
                                    if (keeper && keeper.player_name) {
                                        const normalizedName = keeper.player_name.toLowerCase().trim();
                                        prospectOwnershipData[normalizedName] = {
                                            manager: teamInfo.manager,
                                            team_name: teamInfo.team_name,
                                            team_logo: teamInfo.team_logo
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Also check in-memory keeper selections as fallback
                if (typeof keeperSelections !== 'undefined' && keeperSelections) {
                    const configResponse = await fetch('data/keepers/keeper_config.json');
                    const keeperConfig = configResponse.ok ? await configResponse.json() : null;
                    
                    for (const [teamKey, keepers] of Object.entries(keeperSelections)) {
                        const teamInfo = keeperConfig?.teams?.[teamKey];
                        if (teamInfo && keepers) {
                            for (const keeper of keepers) {
                                if (keeper && keeper.player_name) {
                                    const normalizedName = keeper.player_name.toLowerCase().trim();
                                    if (!prospectOwnershipData[normalizedName]) {
                                        prospectOwnershipData[normalizedName] = {
                                            manager: teamInfo.manager,
                                            team_name: teamInfo.team_name,
                                            team_logo: teamInfo.team_logo
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                console.log('Loaded ownership for', Object.keys(prospectOwnershipData).length, 'players');
                
            } catch (e) {
                console.log('Error loading prospect ownership:', e);
            }
        }
        
        function renderProspectTable() {
            const tbody = document.getElementById('prospect-table-body');
            const hideOwned = document.getElementById('hide-owned-prospects').checked;
            const searchTerm = document.getElementById('prospect-search').value.toLowerCase().trim();
            const positionFilter = document.getElementById('prospect-position-filter').value;
            
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
            
            // Filter prospects
            let filtered = prospectsData.filter(prospect => {
                const normalizedName = prospect.name.toLowerCase().trim();
                const isOwned = !!prospectOwnershipData[normalizedName];
                
                // Hide owned filter
                if (hideOwned && isOwned) return false;
                
                // Search filter
                if (searchTerm) {
                    const nameMatch = prospect.name.toLowerCase().includes(searchTerm);
                    const teamMatch = (prospect.mlb_team || '').toLowerCase().includes(searchTerm);
                    if (!nameMatch && !teamMatch) return false;
                }
                
                // Position filter
                if (positionFilter && prospect.position !== positionFilter) return false;
                
                return true;
            });
            
            // Update stats bar
            const totalOwned = prospectsData.filter(p => prospectOwnershipData[p.name.toLowerCase().trim()]).length;
            document.getElementById('prospect-count').textContent = `Showing ${filtered.length} of ${prospectsData.length} prospects`;
            document.getElementById('prospect-owned-count').textContent = `${totalOwned} owned`;
            
            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="prospect-loading">No prospects match your filters.</td></tr>';
                return;
            }
            
            tbody.innerHTML = filtered.map(prospect => {
                const normalizedName = prospect.name.toLowerCase().trim();
                const owner = prospectOwnershipData[normalizedName];
                const isOwned = !!owner;
                
                const headshot = prospect.headshot_url || placeholderImg;
                const mlbTeam = prospect.mlb_team || '';
                const mlbLogoUrl = mlbTeam ? getMLBTeamLogo(mlbTeam) : '';
                
                // Rank styling
                let rankClass = '';
                if (prospect.rank <= 10) rankClass = 'top-10';
                else if (prospect.rank <= 25) rankClass = 'top-25';
                
                // Owner cell
                let ownerHtml = '<span class="prospect-available">Available</span>';
                if (owner) {
                    const ownerLogo = owner.team_logo ? fixTeamLogo(owner.team_logo) : '';
                    ownerHtml = `
                        <div class="prospect-owner-cell">
                            ${ownerLogo ? `<img src="${ownerLogo}" class="prospect-owner-logo" alt="" onerror="this.style.display='none'">` : ''}
                            <span class="prospect-owner-name">${owner.manager}</span>
                        </div>
                    `;
                }
                
                return `
                    <tr class="${isOwned ? 'owned' : ''}">
                        <td class="prospect-col-rank">
                            <span class="prospect-rank ${rankClass}">${prospect.rank}</span>
                        </td>
                        <td class="prospect-col-player">
                            <div class="prospect-player-cell">
                                <img src="${headshot}" class="prospect-headshot" alt="" onerror="this.src='${placeholderImg}'">
                                <div class="prospect-player-info">
                                    <span class="prospect-player-name">${prospect.name}</span>
                                    <div class="prospect-mlb-team">
                                        ${mlbLogoUrl ? `<img src="${mlbLogoUrl}" class="prospect-mlb-logo" alt="${mlbTeam}" onerror="this.style.display='none'">` : ''}
                                        <span>${mlbTeam}</span>
                                    </div>
                                </div>
                            </div>
                        </td>
                        <td class="prospect-col-pos">
                            <span class="position-badge pos-${prospect.position}">${prospect.position}</span>
                        </td>
                        <td class="prospect-col-details">
                            <div class="prospect-details">
                                <div class="prospect-details-row">
                                    <span class="prospect-detail-item">
                                        <span class="prospect-detail-label">Age:</span>
                                        <span class="prospect-detail-value">${prospect.age || '-'}</span>
                                    </span>
                                    <span class="prospect-detail-item">
                                        <span class="prospect-detail-label">Level:</span>
                                        <span class="prospect-detail-value">${prospect.highest_level || '-'}</span>
                                    </span>
                                </div>
                                <div class="prospect-details-row">
                                    <span class="prospect-detail-item">
                                        <span class="prospect-detail-label">B/T:</span>
                                        <span class="prospect-detail-value">${prospect.bats_throws || '-'}</span>
                                    </span>
                                    <span class="prospect-detail-item">
                                        <span class="prospect-detail-label">Draft:</span>
                                        <span class="prospect-detail-value">${prospect.draft || '-'}</span>
                                    </span>
                                </div>
                            </div>
                        </td>
                        <td class="prospect-col-owner">
                            ${ownerHtml}
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        function filterProspects() {
            renderProspectTable();
        }
        
        // Load prospects when section becomes visible
        function initProspectsOnVisible() {
            if (prospectsData.length === 0) {
                loadProspects();
            }
        }

        // ===== INITIALIZE ON PAGE LOAD =====
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize season selectors (detect available seasons)
            await initializeSeasonSelectors();

            // Load current season standings by default
            loadStandingsBySeason();

            // Load manager profiles
            loadManagerProfiles();
            
            // Load homepage data
            loadHomepageData();
            
            // Initialize bylaws scroll spy for TOC highlighting
            initBylawsScrollSpy();
            
            // Initialize side-nav tooltip positioning
            initSideNavTooltips();
        });
        
        // Side-nav tooltip positioning (for fixed tooltips with scrollable nav)
        function initSideNavTooltips() {
            const navItems = document.querySelectorAll('.side-nav-item');
            navItems.forEach(item => {
                const tooltip = item.querySelector('.side-nav-tooltip');
                if (!tooltip) return;
                
                item.addEventListener('mouseenter', () => {
                    const rect = item.getBoundingClientRect();
                    tooltip.style.top = (rect.top + rect.height / 2) + 'px';
                });
            });
        }
        
        // Bylaws scroll spy - highlight active section in TOC
        function initBylawsScrollSpy() {
            const bylawsSections = document.querySelectorAll('.bylaws-section');
            const tocLinks = document.querySelectorAll('.bylaws-toc-list a');
            
            if (bylawsSections.length === 0 || tocLinks.length === 0) return;
            
            // Create intersection observer
            const observerOptions = {
                root: null,
                rootMargin: '-20% 0px -60% 0px',
                threshold: 0
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const sectionId = entry.target.id;
                        
                        // Remove active from all links
                        tocLinks.forEach(link => link.classList.remove('active'));
                        
                        // Add active to matching link
                        const activeLink = document.querySelector(`.bylaws-toc-list a[data-section="${sectionId}"]`);
                        if (activeLink) {
                            activeLink.classList.add('active');
                        }
                    }
                });
            }, observerOptions);
            
            // Observe all sections
            bylawsSections.forEach(section => observer.observe(section));
            
            // Smooth scroll for TOC links
            tocLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) {
                        targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
            
            // Also handle category links at the top
            document.querySelectorAll('.bylaws-categories a').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const targetId = link.getAttribute('href').substring(1);
                    const targetSection = document.getElementById(targetId);
                    if (targetSection) {
                        targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
        }
    </script>
    
    <!-- Schedule Modal -->
    <div class="schedule-modal-overlay" id="schedule-modal-overlay" onclick="closeScheduleModal(event)">
        <div class="schedule-modal" onclick="event.stopPropagation()">
            <div class="schedule-modal-header">
                <img id="schedule-modal-logo" class="team-logo" src="" alt="">
                <div class="schedule-modal-title">
                    <h3 id="schedule-modal-team-name">Team Schedule</h3>
                    <p id="schedule-modal-manager">Manager</p>
                </div>
                <button class="schedule-modal-close" onclick="closeScheduleModal()">&times;</button>
            </div>
            <div class="schedule-modal-body">
                <div class="schedule-cards-grid" id="schedule-cards-grid">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
    </div>
</body>

</html>
