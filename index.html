<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Baseball Civil War</title>

    <!-- Favicon for browsers -->
    <link rel="icon" type="image/png" sizes="32x32" href="league_logo.png">
    <link rel="icon" type="image/png" sizes="16x16" href="league_logo.png">

    <!-- For iOS/Safari bookmarks -->
    <link rel="apple-touch-icon" sizes="180x180" href="league_logo.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #333;
            min-height: 100vh;
            padding-top: 120px;
            /* header (70px) + nav (~50px) */
        }

        header.desktop-header {
            background: #4a5d23;
            /* Olive/brown color to match banner edges */
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
        }

        /* Mobile header - hidden on desktop */
        header.mobile-header {
            display: none;
        }

        .header-container {
            position: relative;
            display: block;
        }

        .header-banner {
            width: 100%;
            height: auto;
            display: block;
            max-height: 70px;
            object-fit: cover;
        }

        .header-league-link {
            position: absolute;
            top: 0;
            left: 0;
            width: 12%;
            /* Full width of FBCW red box area */
            height: 100%;
            cursor: pointer;
            z-index: 10;
        }

        .header-league-link:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .league-logo {
            width: 50px;
            height: 50px;
            object-fit: contain;
        }

        .header-content {
            flex: 1;
        }

        h1 {
            color: #1e3c72;
            font-size: 2.2rem;
            margin-bottom: 0.3rem;
        }

        @media (max-width: 768px) {

            /* Hide desktop header on mobile */
            header.desktop-header {
                display: none;
            }

            /* Show mobile header */
            header.mobile-header {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 200;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            }

            .mobile-header-container {
                position: relative;
                width: 100%;
            }

            .mobile-header-banner {
                width: 100%;
                height: auto;
                display: block;
            }

            /* Clickable zones positioned over the banner */
            .mobile-zone {
                position: absolute;
                top: 0;
                height: 100%;
                z-index: 10;
            }

            .mobile-zone:active {
                background: rgba(255, 255, 255, 0.15);
            }

            /* Zone positions based on new banner layout */
            /* Logo area covers the left box */
            .zone-logo {
                left: 0;
                width: 35.5%;
            }

            /* Icon 1: Calendar */
            .zone-seasons {
                left: 35%;
                width: 10.75%;
            }

            /* Icon 2: Ribbon */
            .zone-awards {
                left: 45.5%;
                width: 10.75%;
            }

            /* Icon 3: Trophy (NEW) */
            .zone-champions {
                left: 56.0%;
                width: 10.75%;
            }

            /* Icon 4: Gauge */
            .zone-scoring {
                left: 66.5%;
                width: 10.75%;
            }

            /* Icon 5: Head */
            .zone-managers {
                left: 77.0%;
                width: 10.75%;
            }

            .zone-preseason {
                left: 89%;
                width: 10.75%;
                /* Takes remaining space */
            }

            /* Hide desktop nav on mobile */
            nav {
                display: none;
            }

            body {
                padding-top: 55px;
            }

            .header-league-link {
                width: 18%;
                /* Larger tap target on mobile */
            }

            .league-logo {
                width: 40px;
                height: 40px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .section {
                padding: 1rem;
            }
        }

        .tagline {
            color: #666;
            font-style: italic;
            font-size: 0.95rem;
        }

        nav {
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            text-align: center;
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            z-index: 100;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            body {
                padding-top: 95px;
            }

            nav {
                top: 50px;
                padding: 0.4rem;
            }
        }

        nav button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            margin: 0.25rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
        }

        @media (max-width: 768px) {
            nav button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
                margin: 0.2rem;
            }
        }

        nav button:hover {
            background: #1e3c72;
        }

        nav button.active {
            background: #ff6b6b;
        }

        .container {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        .section {
            display: none;
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 2rem;
            overflow-x: hidden;
        }

        @media (max-width: 768px) {
            .section {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }

            .container {
                padding: 0 0.5rem;
                margin: 0.5rem auto;
            }
        }

        .section.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: #1e3c72;
            margin-bottom: 1.5rem;
            border-bottom: 3px solid #ff6b6b;
            padding-bottom: 0.5rem;
        }

        @media (max-width: 768px) {
            h2 {
                font-size: 1.2rem;
                margin-bottom: 0.75rem;
            }

            h3 {
                font-size: 1rem;
            }

            label {
                font-size: 0.85rem;
            }

            select {
                font-size: 0.85rem;
                padding: 0.4rem;
            }
        }

        .standings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.95rem;
        }

        .team-logo {
            width: 30px;
            height: 30px;
            object-fit: contain;
            vertical-align: middle;
            margin-right: 0.5rem;
            border-radius: 50%;
            background: white;
            padding: 0.15rem;
        }

        .manager-cell {
            display: flex;
            align-items: center;
        }

        .team-cell-content {
            display: flex;
            align-items: center;
        }

        .player-award-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-award-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 1rem 0;
        }

        @media (max-width: 768px) {
            .table-wrapper {
                overflow-x: visible;
            }
        }

        @media (max-width: 768px) {
            .standings-table {
                font-size: 0.65rem;
                width: 100%;
                table-layout: fixed;
                border-collapse: collapse;
            }

            .standings-table th,
            .standings-table td {
                padding: 0.3rem 0.2rem;
                white-space: nowrap;
                overflow: hidden;
                vertical-align: middle;
            }

            .standings-table tr {
                border-bottom: 1px solid #ddd;
            }

            .standings-table td {
                border-bottom: none;
                /* Remove individual cell borders, use row border instead */
            }

            /* Column widths for mobile */
            .standings-table th:nth-child(1),
            .standings-table td:nth-child(1) {
                width: 8%;
            }

            /* Rank */

            .standings-table th:nth-child(2),
            .standings-table td:nth-child(2) {
                width: 18%;
            }

            /* Manager */

            .standings-table th:nth-child(3),
            .standings-table td:nth-child(3) {
                width: 28%;
            }

            /* Team Name */

            .standings-table th:nth-child(3) {
                width: 32%;
            }

            .standings-table td:nth-child(3) {
                width: 32%;
                white-space: normal;
                /* Allows text to wrap */
                line-height: 1.1;
                /* Tight line height */
                overflow: visible;
                padding-right: 2px;
            }

            .standings-table td:nth-child(3) .team-cell-content {
                display: flex;
                /* Enables side-by-side layout */
                align-items: center;
                /* Vertically centers logo and text */
            }

            /* Wins */

            .standings-table th:nth-child(5),
            .standings-table td:nth-child(5) {
                width: 9%;
            }

            /* Losses */

            .standings-table th:nth-child(6),
            .standings-table td:nth-child(6) {
                width: 9%;
            }

            /* Win % */

            .standings-table th:nth-child(7),
            .standings-table td:nth-child(7) {
                width: 14%;
            }

            /* Total Points */

            .standings-table .team-logo {
                width: 24px;
                /* Increased from 16px */
                height: 24px;
                /* Increased from 16px */
                min-width: 24px;
                /* Prevents squishing */
                margin-right: 4px;
                object-fit: contain;
            }
        }

        .standings-table th {
            background: #2a5298;
            color: white;
            padding: 1rem;
            text-align: left;
        }

        .standings-table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #ddd;
        }

        .standings-table tr:hover {
            background: #f5f5f5;
        }

        .season-selector {
            margin-bottom: 1.5rem;
        }

        .season-selector label {
            font-weight: bold;
            margin-right: 1rem;
            color: #1e3c72;
        }

        .season-selector select {
            padding: 0.5rem;
            font-size: 1rem;
            border: 2px solid #2a5298;
            border-radius: 5px;
        }

        /* Standings and Draft side-by-side layout */
        .standings-draft-container {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            align-items: flex-start;
        }

        .standings-panel {
            flex: 1;
            min-width: 0;
        }

        .standings-panel .table-wrapper {
            margin: 0;
        }

        .draft-panel {
            flex: 0 0 440px;
            min-width: 0;
        }

        .panel-title {
            color: #1e3c72;
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #2a5298;
            margin-top: 0;
        }

        .draft-table-wrapper {
            max-height: 600px;
            overflow-y: auto;
            overflow-x: hidden;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-top: 1.5rem;
        }

        .draft-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }

        .draft-table thead {
            position: sticky;
            top: 0;
            z-index: 1;
        }

        /* Round separator row */
        .draft-round-separator {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            font-weight: bold;
            text-align: center;
        }

        .draft-round-separator td {
            padding: 0.4rem !important;
            font-size: 0.8rem;
            border-bottom: none !important;
        }

        .draft-table th {
            background: #2a5298;
            color: white;
            padding: 0.5rem 0.4rem;
            text-align: left;
            font-size: 0.75rem;
        }

        /* Column widths for draft table */
        .draft-table th:nth-child(1),
        .draft-table td:nth-child(1) {
            width: 30px;
        }

        /* Rd */
        .draft-table th:nth-child(2),
        .draft-table td:nth-child(2) {
            width: 35px;
        }

        /* Pick */
        .draft-table th:nth-child(3),
        .draft-table td:nth-child(3) {
            width: auto;
        }

        /* Player - takes remaining space */
        .draft-table th:nth-child(4),
        .draft-table td:nth-child(4) {
            width: 40px;
            text-align: center;
        }

        /* Team */
        .draft-table th:nth-child(5),
        .draft-table td:nth-child(5) {
            width: 50px;
            text-align: right;
        }

        /* Pts */
        .draft-table th:nth-child(6),
        .draft-table td:nth-child(6) {
            width: 55px;
            text-align: center;
        }

        /* Rank */

        .draft-table td {
            padding: 0.4rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .draft-table tr:hover {
            background: #f5f5f5;
        }

        .draft-player-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .draft-headshot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .draft-player-info {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .draft-player-name {
            font-weight: 500;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .keeper-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: transparent;
            border: 2px solid #d4af37;
            border-radius: 50%;
            color: #d4af37;
            font-size: 0.6rem;
            font-weight: bold;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .prospect-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: transparent;
            border: 2px solid #17a2b8;
            border-radius: 50%;
            color: #17a2b8;
            font-size: 0.6rem;
            font-weight: bold;
            margin-left: 4px;
            flex-shrink: 0;
        }

        .prospect-free {
            color: #17a2b8 !important;
            background: transparent !important;
        }

        .is-prospect {
            background: rgba(23, 162, 184, 0.08);
        }

        /* Keeper Management Styles */
        .btn-select-keepers {
            padding: 0.5rem 1.25rem;
            background: linear-gradient(135deg, #d4af37, #c9a227);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.2s;
        }

        .btn-select-keepers:hover {
            background: linear-gradient(135deg, #e0bc3f, #d4af37);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .keeper-modal-content {
            max-width: 1450px;
            width: 95vw;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Styled close button with gold circle */
        .keeper-modal-close {
            position: absolute;
            right: 1rem;
            top: 1rem;
            width: 32px;
            height: 32px;
            border: 2px solid #d4af37;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1.25rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 20;
            line-height: 1;
        }

        .keeper-modal-close:hover {
            background: #d4af37;
            color: #1e3c72;
        }

        #keeper-modal-selection {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
            padding: 0;
            min-height: 0;
        }

        /* Two column body layout */
        .keeper-selection-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            gap: 1rem;
            padding: 0 1rem;
            min-height: 0;
        }

        /* Progress Bar Container */
        .keeper-progress-container {
            width: 100%;
            max-width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin: 0.5rem 0;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* The Dynamic Progress Bar */
        .keeper-progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #28a745, #20c997);
            border-radius: 5px;
            transition: width 0.3s ease-out, background 0.3s;
        }

        .keeper-progress-bar.full {
            background: linear-gradient(90deg, #d4af37, #f5d742);
        }

        /* Draft Picks Panel */
        .keeper-picks-section {
            width: 220px;
            flex-shrink: 0;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
        }

        .keeper-picks-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .keeper-pick-box {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #666;
            background: white;
            position: relative;
            overflow: hidden;
        }

        .keeper-pick-box.traded-away {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
            opacity: 0.6;
        }

        .keeper-pick-box.traded-for {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .keeper-pick-box.used-for-keeper {
            border-color: #d4af37;
            background: linear-gradient(135deg, #fff9e6, #fff3cd);
        }

        .keeper-pick-box .pick-round {
            font-size: 0.7rem;
            color: #888;
        }

        .keeper-pick-box .pick-number {
            font-size: 1rem;
            font-weight: 700;
            color: #1e3c72;
        }

        .keeper-pick-box .keeper-headshot {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 6px;
        }

        .keeper-pick-box .keeper-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
            padding: 0.25rem;
            text-align: center;
        }

        .keeper-pick-box .keeper-overlay span {
            color: white;
            font-size: 0.6rem;
            font-weight: 600;
        }

        .keeper-pick-box .traded-label {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .keeper-pick-box.prospect-pick {
            border-color: #17a2b8;
            background: linear-gradient(135deg, #e8f7fa, #d1ecf1);
        }

        .keeper-pick-box .prospect-overlay {
            background: linear-gradient(transparent, rgba(23, 162, 184, 0.8));
        }

        .keeper-prospects-divider {
            grid-column: 1 / -1;
            text-align: center;
            font-size: 0.7rem;
            font-weight: 600;
            color: #17a2b8;
            padding: 0.5rem 0 0.25rem;
            border-top: 1px dashed #17a2b8;
            margin-top: 0.5rem;
        }

        @media (max-width: 900px) {
            .keeper-selection-body {
                flex-direction: column;
            }

            .keeper-picks-section {
                width: 100%;
                max-height: 150px;
            }

            .keeper-picks-grid {
                grid-template-columns: repeat(6, 1fr);
            }
        }

        /* Header Layout */
        .keeper-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 1.25rem 1.5rem;
            padding-right: 3.5rem;
            /* Make room for close button */
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            flex-shrink: 0;
        }

        .keeper-header-left {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            flex: 1;
        }

        .keeper-header-logo {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: white;
            object-fit: contain;
            padding: 3px;
            flex-shrink: 0;
        }

        .keeper-header-info {
            flex: 1;
        }

        .keeper-header-actions {
            position: absolute;
            right: 1rem;
            top: 3.5rem;
        }

        .keeper-header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        /* Draft Picks Header with Toggle */
        .keeper-picks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e0e0e0;
        }

        .keeper-picks-header h4 {
            color: #1e3c72;
            font-size: 0.9rem;
            margin: 0;
            padding: 0;
            border: none;
        }

        .keeper-toggle-traded-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            background: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            cursor: pointer;
            color: #495057;
            transition: all 0.2s;
        }

        .keeper-toggle-traded-btn:hover {
            background: #dee2e6;
        }

        .keeper-toggle-traded-btn.active {
            background: #1e3c72;
            color: white;
            border-color: #1e3c72;
        }

        .keeper-modal-header h2 {
            margin: 0 0 0.25rem 0;
            font-size: 1.1rem;
            color: #f5d742;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .keeper-status {
            font-size: 0.85rem;
            opacity: 0.9;
        }

        .keeper-status.full {
            color: #f5d742;
            font-weight: bold;
            opacity: 1;
        }

        .keeper-switch-btn {
            padding: 0.35rem 0.7rem;
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .keeper-switch-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            color: #fff;
        }

        .keeper-modal-auth {
            padding: 2rem;
            text-align: center;
        }

        .keeper-modal-auth h2 {
            color: #1e3c72;
            margin-bottom: 0.5rem;
        }

        /* Roster Section - contains the table which scrolls independently */
        .keeper-roster-section {
            flex: 1;
            overflow: hidden;
            padding: 0.5rem 0;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .keeper-roster-table-wrapper {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            min-height: 0;
        }

        .keeper-roster-table-wrapper table {
            width: 100%;
            border-collapse: collapse;
        }

        .keeper-roster-table-wrapper thead {
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .keeper-roster-table-wrapper thead th {
            background: linear-gradient(135deg, #1e3c72, #2a5298) !important;
            color: white;
        }

        /* Fixed Footer */
        .keeper-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid #e0e0e0;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        /* Prevent body scroll when modal is open */
        body.keeper-modal-open {
            overflow: hidden;
        }

        .keeper-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid #e0e0e0;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        .keeper-selected-summary {
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            min-height: 50px;
            max-height: 80px;
            overflow: hidden;
        }

        .keeper-summary-header {
            font-weight: 600;
            color: #1e3c72;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .keeper-summary-list {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.5rem;
            overflow-x: auto;
            padding-bottom: 0.25rem;
        }

        .keeper-summary-list::-webkit-scrollbar {
            height: 6px;
        }

        .keeper-summary-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .keeper-summary-list::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .keeper-summary-list::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }

        .keeper-selected-summary .selected-player {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.3rem 0.5rem;
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid #d4af37;
            border-radius: 20px;
            font-size: 0.8rem;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .keeper-selected-summary .selected-player .remove-keeper {
            cursor: pointer;
            color: #888;
            margin-left: 0.25rem;
        }

        .keeper-selected-summary .selected-player .remove-keeper:hover {
            color: #dc3545;
        }

        .keeper-selected-summary .no-selection {
            color: #888;
            font-style: italic;
        }

        .keeper-cost-tag {
            background: #28a745;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-tag {
            background: #1e3c72;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-tag.adjusted {
            background: #6c5ce7;
            position: relative;
        }

        .keeper-round-tag.adjusted::after {
            content: '*';
            font-size: 0.6rem;
        }

        .keeper-round-tag.no-pick {
            background: #dc3545;
        }

        .selected-player.no-pick-warning {
            background: rgba(220, 53, 69, 0.15);
            border-color: #dc3545;
        }

        /* Cost columns in keeper table */
        .keeper-cost-col {
            text-align: center;
            font-size: 0.85rem;
        }

        .keeper-draft-round {
            color: #666;
        }

        .keeper-round-cost {
            color: #1e3c72;
            font-weight: 600;
        }

        .keeper-dollar-cost {
            color: #28a745;
            font-weight: 700;
        }

        .keeper-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        .keeper-cancel-btn {
            padding: 0.6rem 1.5rem;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .keeper-cancel-btn:hover {
            background: #5a6268;
        }

        .keeper-submit-btn {
            padding: 0.6rem 1.5rem;
            background: linear-gradient(135deg, #28a745, #218838);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
        }

        .keeper-submit-btn:hover {
            background: linear-gradient(135deg, #2dbc4e, #28a745);
        }

        .keeper-submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .keeper-auth-container {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 500px;
        }

        .keeper-auth-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .keeper-auth-field {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .keeper-auth-field label {
            min-width: 100px;
            font-weight: 500;
        }

        .keeper-auth-field select,
        .keeper-auth-field input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .keeper-auth-btn {
            padding: 0.5rem 1.25rem;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .keeper-auth-btn:hover {
            background: #2a5298;
        }

        .keeper-auth-error {
            color: #dc3545;
            margin-top: 0.75rem;
            font-size: 0.9rem;
        }

        .keeper-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 1rem;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border-radius: 8px;
            color: white;
        }

        .keeper-header-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .keeper-team-name {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .keeper-status {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .keeper-lock-btn {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            cursor: pointer;
        }

        .keeper-lock-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .keeper-roster-section h4 {
            color: #1e3c72;
            margin-bottom: 0.75rem;
        }

        .keeper-table .keeper-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .keeper-table tr.is-keeper {
            background: rgba(212, 175, 55, 0.15) !important;
        }

        .keeper-table tr.not-keeper {
            opacity: 0.5;
        }

        .keeper-table .keeper-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            margin-left: 0.5rem;
            padding: 0.15rem 0.5rem;
            background: #d4af37;
            color: white;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
        }

        /* Sortable headers for keeper table */
        #keeper-roster-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        #keeper-roster-table th.sortable::after {
            content: '';
            margin-left: 4px;
            opacity: 0.5;
        }

        #keeper-roster-table th.sortable.sort-asc::after {
            content: '▲';
            opacity: 1;
        }

        #keeper-roster-table th.sortable.sort-desc::after {
            content: '▼';
            opacity: 1;
        }

        /* =========================================
           KEEPER VALUE ANALYSIS STYLES
           ========================================= */
        .keeper-value-section {
            margin-top: 3rem;
            border-top: 2px solid #e0e0e0;
            padding-top: 2rem;
        }

        .keeper-value-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .keeper-value-header h3 {
            color: #1e3c72;
            margin: 0;
        }

        /* Expected Points Chart Container */
        .expected-points-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.25rem;
            margin-bottom: 2rem;
        }

        .expected-points-chart-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1rem 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .expected-points-chart-wrapper h4 {
            margin: 0 0 0.75rem 0;
            color: #1e3c72;
            font-size: 0.95rem;
        }

        .expected-points-chart {
            height: 200px;
            position: relative;
        }

        /* League Rankings Table */
        .value-rankings-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }
        
        .value-rankings-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }
        
        .value-rankings-table th {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 0.5rem 0.6rem;
            text-align: left;
            font-weight: 600;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .value-rankings-table th:first-child {
            border-radius: 6px 0 0 0;
        }

        .value-rankings-table th:last-child {
            border-radius: 0 6px 0 0;
            text-align: right;
        }
        
        .value-rankings-table td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
            white-space: nowrap;
        }

        .value-rankings-table tr:hover {
            background: #f8f9fa;
        }

        .value-rankings-table .rank-cell {
            font-weight: 700;
            color: #1e3c72;
            text-align: center;
        }

        .value-rankings-table .team-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .value-rankings-table .team-logo-small {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: contain;
            flex-shrink: 0;
        }

        .value-rankings-table .value-cell {
            text-align: right;
            font-weight: 700;
        }
        
        /* Best player cell in rankings */
        .best-player-cell {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            padding: 0.15rem 0;
            min-width: 140px;
        }
        
        .best-player-cell .player-headshot-mini {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #e0e0e0;
            flex-shrink: 0;
        }
        
        .best-player-cell .player-info {
            display: flex;
            flex-direction: column;
            line-height: 1.1;
            min-width: 0;
            flex: 1;
        }
        
        .best-player-cell .player-name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 75px;
            font-size: 0.65rem;
        }
        
        .best-player-cell .player-details {
            color: #666;
            font-size: 0.6rem;
            display: flex;
            align-items: center;
            gap: 0.2rem;
        }
        
        .best-player-cell .player-details .pos-badge {
            font-size: 0.5rem;
            padding: 0.05rem 0.2rem;
        }
        
        .best-player-cell .player-value {
            font-weight: 600;
            font-size: 0.65rem;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .top-players-cell {
            display: inline-flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        /* Draft pick circles in rankings */
        .top-picks-cell {
            display: inline-flex;
            gap: 0.4rem;
            align-items: center;
        }
        
        .pick-value-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.1rem;
        }
        
        .pick-circle {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #4a148c;
            border: 2px solid #d4af37;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #d4af37;
            font-weight: 700;
            font-size: 0.75rem;
        }
        
        .pick-expected {
            font-size: 0.6rem;
            color: #666;
            font-weight: 500;
        }

        .value-rankings-wrapper h4 {
            margin: 0 0 1rem 0;
            color: #1e3c72;
            font-size: 1rem;
        }
        
        /* Sortable headers */
        .value-rankings-table .sortable-header {
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        
        .value-rankings-table .sortable-header:hover {
            background: linear-gradient(135deg, #2a5298, #3a62a8);
        }
        
        .value-rankings-table .sortable-header .sort-icon {
            font-size: 0.7rem;
            margin-left: 0.25rem;
            opacity: 0.5;
        }
        
        .value-rankings-table .sortable-header.active .sort-icon {
            opacity: 1;
        }

        .value-positive {
            color: #28a745;
        }

        .value-negative {
            color: #dc3545;
        }

        .value-neutral {
            color: #6c757d;
        }

        /* Team Value Cards Grid */
        .team-value-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(340px, 1fr));
            gap: 1.25rem;
            margin-bottom: 2rem;
        }

        .team-value-card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .team-value-card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
        }

        .team-value-card-header .team-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .team-value-card-header .team-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            object-fit: contain;
            padding: 2px;
        }

        .team-value-card-header .team-name {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .team-value-card-header .team-manager {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .team-value-card-header .total-value {
            font-size: 1.1rem;
            font-weight: 700;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
        }

        .team-value-card-header .total-value.positive {
            background: rgba(40, 167, 69, 0.3);
        }

        .team-value-card-header .total-value.negative {
            background: rgba(220, 53, 69, 0.3);
        }

        .team-value-card-body {
            padding: 0;
        }

        .team-value-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .team-value-table th {
            background: #f8f9fa;
            padding: 0.5rem 0.6rem;
            text-align: left;
            font-weight: 600;
            color: #666;
            border-bottom: 1px solid #e0e0e0;
        }

        .team-value-table th:nth-child(3),
        .team-value-table th:nth-child(4),
        .team-value-table th:nth-child(5) {
            text-align: right;
        }

        .team-value-table td {
            padding: 0.5rem 0.6rem;
            border-bottom: 1px solid #eee;
        }

        .team-value-table td:nth-child(3),
        .team-value-table td:nth-child(4),
        .team-value-table td:nth-child(5) {
            text-align: right;
        }

        .team-value-table tr:last-child td {
            border-bottom: none;
        }

        .team-value-table .player-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .team-value-table .player-headshot-tiny {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
        }

        .team-value-card-footer {
            padding: 0.6rem 1rem;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
        }

        .team-value-card-footer .label {
            color: #666;
        }

        .team-value-card-footer .value {
            font-weight: 600;
        }

        /* Prospects Section */
        .prospects-value-section {
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(23, 162, 184, 0.08);
            border-radius: 12px;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }

        .prospects-value-section h4 {
            color: #17a2b8;
            margin: 0 0 1rem 0;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .prospects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 0.75rem;
        }

        .prospect-value-item {
            background: white;
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .prospect-value-item .prospect-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .prospect-value-item .prospect-team-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }

        .prospect-value-item .prospect-pts {
            font-weight: 600;
            color: #17a2b8;
        }

        /* Scatter Plot Container */
        .value-scatter-wrapper {
            background: white;
            border-radius: 12px;
            padding: 1.25rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-top: 1.5rem;
        }

        .value-scatter-wrapper h4 {
            margin: 0 0 1rem 0;
            color: #1e3c72;
            font-size: 1rem;
        }

        .value-scatter-chart {
            height: 350px;
            position: relative;
        }

        /* Loading state */
        .keeper-value-loading {
            text-align: center;
            padding: 3rem;
            color: #666;
        }

        /* League Keepers Grid */
        .keeper-league-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .keeper-team-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .keeper-team-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
        }

        .keeper-team-card-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: white;
            object-fit: contain;
            padding: 2px;
        }

        .keeper-team-card-info h5 {
            margin: 0;
            font-size: 0.95rem;
        }

        .keeper-team-card-info span {
            font-size: 0.8rem;
            opacity: 0.85;
        }

        .keeper-team-card-body {
            padding: 0.75rem 1rem;
        }

        .keeper-team-card-body .no-keepers {
            color: #888;
            font-style: italic;
            font-size: 0.85rem;
        }

        .keeper-by-tag {
            font-size: 0.7rem;
            color: #d4af37;
            font-weight: 600;
            margin-top: 2px;
        }

        /* Keeper row styling in projections table */
        #proj-table tr.is-keeper {
            background: rgba(212, 175, 55, 0.12) !important;
        }

        #proj-table tr.is-keeper:hover {
            background: rgba(212, 175, 55, 0.2) !important;
        }

        .keeper-player-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .keeper-player-row:last-child {
            border-bottom: none;
        }

        .keeper-player-row .keeper-badge {
            margin-left: 0;
            margin-right: 0.25rem;
        }

        .keeper-player-row .player-name {
            flex: 1;
            font-weight: 500;
        }

        .keeper-player-row .player-pos {
            color: #666;
            font-size: 0.85rem;
        }

        .keeper-player-row .player-pts {
            font-weight: 600;
            color: #1e3c72;
            min-width: 32px;
            text-align: right;
        }

        .keeper-cost-small {
            background: #28a745;
            color: white;
            padding: 0.1rem 0.35rem;
            border-radius: 2px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-small {
            background: #1e3c72;
            color: white;
            padding: 0.1rem 0.35rem;
            border-radius: 8px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .keeper-round-small.no-pick {
            background: #dc3545;
        }

        .keeper-player-row.no-pick-warning {
            background: rgba(220, 53, 69, 0.15);
        }

        .keeper-budget-used {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.15rem 0.4rem;
            border-radius: 8px;
            font-size: 0.75rem;
            margin-left: 0.5rem;
        }

        /* League Keeper Budget Bar */
        .league-budget-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.25rem;
        }

        .league-budget-bar-wrapper {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .league-budget-bar {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            border-radius: 4px;
            transition: width 0.3s ease-out, background 0.3s;
        }

        .league-budget-bar.full {
            background: linear-gradient(90deg, #d4af37, #f5d742);
        }

        .league-budget-bar.over {
            background: linear-gradient(90deg, #dc3545, #ff6b6b);
        }

        .league-budget-text {
            font-size: 0.7rem;
            opacity: 0.9;
            white-space: nowrap;
        }

        .prospect-count {
            color: #17a2b8;
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* ===== TRADE MANAGEMENT STYLES ===== */
        .btn-new-trade {
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-new-trade:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 60, 114, 0.3);
        }

        .btn-export-trades {
            padding: 0.5rem 1rem;
            background: linear-gradient(135deg, #6c757d, #5a6268);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-export-trades:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
        }

        .btn-toggle-prospects {
            padding: 0.4rem 0.8rem;
            background: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-toggle-prospects:hover {
            background: #dee2e6;
        }

        .btn-toggle-prospects.active {
            background: #17a2b8;
            color: white;
            border-color: #17a2b8;
        }

        .btn-adjust-budgets {
            padding: 0.4rem 0.8rem;
            background: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-adjust-budgets:hover {
            background: #ffc107;
            color: #212529;
            border-color: #ffc107;
        }

        .budget-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.75rem;
            border-bottom: 1px solid #e0e0e0;
        }

        .budget-row:last-child {
            border-bottom: none;
        }

        .budget-row .team-logo {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: contain;
            background: #f0f0f0;
            padding: 2px;
        }

        .budget-row .team-info {
            flex: 1;
        }

        .budget-row .team-name {
            font-weight: 600;
            color: #1e3c72;
        }

        .budget-row .manager-name {
            font-size: 0.85rem;
            color: #666;
        }

        .budget-row .budget-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .budget-row .budget-input {
            width: 70px;
            padding: 0.4rem 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: center;
        }

        .budget-row .budget-diff {
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 50px;
        }

        .budget-row .budget-diff.positive {
            color: #28a745;
        }

        .budget-row .budget-diff.negative {
            color: #dc3545;
        }

        /* Firebase connection status */
        .firebase-status {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .firebase-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .firebase-status.connected {
            background: rgba(40, 167, 69, 0.15);
            color: #28a745;
        }

        .firebase-status.connected .status-dot {
            background: #28a745;
            box-shadow: 0 0 6px #28a745;
        }

        .firebase-status.disconnected {
            background: rgba(108, 117, 125, 0.15);
            color: #6c757d;
        }

        .firebase-status.disconnected .status-dot {
            background: #6c757d;
        }

        /* Scrollable trades list */
        .trades-list-scrollable {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: #f8f9fa;
            padding: 1rem;
        }

        .trades-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Scrollable projections table with fixed header */
        .proj-table-scrollable {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            position: relative;
        }

        .proj-table-scrollable table {
            width: 100%;
            border-collapse: collapse;
        }

        .proj-table-scrollable thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        }

        .proj-table-scrollable thead th {
            background: transparent;
            color: white;
            padding: 0.75rem 0.5rem;
            font-weight: 600;
            text-align: left;
            border-bottom: 2px solid #1e3c72;
        }

        .proj-table-scrollable tbody tr {
            border-bottom: 1px solid #eee;
        }

        .proj-table-scrollable tbody tr:hover {
            background: #f0f4ff;
        }

        .no-trades {
            color: #888;
            font-style: italic;
            text-align: center;
            padding: 2rem;
        }

        .trade-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .trade-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .trade-card-date {
            font-size: 0.85rem;
            color: #666;
        }

        .trade-card-actions button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .trade-card-actions button:hover {
            opacity: 1;
        }

        .trade-card-body {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .trade-card-side {
            flex: 1;
            padding: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .trade-card-team {
            font-weight: 600;
            color: #1e3c72;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .trade-card-team img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        .trade-card-assets {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .trade-asset-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            margin: 0.1rem;
        }

        .trade-asset-tag.player {
            background: #e3f2fd;
            color: #1565c0;
        }

        .trade-asset-tag.pick {
            background: #fff3e0;
            color: #e65100;
        }

        .trade-asset-tag.money {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .trade-card-arrow {
            font-size: 1.5rem;
            color: #1e3c72;
        }

        .trade-card-notes {
            margin-top: 0.5rem;
            font-size: 0.85rem;
            color: #666;
            font-style: italic;
        }

        /* Trade Modal Styles */
        .trade-modal-content {
            max-width: 900px;
            width: 95vw;
        }

        .trade-modal-header {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 1.25rem 1.5rem;
            margin: -0px;
            border-radius: 15px 15px 0 0;
        }

        .trade-modal-header h2 {
            margin: 0 0 0.25rem 0;
            color: #f5d742;
        }

        .trade-modal-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .trade-builder {
            display: flex;
            gap: 1rem;
            padding: 1.5rem;
            align-items: flex-start;
        }

        .trade-side {
            flex: 1;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 1rem;
            min-height: 300px;
        }

        .trade-team-selector {
            margin-bottom: 1rem;
        }

        .trade-team-selector label {
            display: block;
            font-weight: 600;
            color: #1e3c72;
            margin-bottom: 0.5rem;
        }

        .trade-team-selector select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95rem;
        }

        .trade-team-info {
            background: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            margin-bottom: 1rem;
            border: 1px solid #e0e0e0;
        }

        .trade-budget-display {
            font-size: 0.9rem;
            color: #28a745;
            font-weight: 600;
        }

        .trade-assets {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
            min-height: 100px;
        }

        .trade-asset-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .trade-asset-item .asset-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .trade-asset-item .asset-type-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .trade-asset-item .asset-type-icon.player {
            background: #e3f2fd;
            color: #1565c0;
        }

        .trade-asset-item .asset-type-icon.pick {
            background: #fff3e0;
            color: #e65100;
        }

        .trade-asset-item .asset-type-icon.money {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .trade-asset-item .remove-asset {
            background: none;
            border: none;
            color: #dc3545;
            cursor: pointer;
            font-size: 1rem;
            padding: 0.25rem;
            opacity: 0.6;
        }

        .trade-asset-item .remove-asset:hover {
            opacity: 1;
        }

        .trade-add-asset select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        }

        .trade-asset-selector {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .trade-asset-selector select,
        .trade-asset-selector input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        .trade-asset-selector input[type="number"] {
            width: 80px;
            flex: none;
        }

        .trade-asset-selector button {
            padding: 0.5rem 0.75rem;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        .trade-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #1e3c72;
            padding: 0 0.5rem;
        }

        .trade-modal-footer {
            padding: 1rem 1.5rem;
            border-top: 2px solid #e0e0e0;
            background: #f8f9fa;
        }

        .trade-notes {
            margin-bottom: 1rem;
        }

        .trade-notes label {
            display: block;
            font-size: 0.85rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .trade-notes input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        .trade-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            .trade-builder {
                flex-direction: column;
            }

            .trade-arrow {
                transform: rotate(90deg);
                padding: 0.5rem 0;
            }

            .trade-card-body {
                flex-direction: column;
            }

            .trade-card-arrow {
                transform: rotate(90deg);
            }
        }

        @media (max-width: 600px) {
            .keeper-auth-field {
                flex-direction: column;
                align-items: flex-start;
            }

            .keeper-auth-field label {
                min-width: auto;
            }

            .keeper-auth-field select,
            .keeper-auth-field input {
                width: 100%;
            }

            .keeper-header {
                flex-direction: column;
                gap: 1rem;
                text-align: center;
            }

            .keeper-league-grid {
                grid-template-columns: 1fr;
            }
        }

        .draft-team-cell {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            position: relative;
        }

        .draft-team-logo {
            width: 24px;
            height: 24px;
            object-fit: contain;
            border-radius: 50%;
            background: white;
            padding: 2px;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }

        .draft-team-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.15s, visibility 0.15s;
            z-index: 100;
            pointer-events: none;
            margin-bottom: 4px;
        }

        .draft-team-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.85);
        }

        .draft-team-cell:hover .draft-team-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .draft-pts {
            font-weight: 600;
            color: #1e3c72;
        }

        .draft-rank {
            font-size: 0.75rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            text-align: center;
        }

        .draft-rank.top-10 {
            background: #c6efce;
            color: #006400;
        }

        .draft-rank.top-25 {
            background: #ffeb9c;
            color: #9c5700;
        }

        .draft-rank.top-50 {
            background: #ffc7ce;
            color: #9c0006;
        }

        .draft-empty {
            padding: 2rem;
            text-align: center;
            color: #666;
            font-style: italic;
        }

        @media (max-width: 1024px) {
            .standings-draft-container {
                flex-direction: column;
            }

            .draft-panel {
                flex: 1;
            }

            .draft-table-wrapper {
                max-height: 400px;
            }
        }

        @media (max-width: 768px) {
            .standings-draft-container {
                flex-direction: column;
                gap: 1rem;
            }

            .draft-panel {
                flex: 1;
            }

            .draft-table-wrapper {
                max-height: 350px;
            }

            .draft-table {
                font-size: 0.75rem;
            }

            .draft-table th,
            .draft-table td {
                padding: 0.3rem 0.25rem;
            }

            .draft-headshot {
                width: 24px;
                height: 24px;
            }

            .draft-player-name {
                font-size: 0.7rem;
            }

            .draft-player-pos {
                font-size: 0.6rem;
            }

            .draft-team-logo {
                width: 16px;
                height: 16px;
            }
        }

        .manager-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        @media (max-width: 768px) {
            .manager-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        .manager-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            cursor: pointer;
        }

        .manager-card:hover {
            transform: translateY(-5px);
        }

        .manager-card.inactive {
            background: linear-gradient(135deg, #757575 0%, #616161 100%);
            opacity: 0.8;
        }

        .manager-card h3 {
            margin-bottom: 1rem;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .manager-card .manager-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
            background: white;
            border-radius: 50%;
            padding: 0.25rem;
        }

        .manager-card .stat {
            margin: 0.5rem 0;
            font-size: 0.95rem;
        }

        .manager-card .stat strong {
            display: inline-block;
            width: 140px;
        }

        .manager-card .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.3);
            padding: 0.25rem 0.5rem;
            border-radius: 3px;
            font-size: 0.85rem;
        }

        .manager-card .awards-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .manager-card .award-badge {
            position: relative;
            font-size: 1.6rem;
            line-height: 1;
            display: inline-block;
        }

        .manager-card .award-count {
            position: absolute;
            bottom: -2px;
            right: -4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.55rem;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
            min-width: 14px;
            text-align: center;
        }

        /* Global award badge styles (for modal and other uses) */
        .awards-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex-wrap: wrap;
        }

        .award-badge {
            position: relative;
            font-size: 1.6rem;
            line-height: 1;
            display: inline-block;
        }

        .award-image {
            width: 28px;
            height: 28px;
            object-fit: contain;
            vertical-align: middle;
        }

        .award-count {
            position: absolute;
            bottom: -2px;
            right: -4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 0.55rem;
            padding: 0.1rem 0.2rem;
            border-radius: 2px;
            font-weight: bold;
            line-height: 1;
            min-width: 14px;
            text-align: center;
        }

        /* Manager Detail Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 0;
            border-radius: 15px;
            max-width: 900px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            position: relative;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #2a5298;
            border-radius: 15px 15px 0 0;
        }

        .modal-body-scroll {
            overflow-y: auto;
            padding: 2rem;
            flex: 1;
        }

        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                max-height: 90vh;
            }

            .modal-header {
                padding: 1.5rem;
                padding-bottom: 1rem;
            }

            .modal-body-scroll {
                padding: 1.5rem;
            }
        }

        .modal-close {
            position: absolute;
            right: 1.5rem;
            top: 1.5rem;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
            transition: color 0.3s;
            z-index: 11;
        }

        .modal-close:hover {
            color: #000;
        }

        .modal-header {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            padding: 2rem;
            padding-bottom: 1rem;
            border-bottom: 3px solid #2a5298;
            border-radius: 15px 15px 0 0;
        }

        .modal-header h2 {
            color: #1e3c72;
            margin-bottom: 0.5rem;
            border: none;
            padding: 0;
        }

        .modal-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        @media (max-width: 768px) {
            .modal-stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.75rem;
            }

            .stat-box {
                padding: 0.75rem;
            }

            .stat-box .value {
                font-size: 1.4rem;
            }

            .stat-box .label {
                font-size: 0.8rem;
            }
        }

        .stat-box {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .stat-box .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2a5298;
        }

        .stat-box .label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .timeline {
            margin: 2rem 0;
        }

        .timeline h3 {
            color: #1e3c72;
            margin-bottom: 1rem;
        }

        .timeline-item {
            display: flex;
            padding: 1rem;
            border-left: 3px solid #2a5298;
            margin-bottom: 1rem;
            background: #f8f9fa;
            border-radius: 0 8px 8px 0;
            align-items: center;
        }

        .timeline-item .year {
            font-weight: bold;
            color: #2a5298;
            min-width: 60px;
            font-size: 1.1rem;
        }

        .timeline-item .details {
            flex: 1;
            margin-left: 1rem;
        }

        .timeline-item .timeline-logo {
            width: 35px;
            height: 35px;
            object-fit: contain;
            border-radius: 50%;
            background: white;
            padding: 0.25rem;
            margin-left: 1rem;
        }

        .timeline-item .rank {
            display: inline-block;
            background: #2a5298;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            margin-right: 1rem;
            font-size: 0.9rem;
        }

        .timeline-item .rank.champion {
            background: #ffd700;
            color: #000;
        }

        .timeline-item .rank.runner-up {
            background: #c0c0c0;
            color: #000;
        }

        .matchup-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            overflow-x: auto;
            display: block;
        }

        .matchup-table thead,
        .matchup-table tbody,
        .matchup-table tr {
            display: table;
            width: 100%;
            table-layout: fixed;
        }

        @media (max-width: 768px) {
            .matchup-table {
                font-size: 0.8rem;
            }

            .matchup-table th,
            .matchup-table td {
                padding: 0.5rem 0.25rem;
            }
        }

        .matchup-table th {
            background: #2a5298;
            color: white;
            padding: 0.75rem;
            text-align: left;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .matchup-table th.sortable::after {
            content: ' ⇅';
            opacity: 0.5;
            font-size: 0.8rem;
        }

        .matchup-table th.sorted-asc::after {
            content: ' ▲';
            opacity: 1;
        }

        .matchup-table th.sorted-desc::after {
            content: ' ▼';
            opacity: 1;
        }

        .matchup-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
        }

        .matchup-table tr:hover {
            background: #f8f9fa;
        }

        .awards-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
        }

        @media (max-width: 900px) {
            .awards-grid {
                grid-template-columns: 1fr;
            }
        }

        .award-section {
            margin-bottom: 1rem;
        }

        .award-section h3 {
            color: #1e3c72;
            margin-bottom: 1rem;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .award-icon {
            font-size: 1.5rem;
        }

        .award-header-image {
            width: 28px;
            height: 28px;
            object-fit: contain;
            vertical-align: middle;
        }

        .award-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin-bottom: 1rem;
        }

        .award-table {
            width: 100%;
            border-collapse: collapse;
        }

        .award-table th {
            background: #2a5298;
            color: white;
            padding: 0.75rem;
            text-align: left;
            white-space: nowrap;
        }

        .award-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #ddd;
        }

        .award-table tr:hover {
            background: #f8f9fa;
        }

        .award-value {
            font-weight: bold;
            color: #2a5298;
        }

        /* ===== PLAYER SCORING STYLES ===== */
        .player-controls {
            margin-bottom: 1.5rem;
        }

        .player-control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: flex-end;
        }

        .player-control-row .season-selector,
        .player-control-row .position-filter,
        .player-control-row .manager-filter,
        .player-control-row .stat-type-toggle {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .stat-type-toggle .toggle-buttons {
            display: flex;
            gap: 0;
        }

        .toggle-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid #1e3c72;
            background: white;
            color: #1e3c72;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }

        .toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
            border-left: none;
        }

        .toggle-btn:hover {
            background: #f0f4f8;
        }

        .toggle-btn.active {
            background: #1e3c72;
            color: white;
        }

        .player-control-row label {
            font-weight: bold;
            color: #1e3c72;
            font-size: 0.85rem;
        }

        .player-control-row select {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
            min-width: 150px;
        }

        .player-search {
            width: 100%;
            max-width: 400px;
        }

        .player-search input {
            width: 100%;
            padding: 0.6rem 1rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        .player-search input:focus {
            outline: none;
            border-color: #2a5298;
            box-shadow: 0 0 0 2px rgba(42, 82, 152, 0.1);
        }

        .player-summary {
            margin-bottom: 1rem;
            color: #666;
            font-size: 0.9rem;
        }

        .player-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .player-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .player-table th {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            padding: 0.75rem 0.5rem;
            text-align: left;
            white-space: nowrap;
            position: sticky;
            top: 0;
        }

        .player-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .player-table th.sort-asc::after {
            content: ' ▲';
            font-size: 0.7rem;
        }

        .player-table th.sort-desc::after {
            content: ' ▼';
            font-size: 0.7rem;
        }

        .player-table td {
            padding: 0.6rem 0.5rem;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
        }

        .player-table tbody tr:hover {
            background: #f0f4f8;
        }

        .player-table thead tr:hover {
            background: transparent;
        }

        .player-table .stat-col {
            text-align: center;
        }

        .player-name-cell {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .player-name-cell:hover .player-name {
            color: #2a5298;
            text-decoration: underline;
        }

        .player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            background: #f0f0f0;
        }

        .player-name {
            font-weight: 500;
        }

        .player-mlb-team {
            font-size: 0.75rem;
            color: #888;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .player-mlb-logo {
            width: 16px;
            height: 16px;
            object-fit: contain;
        }

        .player-team-cell {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .player-team-logo {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
            background: white;
        }

        .player-fantasy-team {
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        .player-position {
            font-weight: 500;
            color: #555;
        }

        .player-points {
            font-weight: bold;
            color: #1e3c72;
        }

        /* =========================================
           UNIVERSAL POSITION COLOR SYSTEM
           9 distinct colors with dark text on light backgrounds
           ========================================= */
        :root {
            /* --- POSITION PLAYERS (Dark text colors) --- */
            --pos-c-dark:     #4a148c; /* C: Deep Purple */
            --pos-c-light:    rgba(74, 20, 140, 0.15);
            
            --pos-1b-dark:    #1565c0; /* 1B: Blue */
            --pos-1b-light:   rgba(21, 101, 192, 0.15);
            
            --pos-2b-dark:    #e65100; /* 2B: Orange */
            --pos-2b-light:   rgba(230, 81, 0, 0.15);
            
            --pos-3b-dark:    #b71c1c; /* 3B: Red */
            --pos-3b-light:   rgba(183, 28, 28, 0.15);
            
            --pos-ss-dark:    #9c7c00; /* SS: Gold */
            --pos-ss-light:   rgba(200, 160, 0, 0.18);
            
            --pos-of-dark:    #2e7d32; /* OF: Green */
            --pos-of-light:   rgba(46, 125, 50, 0.15);
            
            --pos-dh-dark:    #546e7a; /* DH/Util: Grey */
            --pos-dh-light:   rgba(84, 110, 122, 0.15);
        
            /* --- PITCHERS --- */
            --pos-sp-dark:    #7e57c2; /* SP: Faded Light Purple/Lavender */
            --pos-sp-light:   rgba(126, 87, 194, 0.15);
            
            --pos-rp-dark:    #00838f; /* RP: Cyan/Teal */
            --pos-rp-light:   rgba(0, 131, 143, 0.15);
            
            /* P uses same as SP for consistency */
            --pos-p-dark:     #7e57c2;
            --pos-p-light:    rgba(126, 87, 194, 0.15);
        }
        
        /* UNIFIED POSITION BADGE STYLE
           Dark text on light background for all contexts */
        .position-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            text-align: center;
            min-width: 26px;
            width: fit-content;
            margin-right: 2px;
            text-transform: uppercase;
        }
        
        /* Position-specific colors */
        .position-badge.pos-C  { color: var(--pos-c-dark); background-color: var(--pos-c-light); }
        .position-badge.pos-1B { color: var(--pos-1b-dark); background-color: var(--pos-1b-light); }
        .position-badge.pos-2B { color: var(--pos-2b-dark); background-color: var(--pos-2b-light); }
        .position-badge.pos-3B { color: var(--pos-3b-dark); background-color: var(--pos-3b-light); }
        .position-badge.pos-SS { color: var(--pos-ss-dark); background-color: var(--pos-ss-light); }
        .position-badge.pos-OF, 
        .position-badge.pos-LF, 
        .position-badge.pos-CF, 
        .position-badge.pos-RF { color: var(--pos-of-dark); background-color: var(--pos-of-light); }
        .position-badge.pos-DH, 
        .position-badge.pos-Util { color: var(--pos-dh-dark); background-color: var(--pos-dh-light); }
        .position-badge.pos-SP { color: var(--pos-sp-dark); background-color: var(--pos-sp-light); }
        .position-badge.pos-RP { color: var(--pos-rp-dark); background-color: var(--pos-rp-light); }
        .position-badge.pos-P  { color: var(--pos-p-dark); background-color: var(--pos-p-light); }
        
        /* Default/unknown position */
        .position-badge:not([class*="pos-"]) {
            color: #666;
            background-color: rgba(0, 0, 0, 0.08);
        }
        
        /* DRAFT TABLE BADGES - Same style, lowercase class names for compatibility */
        .draft-player-pos {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 700;
            text-align: center;
            min-width: 26px;
            width: fit-content;
            align-self: flex-start;
            text-transform: uppercase;
        }
        
        .draft-player-pos.pos-c  { color: var(--pos-c-dark); background-color: var(--pos-c-light); }
        .draft-player-pos.pos-1b { color: var(--pos-1b-dark); background-color: var(--pos-1b-light); }
        .draft-player-pos.pos-2b { color: var(--pos-2b-dark); background-color: var(--pos-2b-light); }
        .draft-player-pos.pos-3b { color: var(--pos-3b-dark); background-color: var(--pos-3b-light); }
        .draft-player-pos.pos-ss { color: var(--pos-ss-dark); background-color: var(--pos-ss-light); }
        .draft-player-pos.pos-of,
        .draft-player-pos.pos-lf,
        .draft-player-pos.pos-cf,
        .draft-player-pos.pos-rf { color: var(--pos-of-dark); background-color: var(--pos-of-light); }
        .draft-player-pos.pos-dh,
        .draft-player-pos.pos-util { color: var(--pos-dh-dark); background-color: var(--pos-dh-light); }
        .draft-player-pos.pos-sp { color: var(--pos-sp-dark); background-color: var(--pos-sp-light); }
        .draft-player-pos.pos-rp { color: var(--pos-rp-dark); background-color: var(--pos-rp-light); }
        .draft-player-pos.pos-p  { color: var(--pos-p-dark); background-color: var(--pos-p-light); }

        /* Hide batter/pitcher stats based on filter */
        .show-batters .pitcher-stat,
        .show-pitchers .batter-stat {
            display: none;
        }

        /* Player Modal Styles */
        .player-modal-content {
            max-width: 420px;
            background: transparent;
            box-shadow: none;
            border-radius: 12px;
            overflow: visible;
        }

        /* Baseball Card Design */
        .baseball-card {
            background: linear-gradient(135deg, #f5d742 0%, #e8c92e 50%, #d4b82a 100%);
            border-radius: 12px;
            border: 4px solid #1e3c72;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            overflow: hidden;
            position: relative;
        }

        .card-header {
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
            padding: 0.75rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid #f5d742;
        }

        .card-player-name {
            color: white;
            font-size: 1.4rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            flex: 1;
            text-align: center;
        }

        .card-mlb-logo {
            width: 48px;
            height: 48px;
            object-fit: contain;
            background: white;
            border-radius: 50%;
            padding: 6px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .card-mlb-fa {
            width: 48px;
            height: 48px;
            background: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            color: #1e3c72;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .card-mlb-team {
            color: #f5d742;
            font-size: 0.9rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-photo-section {
            position: relative;
            background: linear-gradient(180deg, #87CEEB 0%, #4a90c2 60%, #2d6a9f 100%);
            padding: 1rem;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            min-height: 200px;
        }

        .card-photo-frame {
            position: relative;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: white;
            padding: 5px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            border: 3px solid #f5d742;
        }

        .card-headshot {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            background: #e0e0e0;
        }

        .card-position-badge {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: #1e3c72;
            color: #f5d742;
            font-weight: bold;
            font-size: 0.85rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border: 2px solid #f5d742;
        }

        .card-team-logo-corner {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: contain;
            background: white;
            padding: 4px;
            border: 2px solid #f5d742;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .card-team-fa-corner {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: white;
            border: 2px solid #f5d742;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1rem;
            color: #1e3c72;
        }

        /* Keeper team logo wrapper for projection cards */
        .card-keeper-logo-wrapper {
            position: absolute;
            bottom: 10px;
            left: 10px;
        }

        .card-keeper-logo-wrapper .card-team-logo-corner {
            position: relative;
            bottom: auto;
            left: auto;
        }

        .card-keeper-badge {
            position: absolute;
            bottom: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background: white;
            border: 2px solid #d4af37;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem;
            font-weight: bold;
            color: #d4af37;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .card-acquisition-corner {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 500;
            color: #1e3c72;
            border: 2px solid #1e3c72;
            text-align: right;
            max-width: 120px;
            line-height: 1.2;
        }

        .card-acquisition-corner .acq-type {
            font-weight: bold;
            display: block;
        }

        .card-stats-corner {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        .card-team-badge {
            background: rgba(255, 255, 255, 0.95);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            color: #1e3c72;
            border: 2px solid #1e3c72;
        }

        .card-fantasy-points {
            background: #f5d742;
            color: #1e3c72;
            font-size: 1.1rem;
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border: 2px solid #1e3c72;
            text-align: center;
        }

        .card-fantasy-points .pts-label {
            font-size: 0.6rem;
            font-weight: normal;
            display: block;
        }

        .card-position-rank {
            background: #1e3c72;
            color: #f5d742;
            font-size: 0.75rem;
            font-weight: bold;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            border: 2px solid #f5d742;
        }

        .card-info-strip {
            background: #1e3c72;
            color: white;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            border-top: 2px solid #f5d742;
            border-bottom: 2px solid #f5d742;
        }

        .card-info-strip span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .card-stats-section {
            background: #fffef5;
            padding: 0.75rem;
        }

        .card-stats-title {
            background: #1e3c72;
            color: #f5d742;
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 0.3rem 0.5rem;
            margin: -0.75rem -0.75rem 0.5rem -0.75rem;
            text-align: center;
        }

        .card-stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .card-stats-header .card-stats-title {
            margin: 0;
            padding: 0;
            background: none;
        }

        .card-stat-toggle {
            display: flex;
            gap: 0;
        }

        .card-toggle-btn {
            padding: 0.25rem 0.5rem;
            border: 1px solid #1e3c72;
            background: white;
            color: #1e3c72;
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .card-toggle-btn:first-child {
            border-radius: 3px 0 0 3px;
        }

        .card-toggle-btn:last-child {
            border-radius: 0 3px 3px 0;
            border-left: none;
        }

        .card-toggle-btn:hover {
            background: #f0f4f8;
        }

        .card-toggle-btn.active {
            background: #1e3c72;
            color: white;
        }

        .card-stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .card-stats-table th {
            background: #2a5298;
            color: white;
            padding: 0.35rem 0.25rem;
            text-align: center;
            font-weight: bold;
            font-size: 0.65rem;
            text-transform: uppercase;
            border: 1px solid #1e3c72;
        }

        .card-stats-table td {
            background: white;
            padding: 0.35rem 0.25rem;
            text-align: center;
            border: 1px solid #ddd;
            font-weight: 600;
            color: #333;
        }

        .card-stats-table tr:nth-child(even) td {
            background: #f8f8f0;
        }

        .card-history-section {
            background: #fffef5;
            padding: 0.5rem 0.75rem 0.75rem;
            border-top: 2px dashed #ccc;
        }

        .card-history-title {
            font-size: 0.7rem;
            font-weight: bold;
            color: #1e3c72;
            text-transform: uppercase;
            margin-bottom: 0.4rem;
            text-align: center;
        }

        .card-history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.65rem;
        }

        .card-history-table th {
            background: #1e3c72;
            color: white;
            padding: 0.25rem;
            text-align: center;
            font-size: 0.6rem;
        }

        .card-history-table td {
            padding: 0.25rem;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        .card-history-table .team-logo-small {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            vertical-align: middle;
            margin-right: 3px;
        }

        .card-footer {
            background: linear-gradient(180deg, #1e3c72 0%, #152a52 100%);
            color: #f5d742;
            padding: 0.5rem 1rem;
            font-size: 0.65rem;
            text-align: center;
            border-top: 3px solid #f5d742;
        }

        .card-footer .owner-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
        }

        .card-footer .owner-logo {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #f5d742;
        }

        /* Scrollable stats area */
        .card-scrollable {
            max-height: 280px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #1e3c72 #f5d742;
        }

        .card-scrollable::-webkit-scrollbar {
            width: 6px;
        }

        .card-scrollable::-webkit-scrollbar-track {
            background: #f5d742;
        }

        .card-scrollable::-webkit-scrollbar-thumb {
            background: #1e3c72;
            border-radius: 3px;
        }

        /* Hide the default modal body scroll for player modal */
        #player-modal .modal-body-scroll {
            padding: 0;
            max-height: none;
            overflow: visible;
        }

        #player-modal .modal-close {
            color: white;
            background: #1e3c72;
            border: 2px solid #f5d742;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            top: 8px;
            right: 8px;
        }

        #player-modal .modal-close:hover {
            background: #f5d742;
            color: #1e3c72;
        }

        #player-modal-header {
            display: none;
            /* Hide default header, we'll build card structure in body */
        }

        /* Projection Modal Styles */
        .projection-modal-content {
            max-width: 900px;
            width: 95vw;
            background: transparent;
            box-shadow: none;
            border-radius: 12px;
            overflow: visible;
        }

        .projection-modal-layout {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
        }

        .projection-card-container {
            flex: 0 0 420px;
            max-width: 420px;
        }

        .projection-charts-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 350px;
        }

        .projection-chart-box {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border: 3px solid #1e3c72;
        }

        .projection-chart-title {
            font-size: 0.9rem;
            font-weight: bold;
            color: #1e3c72;
            text-align: center;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .projection-chart {
            height: 180px;
            position: relative;
        }

        #projection-modal .modal-close {
            position: absolute;
            top: -12px;
            right: -12px;
            background: #1e3c72;
            color: white;
            border: 3px solid #f5d742;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        #projection-modal .modal-close:hover {
            background: #f5d742;
            color: #1e3c72;
        }

        /* Chart dot styles */
        .chart-dot {
            fill: #1e3c72;
            opacity: 0.7;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .chart-dot:hover {
            opacity: 0.9;
        }

        .chart-dot.highlighted {
            fill: #f5d742;
            stroke: #1e3c72;
            stroke-width: 2;
            opacity: 1;
        }

        /* Keeper dot style for charts */
        .chart-dot.keeper-dot {
            fill: #f5d742;
            /* Gold */
            stroke: #b8860b;
            /* Darker gold border for visibility */
            stroke-width: 1px;
            opacity: 0.5;
        }

        .chart-dot.keeper-dot:hover {
            fill: #ffd700;
            opacity: 0.9;
        }

        .chart-axis {
            stroke: #ccc;
            stroke-width: 1;
        }

        .chart-axis-label {
            font-size: 10px;
            fill: #666;
        }

        .chart-grid {
            stroke: #eee;
            stroke-width: 1;
        }

        /* Mobile styles for projection modal */
        @media (max-width: 900px) {
            .projection-modal-content {
                max-width: 95vw;
            }

            .projection-modal-layout {
                flex-direction: column;
                align-items: center;
            }

            .projection-card-container {
                flex: none;
                max-width: 100%;
                width: 100%;
            }

            .projection-charts-container {
                width: 100%;
                min-width: auto;
            }
        }

        /* Mobile styles for baseball card */
        @media (max-width: 480px) {
            .player-modal-content {
                max-width: 95vw;
                margin: 0.5rem;
            }

            .baseball-card {
                border-width: 3px;
            }

            .card-header {
                padding: 0.5rem 0.75rem;
            }

            .card-mlb-logo {
                width: 30px;
                height: 30px;
            }

            .card-player-name {
                font-size: 1.1rem;
            }

            .card-fantasy-points {
                font-size: 0.9rem;
                padding: 0.15rem 0.35rem;
            }

            .card-fantasy-points .pts-label {
                font-size: 0.5rem;
            }

            .card-photo-section {
                min-height: 160px;
                padding: 0.75rem;
            }

            .card-photo-frame {
                width: 120px;
                height: 120px;
            }

            .card-position-badge {
                font-size: 0.75rem;
            }

            .card-team-badge {
                font-size: 0.65rem;
                padding: 0.2rem 0.4rem;
            }

            .card-team-logo-corner {
                width: 40px;
                height: 40px;
            }

            .card-position-rank {
                font-size: 0.65rem;
                padding: 0.15rem 0.35rem;
            }

            .card-mlb-team {
                font-size: 0.7rem;
            }

            .card-info-strip {
                font-size: 0.7rem;
                padding: 0.4rem 0.75rem;
            }

            .card-stats-table th,
            .card-stats-table td {
                padding: 0.25rem 0.15rem;
                font-size: 0.6rem;
            }

            .card-history-table {
                font-size: 0.6rem;
            }

            .card-scrollable {
                max-height: 220px;
            }
        }

        .player-history-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .player-history-table th {
            background: #f0f4f8;
            padding: 0.6rem;
            text-align: left;
            font-weight: 600;
            color: #1e3c72;
        }

        .player-history-table td {
            padding: 0.6rem;
            border-bottom: 1px solid #eee;
        }

        .player-history-table tr:hover {
            background: #f8f9fa;
        }

        /* Hall of Champions Styles */
        .champion-header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            box-shadow: 0 4px 15px rgba(30, 60, 114, 0.3);
        }

        .champion-header .team-logo {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .champion-header .champion-info h3 {
            font-size: 1.8rem;
            margin: 0 0 0.25rem 0;
            color: #ffd700;
        }

        .champion-header .champion-info .manager-name {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .champion-header .champion-info .season-year {
            font-size: 1rem;
            opacity: 0.7;
            margin-top: 0.5rem;
        }

        .champion-header .trophy-icon {
            font-size: 3rem;
            margin-left: auto;
        }

        .championship-count-banner {
            background: linear-gradient(90deg, #ffd700, #ffec8b, #ffd700);
            color: #1e3c72;
            text-align: center;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
            font-size: 1.3rem;
            font-weight: bold;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }

        .champion-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .champion-stat-card {
            background: white;
            border-radius: 10px;
            padding: 1.25rem;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e0e0e0;
        }

        .champion-stat-card .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #1e3c72;
        }

        .champion-stat-card .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 0.25rem;
        }

        .champion-section {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .champion-section h3 {
            color: #1e3c72;
            margin: 0 0 1rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #eee;
        }

        .champion-schedule-table {
            width: 100%;
            border-collapse: collapse;
        }

        .champion-schedule-table th {
            background: #f0f4f8;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #1e3c72;
        }

        .champion-schedule-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #eee;
        }

        .champion-schedule-table .result-win {
            color: #28a745;
            font-weight: bold;
        }

        .champion-schedule-table .result-loss {
            color: #dc3545;
            font-weight: bold;
        }

        .champion-schedule-table .schedule-row-win {
            background: rgba(40, 167, 69, 0.08);
        }

        .champion-schedule-table .schedule-row-win:hover {
            background: rgba(40, 167, 69, 0.15);
        }

        .champion-schedule-table .schedule-row-loss {
            background: rgba(220, 53, 69, 0.08);
        }

        .champion-schedule-table .schedule-row-loss:hover {
            background: rgba(220, 53, 69, 0.15);
        }

        .champion-schedule-table .playoff-week {
            border-left: 3px solid #ffd700;
        }

        .champion-schedule-table .championship-week {
            border-left: 3px solid #ffd700;
            background: rgba(255, 215, 0, 0.15) !important;
        }

        .champion-schedule-table .championship-week:hover {
            background: rgba(255, 215, 0, 0.25) !important;
        }

        .schedule-opponent {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .schedule-team-logo {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
        }

        .roster-grid {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .roster-player-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid #e0e0e0;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .roster-player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .roster-player-card .player-headshot {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
        }

        .roster-player-card .player-info {
            flex: 1;
        }

        .roster-player-card .player-name {
            font-weight: 600;
            color: #1e3c72;
        }

        .roster-player-card .player-position {
            font-size: 0.8rem;
            color: #666;
        }

        .roster-player-card .player-points {
            text-align: right;
        }

        .roster-player-card .points-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #1e3c72;
        }

        .roster-player-card .points-label {
            font-size: 0.7rem;
            color: #888;
        }

        .roster-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .roster-columns {
                grid-template-columns: 1fr;
            }
        }

        .roster-column {
            min-width: 0;
        }

        .roster-section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1e3c72;
            margin: 0 0 0.75rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #1e3c72;
        }

        .prospects-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 2px dashed #ddd;
        }

        .prospects-section .roster-section-title {
            color: #888;
            border-bottom-color: #ccc;
        }

        .prospects-section .roster-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 0.5rem;
        }

        .roster-player-card.prospect {
            background: #f0f0f0;
            opacity: 0.8;
        }

        .roster-player-card.prospect .points-value {
            color: #999;
        }

        /* Mobile styles for Player Scoring */
        @media (max-width: 768px) {
            .player-control-row {
                flex-direction: column;
                gap: 0.75rem;
            }

            .player-control-row .season-selector,
            .player-control-row .position-filter,
            .player-control-row .manager-filter,
            .player-control-row .stat-type-toggle {
                width: 100%;
            }

            .stat-type-toggle .toggle-buttons {
                width: 100%;
            }

            .toggle-btn {
                flex: 1;
                text-align: center;
            }

            .player-control-row select {
                width: 100%;
                min-width: unset;
            }

            .player-search {
                max-width: 100%;
            }

            .player-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .player-table {
                font-size: 0.7rem;
                min-width: 600px;
            }

            .player-table th,
            .player-table td {
                padding: 0.4rem 0.3rem;
            }

            .player-headshot {
                width: 24px;
                height: 24px;
            }

            .player-team-logo {
                width: 18px;
                height: 18px;
            }

            .player-name-cell {
                gap: 0.3rem;
            }

            .player-mlb-team {
                font-size: 0.65rem;
            }

            .player-mlb-logo {
                width: 12px;
                height: 12px;
            }

            .player-fantasy-team {
                max-width: 60px;
                font-size: 0.7rem;
            }

            /* Player Modal Mobile */
            .player-modal-content {
                width: 95%;
                max-height: 90vh;
            }

            #player-modal-header {
                flex-direction: column;
                text-align: center;
                padding: 1rem;
                gap: 0.75rem;
            }

            .player-modal-headshot {
                width: 60px;
                height: 60px;
            }

            .player-modal-info h2 {
                font-size: 1.2rem;
            }

            .player-modal-info .player-details {
                flex-wrap: wrap;
                justify-content: center;
                gap: 0.5rem;
            }

            .player-modal-points {
                margin-left: 0;
                text-align: center;
            }

            .player-modal-points .points-value {
                font-size: 1.5rem;
            }

            .player-stats-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.5rem;
            }

            .player-stat-box {
                padding: 0.5rem;
            }

            .player-stat-box .stat-value {
                font-size: 1rem;
            }

            .player-stat-box .stat-label {
                font-size: 0.65rem;
            }

            .player-history-table {
                font-size: 0.8rem;
            }

            .player-history-table th,
            .player-history-table td {
                padding: 0.4rem;
            }
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        @media (max-width: 768px) {
            .award-table {
                font-size: 0.6rem;
                width: 100%;
                table-layout: fixed;
            }

            .award-table th,
            .award-table td {
                padding: 0.3rem 0.2rem;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            /* Award table column widths */
            .award-table th:nth-child(1),
            .award-table td:nth-child(1) {
                width: 15%;
            }

            /* Year */

            .award-table th:nth-child(2),
            .award-table td:nth-child(2) {
                width: 25%;
            }

            /* Manager */

            .award-table th:nth-child(3),
            .award-table td:nth-child(3) {
                width: 40%;
            }

            /* Team Name */

            .award-table th:nth-child(4),
            .award-table td:nth-child(4) {
                width: 20%;
            }

            /* Points/Wins */

            .award-section h3 {
                font-size: 1rem;
            }

            .award-icon {
                font-size: 1rem;
            }

            .awards-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .award-table-wrapper {
                overflow-x: visible;
            }
        }

        .error {
            background: #fee;
            border: 1px solid #fcc;
            padding: 1rem;
            border-radius: 5px;
            color: #c33;
            margin: 1rem 0;
        }

        /* Season Chart Styles */
        .chart-svg {
            overflow: visible;
        }

        .chart-line {
            fill: none;
            stroke-width: 2.5;
            transition: opacity 0.3s ease, stroke-width 0.3s ease;
        }

        .chart-line.faded {
            opacity: 0.15;
        }

        .chart-line.highlighted {
            stroke-width: 4;
        }

        .team-logo-marker {
            cursor: pointer;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .team-logo-marker.faded {
            opacity: 0.2;
        }

        .team-logo-marker.highlighted {
            transform-origin: center;
        }

        .chart-tooltip {
            position: absolute;
            background: rgba(30, 60, 114, 0.95);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transform: translate(-50%, -100%);
            margin-top: -10px;
        }

        .chart-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(30, 60, 114, 0.95);
        }

        .chart-axis-label {
            font-size: 0.75rem;
            fill: #666;
        }

        .chart-grid-line {
            stroke: #e0e0e0;
            stroke-width: 1;
        }

        .chart-toggle-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s, color 0.3s;
        }

        .chart-toggle-btn:hover {
            background: #ccc;
        }

        .chart-toggle-btn.active {
            background: #2a5298;
            color: white;
        }

        /* Win Percentage Chart Styles */
        .winpct-chart {
            font-family: inherit;
        }

        .winpct-chart .chart-line {
            transition: opacity 0.2s;
        }

        .winpct-chart .chart-line.faded {
            opacity: 0.15;
        }

        .winpct-chart .chart-line.highlighted path:first-child {
            stroke-width: 4;
        }

        #winpct-chart {
            position: relative;
        }

        #winpct-chart .chart-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
        }

        /* Mobile optimizations for chart */
        @media (max-width: 768px) {
            #season-chart-container>div:first-child {
                flex-direction: column;
                align-items: flex-start;
            }

            #season-chart {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .chart-toggle-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.85rem;
            }

            /* Mobile adjustments for Champion Schedule Table */
            .champion-schedule-table {
                font-size: 0.7rem;
                /* Reduce font size significantly */
                table-layout: fixed;
                /* Enforce column widths */
                width: 100%;
            }

            .champion-schedule-table th,
            .champion-schedule-table td {
                padding: 0.4rem 0.2rem;
                /* Tighten padding */
                white-space: nowrap;
                /* Prevent wrapping */
                overflow: hidden;
                text-overflow: ellipsis;
                /* Add ... if text is too long */
            }

            /* Week Column */
            .champion-schedule-table th:nth-child(1),
            .champion-schedule-table td:nth-child(1) {
                width: 15%;
            }

            /* Opponent Column (Give this the most space) */
            .champion-schedule-table th:nth-child(2),
            .champion-schedule-table td:nth-child(2) {
                width: 40%;
                white-space: normal;
                /* Allow wrapping */
                line-height: 1.2;
                /* Tighter spacing */
                text-overflow: clip;
                /* Remove the "..." */
                overflow: visible;
                /* Show content */
            }

            /* Score Column */
            .champion-schedule-table th:nth-child(3),
            .champion-schedule-table td:nth-child(3) {
                width: 33%;
                text-align: center;
                font-size: 0.65rem;
                /* Make score slightly smaller to fit decimals */
            }

            /* Result Column */
            .champion-schedule-table th:nth-child(4),
            .champion-schedule-table td:nth-child(4) {
                width: 10%;
                text-align: center;
            }

            /* Adjust opponent logo and text gap */
            .schedule-opponent {
                gap: 0.25rem;
            }

            .schedule-team-logo {
                width: 16px;
                /* Smaller logo */
                height: 16px;
            }

            .week-text {
                display: none;
            }
        }

        /* =========================================
           MOBILE PLAYER MODAL - SCROLLABLE CONTENT
           ========================================= */
        @media (max-width: 768px) {
            /* Lock body scroll when modal is open */
            body.modal-open,
            body.keeper-modal-open {
                overflow: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
            }

            /* Make the modal backdrop scrollable and align content to top */
            #player-modal.active,
            #projection-modal.active {
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                align-items: flex-start;
                padding: 1rem 0;
            }

            /* Let content flow naturally */
            #player-modal .modal-content,
            #player-modal .player-modal-content,
            #projection-modal .modal-content,
            #projection-modal .projection-modal-content {
                max-height: none;
                height: auto;
                margin: 0 auto;
                overflow: visible;
                flex-shrink: 0;
            }

            #player-modal .modal-body-scroll,
            #projection-modal .modal-body-scroll {
                overflow: visible;
                max-height: none;
                padding: 0;
            }

            .baseball-card {
                max-height: none;
                overflow: visible;
            }

            .card-scrollable {
                max-height: none !important;
                overflow: visible !important;
            }

            /* Projection modal charts - ensure visible */
            .projection-modal-layout {
                flex-direction: column;
            }

            .projection-charts-panel {
                width: 100%;
                padding: 1rem;
            }

            .projection-chart-container {
                height: 200px;
                margin-bottom: 1rem;
            }
        }

        footer {
            background: rgba(255, 255, 255, 0.9);
            text-align: center;
            padding: 1rem;
            margin-top: 2rem;
            color: #666;
        }
    </style>
</head>

<body>
    <header class="desktop-header">
        <div class="header-container">
            <picture>
                <source srcset="header_long.png" media="(min-width: 1200px)">
                <img src="header_short.png" alt="Fantasy Baseball Civil War - Established 2017 - 12 Team Points League"
                    class="header-banner">
            </picture>
            <a href="https://baseball.fantasysports.yahoo.com/league/fantasybaseballcivilwar/2025" target="_blank"
                class="header-league-link" title="Go to Yahoo Fantasy League"></a>
        </div>
    </header>

    <header class="mobile-header">
        <div class="mobile-header-container">
            <img src="mobile_header.png" alt="Fantasy Baseball Civil War" class="mobile-header-banner">
            <a href="https://baseball.fantasysports.yahoo.com/league/fantasybaseballcivilwar/2025" target="_blank"
                class="mobile-zone zone-logo" title="Go to Yahoo Fantasy League"></a>

            <a href="#" class="mobile-zone zone-seasons" onclick="showSection('standings'); return false;"
                title="Seasons"></a>

            <a href="#" class="mobile-zone zone-awards" onclick="showSection('awards'); return false;"
                title="Awards"></a>

            <a href="#" class="mobile-zone zone-champions" onclick="showSection('champions'); return false;"
                title="Hall of Champions"></a>

            <a href="#" class="mobile-zone zone-scoring" onclick="showSection('scoring'); return false;"
                title="Player Scoring"></a>

            <a href="#" class="mobile-zone zone-managers" onclick="showSection('managers'); return false;"
                title="Manager Profiles"></a>

            <a href="#" class="mobile-zone zone-preseason" onclick="showSection('preseason'); return false;"
                title="Preseason Tools"></a>
        </div>
    </header>

    <nav>
        <button onclick="showSection('standings')" class="nav-btn active">Seasons</button>
        <button onclick="showSection('awards')" class="nav-btn">Awards</button>
        <button onclick="showSection('champions')" class="nav-btn">Hall of Champions</button>
        <button onclick="showSection('scoring')" class="nav-btn">Player Scoring</button>
        <button onclick="showSection('managers')" class="nav-btn">Manager Profiles</button>
        <button onclick="showSection('preseason')" class="nav-btn">Preseason Tools</button>
    </nav>

    <div class="container">
        <!-- Seasons Section -->
        <div id="standings" class="section active">
            <h2>Seasons</h2>

            <div class="season-selector">
                <label for="standings-season">Select Season:</label>
                <select id="standings-season" onchange="loadStandingsBySeason()">
                    <!-- Will be populated dynamically -->
                </select>
            </div>

            <div id="standings-loading" class="loading">Loading standings...</div>
            <div id="standings-error" class="error" style="display: none;"></div>

            <!-- Container for standings and draft side by side -->
            <div class="standings-draft-container">
                <!-- Standings Table -->
                <div class="standings-panel">
                    <h3 class="panel-title">Final Standings</h3>
                    <div class="table-wrapper">
                        <table class="standings-table" id="standings-table" style="display: none;">
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Manager</th>
                                    <th>Team Name</th>
                                    <th>Wins</th>
                                    <th>Losses</th>
                                    <th>Win %</th>
                                    <th>Total Points</th>
                                </tr>
                            </thead>
                            <tbody id="standings-body">
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Draft Results Table -->
                <div class="draft-panel">
                    <h3 class="panel-title">Draft Results</h3>
                    <div class="draft-table-wrapper">
                        <table class="draft-table" id="draft-table" style="display: none;">
                            <thead>
                                <tr>
                                    <th>Rd</th>
                                    <th>Pick</th>
                                    <th>Player</th>
                                    <th>Team</th>
                                    <th>Pts</th>
                                    <th>Rank</th>
                                </tr>
                            </thead>
                            <tbody id="draft-body">
                            </tbody>
                        </table>
                        <div id="draft-loading" class="loading" style="display: none;">Loading draft...</div>
                        <div id="draft-empty" class="draft-empty" style="display: none;">No draft data available</div>
                    </div>
                </div>
            </div>

            <!-- Season Points Chart -->
            <div id="season-chart-container" style="display: none; margin-top: 2rem;">
                <div
                    style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem;">
                    <h3 style="color: #1e3c72; margin: 0;">Summary</h3>
                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                        <label style="font-weight: bold; color: #1e3c72;">Scoring Type:</label>
                        <button id="btn-weekly" class="chart-toggle-btn active"
                            onclick="setChartType('weekly')">Weekly</button>
                        <button id="btn-total" class="chart-toggle-btn" onclick="setChartType('total')">Total</button>
                    </div>
                </div>
                <div id="season-chart"
                    style="position: relative; width: 100%; min-height: 500px; background: #fafafa; border-radius: 8px; overflow: visible;">
                </div>
            </div>
        </div>

        <!-- Awards Section -->
        <div id="awards" class="section">
            <h2>🏆 League Awards</h2>

            <div id="awards-loading" class="loading">Loading awards...</div>
            <div id="awards-error" class="error" style="display: none;"></div>

            <div id="awards-content" style="display: none;">
                <div class="awards-grid">
                    <div class="award-section">
                        <h3><span class="award-icon">👑</span> Regular Season Champion (Most Wins)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Wins</th>
                                    </tr>
                                </thead>
                                <tbody id="regular-season-winners">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon">🏅</span> Scoring Champion (Most Points)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="scoring-champions">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon">🗑️</span> Garbage Award (Worst Record)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Record</th>
                                    </tr>
                                </thead>
                                <tbody id="garbage-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="clown_award.png" alt="Clown Award"
                                    class="award-header-image"></span> Clown Award (Least Points)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Team Name</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="clown-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="attached_assets/trout_award_1764648146923.png"
                                    alt="Mike Trout Award" class="award-header-image"></span> Mike Trout Award (Highest
                            Scoring Hitter)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="trout-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon"><img src="attached_assets/degom_award_1764648146918.png"
                                    alt="Jacob deGrom Award" class="award-header-image"></span> Jacob deGrom Award
                            (Highest Scoring Pitcher)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody id="degrom-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon">💎</span> Diamond in the Rough Award (Best Draft Value)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Pick</th>
                                        <th>+/-</th>
                                    </tr>
                                </thead>
                                <tbody id="diamond-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="award-section">
                        <h3><span class="award-icon">❌</span> Bust of the Year Award (Worst Draft Value)</h3>
                        <div class="award-table-wrapper">
                            <table class="award-table player-award-table">
                                <thead>
                                    <tr>
                                        <th>Year</th>
                                        <th>Manager</th>
                                        <th>Player</th>
                                        <th>Pick</th>
                                        <th>+/-</th>
                                    </tr>
                                </thead>
                                <tbody id="bust-awards">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Hall of Champions Section -->
        <div id="champions" class="section">
            <h2>🏆 Hall of Champions</h2>

            <div class="season-selector">
                <label for="champions-season">Select Championship Season:</label>
                <select id="champions-season" onchange="loadChampionData()">
                    <!-- Will be populated dynamically -->
                </select>
            </div>

            <div id="champions-loading" class="loading">Loading champion data...</div>
            <div id="champions-error" class="error" style="display: none;"></div>

            <div id="champions-content" style="display: none;">
                <!-- Champion Header -->
                <div id="champion-header" class="champion-header">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Championship Count Banner -->
                <div id="championship-count-banner" class="championship-count-banner">
                    <!-- Will show "1st Championship", "2nd Championship", etc. -->
                </div>

                <!-- Champion Stats Grid -->
                <div class="champion-stats-grid">
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-record">-</div>
                        <div class="stat-label">Record</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-points">-</div>
                        <div class="stat-label">Total Points</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-ppg">-</div>
                        <div class="stat-label">Points/Week</div>
                    </div>
                    <div class="champion-stat-card">
                        <div class="stat-value" id="champion-best-week">-</div>
                        <div class="stat-label">Best Week</div>
                    </div>
                </div>

                <!-- Season Schedule -->
                <div class="champion-section">
                    <h3>📅 Season Schedule</h3>
                    <div class="table-wrapper">
                        <table class="champion-schedule-table">
                            <thead>
                                <tr>
                                    <th>Week</th>
                                    <th>Opponent</th>
                                    <th>Score</th>
                                    <th>Result</th>
                                </tr>
                            </thead>
                            <tbody id="champion-schedule">
                                <!-- Will be populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Championship Roster -->
                <div class="champion-section">
                    <h3>⭐ Championship Roster</h3>
                    <div class="roster-grid" id="champion-roster">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Player Scoring Section -->
        <div id="scoring" class="section">
            <h2>Player Scoring</h2>

            <div class="player-controls">
                <div class="player-control-row">
                    <div class="season-selector">
                        <label for="scoring-season">Season:</label>
                        <select id="scoring-season" onchange="loadPlayerScoring()">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>

                    <div class="stat-type-toggle">
                        <label>Stats:</label>
                        <div class="toggle-buttons">
                            <button id="fantasy-season-btn" class="toggle-btn active"
                                onclick="setStatType('fantasy')">Fantasy Season</button>
                            <button id="full-season-btn" class="toggle-btn" onclick="setStatType('full')">Full MLB
                                Season</button>
                        </div>
                    </div>

                    <div class="position-filter">
                        <label for="position-filter">Position:</label>
                        <select id="position-filter" onchange="filterPlayers()">
                            <option value="all">All Players</option>
                            <option value="B">All Batters</option>
                            <option value="P">All Pitchers</option>
                            <optgroup label="Batting Positions">
                                <option value="C">C - Catcher</option>
                                <option value="1B">1B - First Base</option>
                                <option value="2B">2B - Second Base</option>
                                <option value="3B">3B - Third Base</option>
                                <option value="SS">SS - Shortstop</option>
                                <option value="OF">OF - Outfield</option>
                                <option value="Util">Util - Utility</option>
                            </optgroup>
                            <optgroup label="Pitching Positions">
                                <option value="SP">SP - Starting Pitcher</option>
                                <option value="RP">RP - Relief Pitcher</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="manager-filter">
                        <label for="manager-filter">Manager:</label>
                        <select id="manager-filter" onchange="filterPlayers()">
                            <option value="all">All Managers</option>
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                </div>

                <div class="player-search">
                    <input type="text" id="player-search" placeholder="Search players..." oninput="filterPlayers()">
                </div>
            </div>

            <div id="player-loading" class="loading">Loading player data...</div>
            <div id="player-error" class="error" style="display: none;"></div>

            <div id="player-stats-container" style="display: none;">
                <div class="player-summary">
                    <span id="player-count">0 players</span>
                </div>

                <div class="table-wrapper player-table-wrapper">
                    <table class="player-table" id="player-table">
                        <thead>
                            <tr>
                                <th class="sortable" onclick="sortPlayerTable('rank')">#</th>
                                <th class="sortable" onclick="sortPlayerTable('name')">Player</th>
                                <th>Team</th>
                                <th class="sortable" onclick="sortPlayerTable('position')">Pos</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('PA')">PA</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                                <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                            </tr>
                        </thead>
                        <tbody id="player-table-body">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Player Detail Modal -->
        <div id="player-modal" class="modal">
            <div class="modal-content player-modal-content">
                <span class="modal-close" onclick="closePlayerModal()">&times;</span>
                <div id="player-modal-header">
                    <!-- Header loaded dynamically -->
                </div>
                <div class="modal-body-scroll" id="player-modal-body">
                    <!-- Body content loaded dynamically -->
                </div>
            </div>
        </div>

        <!-- Projection Player Detail Modal -->
        <div id="projection-modal" class="modal">
            <div class="modal-content projection-modal-content">
                <span class="modal-close" onclick="closeProjectionModal()">&times;</span>
                <div class="projection-modal-layout">
                    <div class="projection-card-container" id="projection-card-container">
                        <!-- Baseball card loaded dynamically -->
                    </div>
                    <div class="projection-charts-container">
                        <div class="projection-chart-box">
                            <div class="projection-chart-title">Position Ranking</div>
                            <div class="projection-chart" id="projection-pos-chart">
                                <!-- Position rank chart -->
                            </div>
                        </div>
                        <div class="projection-chart-box">
                            <div class="projection-chart-title" id="projection-scatter-title">Points vs PA</div>
                            <div class="projection-chart" id="projection-scatter-chart">
                                <!-- Scatter plot -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Manager Profiles Section -->
        <div id="managers" class="section">
            <h2>Manager Profiles</h2>

            <div id="managers-loading" class="loading">Loading manager profiles...</div>
            <div id="managers-error" class="error" style="display: none;"></div>

            <div class="manager-grid" id="manager-grid">
            </div>

            <!-- Win Percentage Over Time Chart -->
            <div id="winpct-chart-container" style="display: none; margin-top: 2rem;">
                <h3 style="color: #1e3c72; margin-bottom: 1rem;">📈 Win Percentage Over Time</h3>
                <div id="winpct-chart"
                    style="width: 100%; overflow-x: auto; background: white; border-radius: 8px; padding: 1rem; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                </div>
            </div>
        </div>

        <!-- Preseason Tools Section -->
        <div id="preseason" class="section">
            <h2>⚾ Preseason Tools - Projected Points</h2>

            <div class="player-controls">
                <div class="player-control-row">
                    <div class="projection-selector">
                        <label for="projection-type">Projection System:</label>
                        <select id="projection-type" onchange="loadProjections()">
                            <option value="steamer">Steamer</option>
                            <option value="zips">ZiPS</option>
                            <option value="depthcharts">Depth Charts</option>
                        </select>
                    </div>

                    <div class="position-filter">
                        <label for="proj-position-filter">Position:</label>
                        <select id="proj-position-filter" onchange="filterProjections()">
                            <option value="all">All Players</option>
                            <option value="B">All Batters</option>
                            <option value="P">All Pitchers</option>
                            <optgroup label="Batting Positions">
                                <option value="C">C - Catcher</option>
                                <option value="1B">1B - First Base</option>
                                <option value="2B">2B - Second Base</option>
                                <option value="3B">3B - Third Base</option>
                                <option value="SS">SS - Shortstop</option>
                                <option value="OF">OF - Outfield</option>
                                <option value="DH">DH - Designated Hitter</option>
                            </optgroup>
                            <optgroup label="Pitching Positions">
                                <option value="SP">SP - Starting Pitcher</option>
                                <option value="RP">RP - Relief Pitcher</option>
                            </optgroup>
                        </select>
                    </div>

                    <div class="stat-type-toggle">
                        <label>Player Type:</label>
                        <div class="toggle-buttons">
                            <button id="proj-btn-all" class="toggle-btn active"
                                onclick="setProjectionPlayerType('all')">All</button>
                            <button id="proj-btn-batters" class="toggle-btn"
                                onclick="setProjectionPlayerType('batters')">Batters</button>
                            <button id="proj-btn-pitchers" class="toggle-btn"
                                onclick="setProjectionPlayerType('pitchers')">Pitchers</button>
                        </div>
                    </div>
                </div>

                <div class="player-search">
                    <input type="text" id="proj-player-search" placeholder="Search players..."
                        oninput="filterProjections()">
                </div>
            </div>

            <div id="proj-loading" class="loading" style="display: none;">Loading projections...</div>
            <div id="proj-error" class="error" style="display: none;"></div>
            <div id="proj-no-data" style="text-align: center; padding: 2rem; color: #666;">
                <p style="font-size: 1.1rem; margin-bottom: 1rem;">No projection data available yet.</p>
                <p>Run <code
                        style="background: #f0f0f0; padding: 0.2rem 0.5rem; border-radius: 4px;">python collect_data.py projections</code>
                    to generate projections.</p>
            </div>

            <div id="proj-stats-container" style="display: none;">
                <div class="player-summary" style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span id="proj-player-count">0 players</span>
                        <button class="btn-export"
                            style="margin-left: 1rem; padding: 0.3rem 0.8rem; font-size: 0.8rem; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;"
                            onclick="exportProjectionsCSV()">Export CSV</button>
                        <button id="btn-toggle-kept" onclick="toggleKeptPlayers()"
                            style="margin-left: 0.5rem; padding: 0.3rem 0.8rem; font-size: 0.8rem; background: #e9ecef; color: #333; border: 1px solid #ced4da; border-radius: 4px; cursor: pointer;">Hide
                            Kept Players</button>
                    </div>
                    <button class="btn-select-keepers" onclick="openKeeperModal()">🔒 Select Keepers</button>
                </div>

                <div class="proj-table-scrollable">
                    <table class="player-table" id="proj-table">
                        <thead id="proj-table-head">
                            <!-- Headers will be populated dynamically -->
                        </thead>
                        <tbody id="proj-table-body">
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- League Keepers Section -->
            <div style="margin-top: 3rem; border-top: 2px solid #e0e0e0; padding-top: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <div style="display: flex; align-items: center; gap: 0.75rem;">
                        <h3 style="color: #1e3c72; margin: 0;">📋 League Keepers</h3>
                        <span id="firebase-status" class="firebase-status disconnected" title="Real-time sync status">
                            <span class="status-dot"></span>
                            <span class="status-text">Offline</span>
                        </span>
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn-adjust-budgets" onclick="openBudgetAdjustmentModal()"
                            title="Manually adjust team budgets">💰 Adjust Budgets</button>
                        <button class="btn-toggle-prospects" id="btn-toggle-prospects"
                            onclick="toggleLeagueProspects()">
                            <span id="toggle-prospects-text">Show Prospects</span>
                        </button>
                    </div>
                </div>
                <div id="keeper-league-loading" class="loading" style="display: none;">Loading keepers...</div>
                <div id="keeper-league-container">
                    <div class="keeper-league-grid" id="keeper-league-grid">
                        <!-- Keeper cards for each team -->
                    </div>
                </div>
            </div>

            <!-- Keeper Value Analysis Section -->
            <div class="keeper-value-section" id="keeper-value-section">
                <div class="keeper-value-header">
                    <h3>📊 Keeper Value Analysis</h3>
                    <div style="font-size: 0.85rem; color: #666;">
                        Comparing keeper projections vs. historical draft pick value (2019-2025)
                    </div>
                </div>

                <div id="keeper-value-loading" class="keeper-value-loading" style="display: none;">
                    Analyzing keeper values...
                </div>

                <div id="keeper-value-content">
                    <!-- Expected Points Chart + Rankings -->
                    <div class="expected-points-container">
                        <div class="expected-points-chart-wrapper">
                            <h4>📈 Expected Points by Draft Round</h4>
                            <div class="expected-points-chart">
                                <canvas id="expected-points-chart"></canvas>
                            </div>
                        </div>
                        <div class="value-rankings-wrapper">
                            <h4>🏆 Team Value Rankings</h4>
                            <table class="value-rankings-table" id="value-rankings-table">
                                <thead>
                                    <tr>
                                        <th>Team</th>
                                        <th>Top Value Players</th>
                                        <th class="sortable-header" data-sort="keeperValue" onclick="sortValueRankings('keeperValue')">Keeper Value <span class="sort-icon">▼</span></th>
                                        <th>Top Picks</th>
                                        <th class="sortable-header" data-sort="draftValue" onclick="sortValueRankings('draftValue')">Draft Value <span class="sort-icon"></span></th>
                                        <th class="sortable-header" data-sort="total" onclick="sortValueRankings('total')" style="text-align: right;">Total <span class="sort-icon"></span></th>
                                    </tr>
                                </thead>
                                <tbody id="value-rankings-body">
                                    <!-- Populated by JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Team Value Cards -->
                    <h4 style="color: #1e3c72; margin: 1.5rem 0 1rem;">📋 Team Keeper Breakdown</h4>
                    <div class="team-value-grid" id="team-value-grid">
                        <!-- Populated by JS -->
                    </div>

                    <!-- Prospects Section -->
                    <div class="prospects-value-section" id="prospects-value-section" style="display: none;">
                        <h4>🌟 Prospect Value (Free Keepers)</h4>
                        <p style="font-size: 0.85rem; color: #666; margin: 0 0 1rem;">
                            Prospects cost nothing to keep, so their entire projection is pure value.
                        </p>
                        <div class="prospects-grid" id="prospects-value-grid">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <!-- Scatter Plot -->
                    <div class="value-scatter-wrapper">
                        <h4>🎯 All Keepers: Projected Points vs. Keeper Cost</h4>
                        <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.75rem;">
                            Hover over points to see player details. Green = above expected, Red = below expected.
                        </div>
                        <div class="value-scatter-chart">
                            <canvas id="value-scatter-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Trade Management Section -->
            <div style="margin-top: 3rem; border-top: 2px solid #e0e0e0; padding-top: 2rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                    <h3 style="color: #1e3c72; margin: 0;">🔄 Trade Management</h3>
                    <div style="display: flex; gap: 0.5rem;">
                        <button class="btn-export-trades" onclick="exportTradesForSite()"
                            title="Export JSON for GitHub">📤 Export for Site</button>
                        <button class="btn-new-trade" onclick="openTradeBuilder()">+ New Trade</button>
                    </div>
                </div>

                <!-- Existing Trades List - Scrollable -->
                <div id="trades-list-container" class="trades-list-scrollable">
                    <div id="trades-list" class="trades-list">
                        <!-- Trade cards will be populated here -->
                        <p class="no-trades" id="no-trades-msg">No trades recorded yet. Click "New Trade" to add one.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Trades Modal -->
    <div id="export-trades-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="keeper-modal-close" onclick="closeExportModal()">&times;</span>
            <div class="trade-modal-header">
                <h2>📤 Export Trades for Site</h2>
                <p>Copy this JSON and save it to <code>data/keepers/trades_2026.json</code> in your repository.</p>
            </div>
            <div style="padding: 1.5rem;">
                <textarea id="export-json-content" readonly
                    style="width: 100%; height: 300px; font-family: monospace; font-size: 0.85rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa;"></textarea>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button class="keeper-cancel-btn" onclick="closeExportModal()">Close</button>
                    <button class="keeper-submit-btn" onclick="copyExportJson()">📋 Copy to Clipboard</button>
                    <button class="keeper-submit-btn" onclick="downloadExportJson()"
                        style="background: linear-gradient(135deg, #1e3c72, #2a5298);">💾 Download File</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Budget Adjustment Modal -->
    <div id="budget-adjustment-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="keeper-modal-close" onclick="closeBudgetModal()">&times;</span>
            <div class="trade-modal-header">
                <h2>💰 Adjust Team Budgets</h2>
                <p>Manually adjust keeper budgets for each team. Export to share with all managers.</p>
            </div>
            <div style="padding: 1.5rem;">
                <div id="budget-adjustment-list" style="max-height: 350px; overflow-y: auto;">
                    <!-- Team budget rows will be populated here -->
                </div>
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">
                    <div style="display: flex; gap: 1rem; justify-content: space-between; align-items: center;">
                        <button class="keeper-cancel-btn" onclick="resetAllBudgets()"
                            style="background: #dc3545; color: white;">Reset All</button>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn-export-trades" onclick="exportBudgetsForSite()">📤 Export for
                                Site</button>
                            <button class="keeper-cancel-btn" onclick="closeBudgetModal()">Cancel</button>
                            <button class="keeper-submit-btn" onclick="saveBudgetAdjustments()">💾 Save</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Budgets Modal -->
    <div id="export-budgets-modal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <span class="keeper-modal-close" onclick="closeExportBudgetsModal()">&times;</span>
            <div class="trade-modal-header">
                <h2>📤 Export Budget Adjustments</h2>
                <p>Copy this JSON and save it to <code>data/keepers/budget_adjustments_2026.json</code> in your
                    repository.</p>
            </div>
            <div style="padding: 1.5rem;">
                <textarea id="export-budgets-json-content" readonly
                    style="width: 100%; height: 300px; font-family: monospace; font-size: 0.85rem; padding: 1rem; border: 1px solid #ddd; border-radius: 8px; background: #f8f9fa;"></textarea>
                <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: flex-end;">
                    <button class="keeper-cancel-btn" onclick="closeExportBudgetsModal()">Close</button>
                    <button class="keeper-submit-btn" onclick="copyExportBudgetsJson()">📋 Copy to Clipboard</button>
                    <button class="keeper-submit-btn" onclick="downloadExportBudgetsJson()"
                        style="background: linear-gradient(135deg, #1e3c72, #2a5298);">💾 Download File</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Trade Builder Modal -->
    <div id="trade-modal" class="modal">
        <div class="modal-content trade-modal-content">
            <span class="keeper-modal-close" onclick="closeTradeModal()">&times;</span>

            <div class="trade-modal-header">
                <h2>🔄 Create Trade</h2>
                <p>Select two teams and add assets to each side of the trade.</p>
            </div>

            <div class="trade-builder">
                <!-- Team A Side -->
                <div class="trade-side" id="trade-side-a">
                    <div class="trade-team-selector">
                        <label>Team A:</label>
                        <select id="trade-team-a" onchange="onTradeTeamSelect('a')">
                            <option value="">-- Select Team --</option>
                        </select>
                    </div>

                    <div class="trade-team-info" id="trade-team-a-info" style="display: none;">
                        <div class="trade-budget-display">
                            Budget: <span id="trade-budget-a">$50</span>
                        </div>
                    </div>

                    <div class="trade-assets" id="trade-assets-a">
                        <!-- Assets Team A is giving up -->
                    </div>

                    <div class="trade-add-asset" id="trade-add-asset-a" style="display: none;">
                        <select id="trade-asset-type-a" onchange="onAssetTypeChange('a')">
                            <option value="">+ Add Asset</option>
                            <option value="player">Player</option>
                            <option value="pick">Draft Pick</option>
                            <option value="money">Budget $</option>
                        </select>

                        <div id="trade-asset-selector-a" class="trade-asset-selector" style="display: none;">
                            <!-- Dynamic selector based on asset type -->
                        </div>
                    </div>
                </div>

                <!-- Trade Arrow -->
                <div class="trade-arrow">
                    <span>⇄</span>
                </div>

                <!-- Team B Side -->
                <div class="trade-side" id="trade-side-b">
                    <div class="trade-team-selector">
                        <label>Team B:</label>
                        <select id="trade-team-b" onchange="onTradeTeamSelect('b')">
                            <option value="">-- Select Team --</option>
                        </select>
                    </div>

                    <div class="trade-team-info" id="trade-team-b-info" style="display: none;">
                        <div class="trade-budget-display">
                            Budget: <span id="trade-budget-b">$50</span>
                        </div>
                    </div>

                    <div class="trade-assets" id="trade-assets-b">
                        <!-- Assets Team B is giving up -->
                    </div>

                    <div class="trade-add-asset" id="trade-add-asset-b" style="display: none;">
                        <select id="trade-asset-type-b" onchange="onAssetTypeChange('b')">
                            <option value="">+ Add Asset</option>
                            <option value="player">Player</option>
                            <option value="pick">Draft Pick</option>
                            <option value="money">Budget $</option>
                        </select>

                        <div id="trade-asset-selector-b" class="trade-asset-selector" style="display: none;">
                            <!-- Dynamic selector based on asset type -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="trade-modal-footer">
                <div class="trade-notes">
                    <label for="trade-notes">Trade Notes (optional):</label>
                    <input type="text" id="trade-notes"
                        placeholder="e.g., Part of larger deal, future considerations...">
                </div>
                <div class="trade-modal-actions">
                    <button class="keeper-cancel-btn" onclick="closeTradeModal()">Cancel</button>
                    <button class="keeper-submit-btn" onclick="submitTrade()" id="trade-submit-btn" disabled>Record
                        Trade</button>
                </div>
            </div>
        </div>
    </div>
    <div id="keeper-modal" class="modal">
        <div class="modal-content keeper-modal-content">
            <span class="keeper-modal-close" onclick="closeKeeperModal()">&times;</span>

            <!-- Auth Section -->
            <div id="keeper-modal-auth" class="keeper-modal-auth">
                <h2>🔒 Select Your Keepers</h2>
                <p style="color: #666; margin-bottom: 1.5rem;">Select your team and enter your password to manage your
                    keepers.</p>

                <div class="keeper-auth-form">
                    <div class="keeper-auth-field">
                        <label for="keeper-team-select">Your Team:</label>
                        <select id="keeper-team-select" onchange="onKeeperTeamSelect()">
                            <option value="">-- Select Team --</option>
                        </select>
                    </div>
                    <div class="keeper-auth-field" id="keeper-password-field" style="display: none;">
                        <label for="keeper-password">Password:</label>
                        <input type="password" id="keeper-password" placeholder="Enter password"
                            onkeypress="if(event.key === 'Enter') authenticateKeeper()">
                        <button class="keeper-auth-btn" onclick="authenticateKeeper()">Unlock</button>
                    </div>
                </div>
                <div id="keeper-auth-error" class="keeper-auth-error" style="display: none;"></div>
            </div>

            <!-- Selection Section (hidden until authenticated) -->
            <div id="keeper-modal-selection" style="display: none;">

                <!-- Fixed Header -->
                <div class="keeper-modal-header">
                    <div class="keeper-header-left">
                        <img id="keeper-team-logo" class="keeper-header-logo" src="" alt="">
                        <div class="keeper-header-info">
                            <h2 id="keeper-current-team"></h2>
                            <div class="keeper-progress-container">
                                <div id="keeper-progress-bar" class="keeper-progress-bar"></div>
                            </div>
                            <span class="keeper-status" id="keeper-status">0 / 5 keepers selected</span>
                        </div>
                    </div>
                    <!-- Switch Team button moved under close button -->
                    <div class="keeper-header-actions">
                        <button class="keeper-switch-btn" onclick="logoutKeeper()">Switch Team</button>
                    </div>
                </div>

                <!-- Two Column Layout: Roster + Draft Picks -->
                <div class="keeper-selection-body">
                    <!-- Left: Scrollable Roster Section -->
                    <div class="keeper-roster-section">
                        <p style="color: #666; margin-bottom: 1rem;">Select players from your 2025 roster to keep.
                            Budget: <strong>$50</strong>. Player costs are based on draft round.</p>
                        <div id="keeper-roster-loading" class="loading" style="display: none;">Loading roster...</div>
                        <div class="keeper-roster-table-wrapper">
                            <table class="player-table keeper-table" id="keeper-roster-table">
                                <thead>
                                    <tr>
                                        <th style="width: 40px;">Keep</th>
                                        <th class="sortable" data-sort="name">Player</th>
                                        <th class="sortable" data-sort="position">Pos</th>
                                        <th class="sortable" data-sort="pts2025">2025</th>
                                        <th class="sortable" data-sort="pts2026">2026</th>
                                        <th class="sortable" data-sort="drafted" style="width: 55px;">Drafted</th>
                                        <th class="sortable" data-sort="rdcost" style="width: 55px;">Rd Cost</th>
                                        <th class="sortable" data-sort="cost" style="width: 50px;">Cost</th>
                                    </tr>
                                </thead>
                                <tbody id="keeper-roster-body">
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Right: Draft Picks Visualization -->
                    <div class="keeper-picks-section">
                        <div class="keeper-picks-header">
                            <h4>📋 Your 2026 Draft Picks</h4>
                            <button class="keeper-toggle-traded-btn" id="keeper-toggle-traded"
                                onclick="toggleTradedPicks()">
                                <span id="toggle-traded-text">Show Traded</span>
                            </button>
                        </div>
                        <div class="keeper-picks-grid" id="keeper-picks-grid">
                            <!-- Pick boxes will be populated dynamically -->
                        </div>
                    </div>
                </div>

                <!-- Fixed Footer with Submit -->
                <div class="keeper-modal-footer">
                    <div class="keeper-selected-summary" id="keeper-selected-summary">
                        <span class="no-selection">No keepers selected. Check the boxes next to players you want to
                            keep.</span>
                    </div>
                    <div class="keeper-modal-actions">
                        <button class="keeper-cancel-btn" onclick="closeKeeperModal()">Cancel</button>
                        <button class="keeper-submit-btn" onclick="submitKeepers()" id="keeper-submit-btn"
                            disabled>Submit Keepers</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Manager Detail Modal -->
    <div id="manager-modal" class="modal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeManagerModal()">&times;</span>
            <div id="modal-header-section">
                <!-- Header loaded dynamically -->
            </div>
            <div class="modal-body-scroll" id="modal-body">
                <!-- Body content loaded dynamically -->
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; 2024 Yahoo Fantasy Baseball League | Powered by Python & Yahoo Fantasy API</p>
    </footer>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <script>
        // ===== GLOBAL STATE =====
        let availableSeasons = [];
        let allManagersData = [];
        let managerHistoryData = [];
        let managerAwardsData = {}; // Store manager awards globally
        let currentTableMode = 'all'; // 'all', 'batters', or 'pitchers'

        // Player scoring state
        let allPlayersData = [];
        let filteredPlayersData = [];
        let playerHistoryData = {};
        let currentPlayerSort = { column: 'fantasy_points', direction: 'desc' };
        let currentStatType = 'fantasy'; // 'fantasy' for fantasy season, 'full' for full MLB season

        // Chart state
        let currentChartData = null;
        let currentChartType = 'weekly'; // 'weekly' or 'total'

        // Cache for team data to avoid redundant fetches
        const teamDataCache = {};

        // Cache for player stats data to avoid redundant fetches for rank calculations
        const playerStatsCache = {};

        // Helper function to get player stats data with caching
        async function getPlayerStatsData(year) {
            const cacheKey = year === 2025 ? 'current' : year;

            if (playerStatsCache[cacheKey]) {
                return playerStatsCache[cacheKey];
            }

            try {
                let statsPath = year === 2025
                    ? 'data/current_season/player_stats.json'
                    : `data/historical/${year}/player_stats.json`;
                const response = await fetch(statsPath);
                if (response.ok) {
                    const data = await response.json();
                    playerStatsCache[cacheKey] = data;
                    return data;
                }
            } catch (e) {
                console.log(`Could not load player stats for ${year}`);
            }
            return null;
        }

        // Helper function to get team data with caching
        async function getTeamData(year) {
            const cacheKey = year === 2025 ? 'current' : year;

            if (teamDataCache[cacheKey]) {
                return teamDataCache[cacheKey];
            }

            try {
                let teamsResponse;
                if (year === 2025) {
                    teamsResponse = await fetch('data/current_season/teams.json');
                } else {
                    teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                }

                if (teamsResponse.ok) {
                    const teams = await teamsResponse.json();
                    teamDataCache[cacheKey] = teams;
                    return teams;
                }
            } catch (e) {
                console.log(`Could not load team data for ${year}`);
            }

            return null;
        }

        // ===== PLAYER SCORING FUNCTIONS =====

        async function loadPlayerScoring() {
            const seasonSelect = document.getElementById('scoring-season');
            const selectedYear = parseInt(seasonSelect.value);

            const loadingEl = document.getElementById('player-loading');
            const errorEl = document.getElementById('player-error');
            const containerEl = document.getElementById('player-stats-container');

            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            containerEl.style.display = 'none';

            try {
                // Determine the path based on year
                let playerStatsPath;
                if (selectedYear === 2025) {
                    playerStatsPath = 'data/current_season/player_stats.json';
                } else {
                    playerStatsPath = `data/historical/${selectedYear}/player_stats.json`;
                }

                const response = await fetch(playerStatsPath);
                if (!response.ok) {
                    throw new Error(`No player data available for ${selectedYear}`);
                }

                allPlayersData = await response.json();

                // Calculate position ranks for each player
                calculatePositionRanks();

                // Populate manager filter
                populateManagerFilter();

                // Apply filters and render
                filterPlayers();

                loadingEl.style.display = 'none';
                containerEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading player data:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function calculatePositionRanks() {
            // Define all positions to rank
            const positions = ['C', '1B', '2B', '3B', 'SS', 'OF', 'Util', 'SP', 'RP', 'P'];

            // For each position, sort eligible players by fantasy points and assign ranks
            positions.forEach(pos => {
                // Get players eligible for this position
                let eligiblePlayers;
                if (pos === 'P') {
                    // P includes all pitchers
                    eligiblePlayers = allPlayersData.filter(p => p.position_type === 'P');
                } else {
                    eligiblePlayers = allPlayersData.filter(p =>
                        p.eligible_positions && p.eligible_positions.includes(pos)
                    );
                }

                // Sort by fantasy points descending (using current stat type)
                eligiblePlayers.sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));

                // Assign ranks
                eligiblePlayers.forEach((player, index) => {
                    if (!player.position_ranks) {
                        player.position_ranks = {};
                    }
                    player.position_ranks[pos] = index + 1;
                });
            });

            // Also calculate overall batter and pitcher ranks
            const batters = allPlayersData.filter(p => p.position_type === 'B')
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            batters.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['B'] = index + 1;
            });

            const pitchers = allPlayersData.filter(p => p.position_type === 'P')
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            pitchers.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['P'] = index + 1;
            });
        }

        function getPositionWithRank(player) {
            const positionFilter = document.getElementById('position-filter').value;
            const pos = player.primary_position || '-';

            if (!player.position_ranks) return pos;

            // Determine which position rank to show based on filter
            let rankPos;
            let displayPos;

            if (positionFilter === 'all') {
                // Show primary position rank
                rankPos = pos;
                displayPos = pos;
            } else if (positionFilter === 'B') {
                // Show overall batter rank with primary position
                rankPos = 'B';
                displayPos = pos;
            } else if (positionFilter === 'P') {
                // Show overall pitcher rank with primary position
                rankPos = 'P';
                displayPos = pos;
            } else {
                // Specific position filter - show that position's rank
                rankPos = positionFilter;
                displayPos = positionFilter;
            }

            const rank = player.position_ranks[rankPos];
            if (rank) {
                return `${displayPos}${rank}`;
            }
            return pos;
        }

        function populateManagerFilter() {
            const managerFilter = document.getElementById('manager-filter');
            const managers = [...new Set(allPlayersData.map(p => p.manager))].sort();

            // Keep the "All Managers" option and add the rest
            managerFilter.innerHTML = '<option value="all">All Managers</option>';
            managers.forEach(manager => {
                const option = document.createElement('option');
                option.value = manager;
                option.textContent = manager;
                managerFilter.appendChild(option);
            });
        }

        function setStatType(type) {
            currentStatType = type;

            // Update button states
            document.getElementById('fantasy-season-btn').classList.toggle('active', type === 'fantasy');
            document.getElementById('full-season-btn').classList.toggle('active', type === 'full');

            // Re-calculate position ranks and re-render
            calculatePositionRanks();
            filterPlayers();
        }

        function setModalStatType(type) {
            currentStatType = type;

            // Update main page toggle buttons too
            document.getElementById('fantasy-season-btn').classList.toggle('active', type === 'fantasy');
            document.getElementById('full-season-btn').classList.toggle('active', type === 'full');

            // Update modal toggle buttons
            document.querySelectorAll('.card-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase().includes(type === 'fantasy' ? 'fantasy' : 'full'));
            });

            // Re-render the modal with the current player
            if (window.currentModalPlayer) {
                updateModalStats(window.currentModalPlayer);
            }

            // Re-calculate position ranks and re-render main table
            calculatePositionRanks();
            filterPlayers();
        }

        function updateModalStats(player) {
            const stats = getPlayerStats(player);
            const fantasyPts = getPlayerFantasyPoints(player);
            const isBatter = player.position_type === 'B';

            // Update points display in the card
            const ptsEl = document.querySelector('.card-fantasy-points');
            if (ptsEl) {
                ptsEl.innerHTML = `${fantasyPts.toFixed(1)}<span class="pts-label">PTS</span>`;
            }

            // Update position rank
            const primaryPos = player.primary_position;
            const samePos = allPlayersData
                .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            const posRank = samePos.findIndex(p => p.name === player.name) + 1;
            const posRankDisplay = posRank > 0 ? `${primaryPos}${posRank}` : primaryPos;

            const rankEl = document.querySelector('.card-position-rank');
            if (rankEl) {
                rankEl.textContent = posRankDisplay;
            }

            // Update stats table
            const statsContent = document.getElementById('modal-stats-content');
            if (statsContent) {
                if (isBatter) {
                    statsContent.innerHTML = `
                        <table class="card-stats-table">
                            <tr>
                                <th>G</th><th>AB</th><th>H</th><th>HR</th><th>RBI</th><th>R</th><th>SB</th>
                            </tr>
                            <tr>
                                <td>${stats.G || 0}</td>
                                <td>${stats.AB || 0}</td>
                                <td>${stats.H || 0}</td>
                                <td>${stats.HR || 0}</td>
                                <td>${stats.RBI || 0}</td>
                                <td>${stats.R || 0}</td>
                                <td>${stats.SB || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>2B</th><th>3B</th><th>AVG</th><th>OBP</th><th>SLG</th><th>OPS</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats['2B'] || 0}</td>
                                <td>${stats['3B'] || 0}</td>
                                <td>${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</td>
                                <td>${stats.OBP ? stats.OBP.toFixed(3) : '.000'}</td>
                                <td>${stats.SLG ? stats.SLG.toFixed(3) : '.000'}</td>
                                <td>${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</td>
                            </tr>
                        </table>`;
                } else {
                    statsContent.innerHTML = `
                        <table class="card-stats-table">
                            <tr>
                                <th>W</th><th>L</th><th>SV</th><th>G</th><th>GS</th><th>IP</th><th>K</th>
                            </tr>
                            <tr>
                                <td>${stats.W || 0}</td>
                                <td>${stats.L || 0}</td>
                                <td>${stats.SV || 0}</td>
                                <td>${stats.G || 0}</td>
                                <td>${stats.GS || 0}</td>
                                <td>${stats.IP || 0}</td>
                                <td>${stats.SO || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>ERA</th><th>WHIP</th><th>K/9</th><th>K%</th><th>BB%</th><th>HLD</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</td>
                                <td>${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</td>
                                <td>${stats['K/9'] ? stats['K/9'].toFixed(1) : '0.0'}</td>
                                <td>${stats['K%'] ? stats['K%'].toFixed(0) : '0'}%</td>
                                <td>${stats['BB%'] ? stats['BB%'].toFixed(0) : '0'}%</td>
                                <td>${stats.HLD || 0}</td>
                            </tr>
                        </table>`;
                }
            }
        }

        function getPlayerStats(player) {
            // Returns the appropriate stats object based on currentStatType
            if (currentStatType === 'full') {
                return player.full_season_stats || player.stats || {};
            }
            return player.stats || {};
        }

        function getPlayerFantasyPoints(player) {
            // Returns the appropriate fantasy points based on currentStatType
            if (currentStatType === 'full') {
                return player.full_season_fantasy_points || player.fantasy_points || 0;
            }
            return player.fantasy_points || 0;
        }

        function filterPlayers() {
            const positionFilter = document.getElementById('position-filter').value;
            const managerFilter = document.getElementById('manager-filter').value;
            const searchQuery = document.getElementById('player-search').value.toLowerCase().trim();

            // 1. DETERMINE TABLE MODE
            if (positionFilter === 'P' || positionFilter === 'SP' || positionFilter === 'RP') {
                currentTableMode = 'pitchers';
            } else if (positionFilter === 'B' || ['C', '1B', '2B', '3B', 'SS', 'OF', 'Util'].includes(positionFilter)) {
                currentTableMode = 'batters';
            } else {
                currentTableMode = 'all';
            }

            filteredPlayersData = allPlayersData.filter(player => {
                // Position filter
                if (positionFilter !== 'all') {
                    if (positionFilter === 'B' || positionFilter === 'P') {
                        if (player.position_type !== positionFilter) return false;
                    } else {
                        // Specific position
                        if (!player.eligible_positions.includes(positionFilter)) return false;
                    }
                }

                // Manager filter
                if (managerFilter !== 'all' && player.manager !== managerFilter) {
                    return false;
                }

                // Search filter
                if (searchQuery) {
                    const nameMatch = player.name.toLowerCase().includes(searchQuery);
                    const teamMatch = player.team_name.toLowerCase().includes(searchQuery);
                    const mlbMatch = (player.mlb_team || '').toLowerCase().includes(searchQuery);
                    if (!nameMatch && !teamMatch && !mlbMatch) return false;
                }

                return true;
            });

            // Apply current sort
            sortPlayersArray();

            // 2. REBUILD HEADERS BASED ON MODE
            updateTableHeaders();

            // Render the table
            renderPlayerTable();
        }

        function updateTableHeaders() {
            const thead = document.querySelector('#player-table thead');
            let headerHTML = `
                <tr>
                    <th class="sortable" onclick="sortPlayerTable('rank')">#</th>
                    <th class="sortable" onclick="sortPlayerTable('name')">Player</th>
                    <th>Team</th>
                    <th class="sortable" onclick="sortPlayerTable('position')">Pos</th>
            `;

            if (currentTableMode === 'batters') {
                // BATTER SPECIFIC HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('AVG')">AVG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('AB')">AB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('H')">H</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('RBI')">RBI</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SB')">SB</th>
                `;
            } else if (currentTableMode === 'pitchers') {
                // PITCHER SPECIFIC HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('GS')">GS</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('WHIP')">WHIP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('K%')">K%</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB%')">BB%</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SV')">SV</th>
                `;
            } else {
                // ALL PLAYERS (DEFAULT) HEADERS
                headerHTML += `
                    <th class="sortable stat-col" onclick="sortPlayerTable('fantasy_points')">Pts</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('G')">G</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PPG')">PPG</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('IP')">IP</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('ERA')">ERA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('W')">W</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('SO')">K</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('BB')">BB</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('PA')">PA</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('HR')">HR</th>
                    <th class="sortable stat-col" onclick="sortPlayerTable('OPS')">OPS</th>
                `;
            }

            headerHTML += `</tr>`;
            thead.innerHTML = headerHTML;
        }

        function sortPlayerTable(column) {
            // Toggle direction if same column
            if (currentPlayerSort.column === column) {
                currentPlayerSort.direction = currentPlayerSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentPlayerSort.column = column;
                // Default to descending for stats, ascending for name
                currentPlayerSort.direction = (column === 'name' || column === 'position') ? 'asc' : 'desc';
            }

            sortPlayersArray();
            renderPlayerTable();
            updateSortIndicators();
        }

        function sortPlayersArray() {
            const { column, direction } = currentPlayerSort;

            filteredPlayersData.sort((a, b) => {
                let aVal, bVal;
                const aStats = getPlayerStats(a);
                const bStats = getPlayerStats(b);
                const aPoints = getPlayerFantasyPoints(a);
                const bPoints = getPlayerFantasyPoints(b);

                if (column === 'rank') {
                    // Rank is determined by fantasy points
                    aVal = aPoints;
                    bVal = bPoints;
                } else if (column === 'name') {
                    aVal = a.name.toLowerCase();
                    bVal = b.name.toLowerCase();
                } else if (column === 'position') {
                    aVal = a.primary_position || '';
                    bVal = b.primary_position || '';
                } else if (column === 'fantasy_points') {
                    aVal = aPoints;
                    bVal = bPoints;
                } else if (column === 'PPG') {
                    // Points Per Game = fantasy_points / G
                    const aGames = aStats.G || 0;
                    const bGames = bStats.G || 0;
                    aVal = aGames > 0 ? aPoints / aGames : 0;
                    bVal = bGames > 0 ? bPoints / bGames : 0;
                } else {
                    // Stat column
                    aVal = aStats[column] || 0;
                    bVal = bStats[column] || 0;
                }

                if (typeof aVal === 'string') {
                    return direction === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                }

                return direction === 'asc' ? aVal - bVal : bVal - aVal;
            });
        }

        function updateSortIndicators() {
            // Remove all sort indicators
            document.querySelectorAll('.player-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add indicator to current sort column
            const headers = document.querySelectorAll('.player-table th');
            headers.forEach(th => {
                const onclick = th.getAttribute('onclick');
                if (onclick && onclick.includes(`'${currentPlayerSort.column}'`)) {
                    th.classList.add(currentPlayerSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function renderPlayerTable() {
            const tbody = document.getElementById('player-table-body');
            const countEl = document.getElementById('player-count');

            countEl.textContent = `${filteredPlayersData.length} player${filteredPlayersData.length !== 1 ? 's' : ''}`;

            if (filteredPlayersData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; padding: 2rem; color: #666;">No players found matching your criteria</td></tr>';
                return;
            }

            // Base64 encoded placeholder
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            tbody.innerHTML = filteredPlayersData.map((player, index) => {
                const stats = getPlayerStats(player);
                const fantasyPoints = getPlayerFantasyPoints(player);
                const isBatter = player.position_type === 'B';
                const headshot = (player.headshot_url && player.headshot_url.trim()) ? player.headshot_url : placeholderImg;

                // Calculate PPG
                const games = stats.G || 0;
                const ppg = games > 0 ? (fantasyPoints / games).toFixed(2) : '-';

                // Get MLB logo URL and normalize team display
                const mlbLogoUrl = getMLBTeamLogo(player.mlb_team);
                const mlbTeamText = formatMLBTeamDisplay(player.mlb_team);
                const hasMlbLogo = mlbTeamText !== 'FA' && mlbLogoUrl;
                const mlbLogoHtml = hasMlbLogo
                    ? `<img src="${mlbLogoUrl}" alt="" class="player-mlb-logo" onerror="this.style.display='none'">`
                    : '';

                // Check if player is on a fantasy team
                const hasFantasyTeam = player.team_key && player.team_key.trim() && player.team_name && player.team_name !== 'Free Agent' && player.team_name !== 'Drafted (Dropped)' && player.team_name !== 'Previously Rostered';
                const fantasyTeamHtml = hasFantasyTeam
                    ? `<img src="${player.team_logo}" alt="" class="player-team-logo" onerror="this.style.display='none'">
                       <span class="player-fantasy-team" title="${player.team_name}">${player.manager}</span>`
                    : '<span class="player-fantasy-team">FA</span>';

                // Common cells (Rank, Name, Team, Pos)
                let rowHTML = `
                    <tr>
                        <td>${index + 1}</td>
                        <td>
                            <div class="player-name-cell" onclick="showPlayerDetail('${player.name.replace(/'/g, "\\'")}')">
                                <img src="${headshot}" alt="" class="player-headshot" onerror="this.src='${placeholderImg}'">
                                <div>
                                    <div class="player-name">${player.name}</div>
                                    <div class="player-mlb-team">${mlbLogoHtml}${mlbTeamText}</div>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="player-team-cell">
                                ${fantasyTeamHtml}
                            </div>
                        </td>
                        <td class="player-position">${getPositionWithRank(player)}</td>
                `;

                // STAT CELLS BASED ON MODE
                if (currentTableMode === 'batters') {
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${stats.AVG ? stats.AVG.toFixed(3) : '-'}</td>
                        <td class="stat-col">${stats.OPS ? stats.OPS.toFixed(3) : '-'}</td>
                        <td class="stat-col">${stats.AB || '-'}</td>
                        <td class="stat-col">${stats.H || '-'}</td>
                        <td class="stat-col">${stats.HR || '-'}</td>
                        <td class="stat-col">${stats.RBI || '-'}</td>
                        <td class="stat-col">${stats.SB || '-'}</td>
                    `;
                } else if (currentTableMode === 'pitchers') {
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${stats.GS || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${stats.IP || '-'}</td>
                        <td class="stat-col">${stats.ERA ? stats.ERA.toFixed(2) : '-'}</td>
                        <td class="stat-col">${stats.WHIP ? stats.WHIP.toFixed(2) : '-'}</td>
                        <td class="stat-col">${stats.SO || '-'}</td>
                        <td class="stat-col">${stats['K%'] ? stats['K%'].toFixed(1) : '-'}</td>
                        <td class="stat-col">${stats.BB || '-'}</td>
                        <td class="stat-col">${stats['BB%'] ? stats['BB%'].toFixed(1) : '-'}</td>
                        <td class="stat-col">${stats.W || '-'}</td>
                        <td class="stat-col">${stats.SV || '-'}</td>
                    `;
                } else {
                    // ALL PLAYERS
                    rowHTML += `
                        <td class="player-points">${fantasyPoints.toFixed(1)}</td>
                        <td class="stat-col">${games || '-'}</td>
                        <td class="stat-col">${ppg}</td>
                        <td class="stat-col">${!isBatter ? (stats.IP || '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.ERA ? stats.ERA.toFixed(2) : '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.W || '-') : '-'}</td>
                        <td class="stat-col">${!isBatter ? (stats.SO || '-') : '-'}</td>
                        <td class="stat-col">${stats.BB || '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.PA || '-') : '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.HR || '-') : '-'}</td>
                        <td class="stat-col">${isBatter ? (stats.OPS ? stats.OPS.toFixed(3) : '-') : '-'}</td>
                    `;
                }

                rowHTML += `</tr>`;
                return rowHTML;
            }).join('');

            updateSortIndicators();
        }

        // MLB Team abbreviation to ESPN CDN logo mapping
        // Helper function to normalize and format MLB team display
        function formatMLBTeamDisplay(mlbTeam) {
            if (!mlbTeam || !mlbTeam.trim()) return 'FA';

            // Standard abbreviation mapping for display normalization
            const displayMap = {
                // Teams with alternate abbreviations that should be normalized
                'TBR': 'TB', 'TAM': 'TB',
                'CHW': 'CWS',
                'KCR': 'KC',
                'ANA': 'LAA',
                'FLA': 'MIA',
                'WAS': 'WSH', 'WSN': 'WSH',
                'AZ': 'ARI',
                'SDP': 'SD',
                'SFG': 'SF'
            };

            // Split by comma for multi-team players
            const teams = mlbTeam.split(',').map(t => {
                const trimmed = t.trim().toUpperCase();
                return displayMap[trimmed] || trimmed;
            });

            return teams.join(', ');
        }

        function getMLBTeamLogo(mlbTeam, playerPosition) {
            if (!mlbTeam) return null;

            // Normalize input - for multi-team players (e.g., "ARI, SEA"), use the last team
            let team = mlbTeam.trim();
            if (team.includes(',')) {
                const teams = team.split(',').map(t => t.trim());
                team = teams[teams.length - 1]; // Use last/current team
            }

            // Direct abbreviation mappings (most reliable)
            // Covers both Fangraphs and Yahoo abbreviation styles
            const abbreviationMap = {
                // American League East
                'BAL': 'bal', 'BOS': 'bos', 'NYY': 'nyy', 'TB': 'tb', 'TBR': 'tb', 'TAM': 'tb', 'TOR': 'tor',
                // American League Central  
                'CWS': 'chw', 'CHW': 'chw', 'CLE': 'cle', 'DET': 'det', 'KC': 'kc', 'KCR': 'kc', 'MIN': 'min',
                // American League West
                'HOU': 'hou', 'LAA': 'laa', 'ANA': 'laa', 'OAK': 'oak', 'ATH': 'oak', 'SEA': 'sea', 'TEX': 'tex',
                // National League East
                'ATL': 'atl', 'MIA': 'mia', 'FLA': 'mia', 'NYM': 'nym', 'PHI': 'phi', 'WSH': 'wsh', 'WAS': 'wsh', 'WSN': 'wsh',
                // National League Central
                'CHC': 'chc', 'CIN': 'cin', 'MIL': 'mil', 'PIT': 'pit', 'STL': 'stl',
                // National League West
                'ARI': 'ari', 'AZ': 'ari', 'COL': 'col', 'LAD': 'lad', 'SD': 'sd', 'SDP': 'sd', 'SF': 'sf', 'SFG': 'sf'
            };

            // Check abbreviation first
            if (abbreviationMap[team]) {
                return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbreviationMap[team]}.png`;
            }

            // Nickname mappings (unambiguous)
            const nicknameMap = {
                'Orioles': 'bal', 'Red Sox': 'bos', 'Yankees': 'nyy', 'Rays': 'tb', 'Blue Jays': 'tor',
                'White Sox': 'chw', 'Guardians': 'cle', 'Indians': 'cle', 'Tigers': 'det', 'Royals': 'kc', 'Twins': 'min',
                'Astros': 'hou', 'Angels': 'laa', 'Athletics': 'oak', "A's": 'oak', 'Mariners': 'sea', 'Rangers': 'tex',
                'Braves': 'atl', 'Marlins': 'mia', 'Mets': 'nym', 'Phillies': 'phi', 'Nationals': 'wsh',
                'Cubs': 'chc', 'Reds': 'cin', 'Brewers': 'mil', 'Pirates': 'pit', 'Cardinals': 'stl',
                'Diamondbacks': 'ari', 'D-backs': 'ari', 'Rockies': 'col', 'Dodgers': 'lad', 'Padres': 'sd', 'Giants': 'sf'
            };

            // Check if team contains a nickname
            for (const [nickname, abbrev] of Object.entries(nicknameMap)) {
                if (team.includes(nickname)) {
                    return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbrev}.png`;
                }
            }

            // Convert to uppercase for case-insensitive city matching
            const teamUpper = team.toUpperCase();

            // Unambiguous city mappings (uppercase for comparison)
            const cityMap = {
                'BALTIMORE': 'bal', 'BOSTON': 'bos', 'TAMPA BAY': 'tb', 'TORONTO': 'tor',
                'CLEVELAND': 'cle', 'DETROIT': 'det', 'KANSAS CITY': 'kc', 'MINNESOTA': 'min',
                'HOUSTON': 'hou', 'OAKLAND': 'oak', 'SEATTLE': 'sea', 'TEXAS': 'tex',
                'ATLANTA': 'atl', 'MIAMI': 'mia', 'PHILADELPHIA': 'phi', 'WASHINGTON': 'wsh',
                'CINCINNATI': 'cin', 'MILWAUKEE': 'mil', 'PITTSBURGH': 'pit', 'ST. LOUIS': 'stl', 'ST LOUIS': 'stl',
                'ARIZONA': 'ari', 'COLORADO': 'col', 'SAN DIEGO': 'sd', 'SAN FRANCISCO': 'sf'
            };

            // Check unambiguous cities
            for (const [city, abbrev] of Object.entries(cityMap)) {
                if (teamUpper.includes(city)) {
                    return `https://a.espncdn.com/i/teamlogos/mlb/500/${abbrev}.png`;
                }
            }

            // Handle ambiguous cities - use MLB logo as fallback or make best guess
            // New York, Los Angeles, Chicago all have 2 teams
            if (teamUpper === 'NEW YORK' || teamUpper === 'NY') {
                // Default to Yankees (more popular), but this is a guess
                return `https://a.espncdn.com/i/teamlogos/mlb/500/nyy.png`;
            }
            if (teamUpper === 'LOS ANGELES' || teamUpper === 'LA') {
                // Default to Dodgers (more popular)
                return `https://a.espncdn.com/i/teamlogos/mlb/500/lad.png`;
            }
            if (teamUpper === 'CHICAGO' || teamUpper === 'CHI') {
                // Default to Cubs (more popular)
                return `https://a.espncdn.com/i/teamlogos/mlb/500/chc.png`;
            }

            return null;
        }

        async function showPlayerDetail(playerName) {
            const modal = document.getElementById('player-modal');
            const headerEl = document.getElementById('player-modal-header');
            const bodyEl = document.getElementById('player-modal-body');

            // Find player in current data
            const player = allPlayersData.find(p => p.name === playerName);
            if (!player) return;

            // Store current player for modal stat toggle
            window.currentModalPlayer = player;

            const seasonSelect = document.getElementById('scoring-season');
            const selectedYear = parseInt(seasonSelect.value);

            // Load player history if not cached
            if (Object.keys(playerHistoryData).length === 0) {
                try {
                    const historyResponse = await fetch('data/players/player_history.json');
                    if (historyResponse.ok) {
                        playerHistoryData = await historyResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load player history');
                }
            }

            // Placeholders
            const placeholderHeadshot = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFlM2M3MiIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZiI+4pqB77iPPC90ZXh0Pjwvc3ZnPg==';

            const headshot = (player.headshot_url && player.headshot_url.trim()) ? player.headshot_url : placeholderHeadshot;
            const mlbLogoUrl = getMLBTeamLogo(player.mlb_team);
            const mlbTeamText = formatMLBTeamDisplay(player.mlb_team);
            const hasMlbLogo = mlbTeamText !== 'FA' && mlbLogoUrl;
            const mlbLogoHtml = hasMlbLogo
                ? `<img src="${mlbLogoUrl}" alt="" class="card-mlb-logo" onerror="this.outerHTML='<div class=\\'card-mlb-fa\\'>FA</div>'">`
                : `<div class="card-mlb-fa">FA</div>`;

            // Check if player has a fantasy team
            const hasFantasyTeam = player.team_key && player.team_key.trim() && player.team_logo && player.team_name && player.team_name !== 'Free Agent' && player.team_name !== 'Drafted (Dropped)' && player.team_name !== 'Previously Rostered';
            const fantasyTeamLogoHtml = hasFantasyTeam
                ? `<img src="${player.team_logo}" alt="" class="card-team-logo-corner" onerror="this.outerHTML='<div class=\\'card-team-fa-corner\\'>FA</div>'">`
                : `<div class="card-team-fa-corner">FA</div>`;

            const stats = getPlayerStats(player);
            const isBatter = player.position_type === 'B';
            const fantasyPts = getPlayerFantasyPoints(player).toFixed(1);

            // Calculate position rank for current season (using current stat type)
            const primaryPos = player.primary_position;
            const samePos = allPlayersData
                .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                .sort((a, b) => getPlayerFantasyPoints(b) - getPlayerFantasyPoints(a));
            const posRank = samePos.findIndex(p => p.name === player.name) + 1;
            const posRankDisplay = posRank > 0 ? `${primaryPos}${posRank}` : primaryPos;

            // Load acquisition info (draft data and transactions)
            // Priority: Trade to current team > Waiver pickup > Draft
            let acquisitionHtml = '';
            let draftInfo = null;
            let tradeInfo = null;
            let pickupInfo = null;

            try {
                // Load draft data
                let draftResponse;
                if (selectedYear === 2025) {
                    draftResponse = await fetch('data/current_season/draft.json');
                } else {
                    draftResponse = await fetch(`data/historical/${selectedYear}/draft.json`);
                }

                if (draftResponse.ok) {
                    const draftData = await draftResponse.json();
                    const draftPick = draftData.find(pick =>
                        pick.player_name && pick.player_name.toLowerCase() === player.name.toLowerCase()
                    );
                    if (draftPick) {
                        draftInfo = { round: draftPick.round, pick: draftPick.pick, team_key: draftPick.team_key };
                    }
                }

                // Load transaction data
                let transResponse;
                if (selectedYear === 2025) {
                    transResponse = await fetch('data/current_season/transactions.json');
                } else {
                    transResponse = await fetch(`data/historical/${selectedYear}/transactions.json`);
                }

                if (transResponse && transResponse.ok) {
                    const transData = await transResponse.json();

                    // Find all transactions involving this player where they were added to current team
                    const playerTransactions = transData.filter(t => {
                        if (!t.players) return false;
                        return t.players.some(p =>
                            p.name && p.name.toLowerCase() === player.name.toLowerCase() &&
                            (p.type === 'add' || p.destination_team_key === player.team_key)
                        );
                    }).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Most recent first

                    // Check for trade to current team
                    for (const trans of playerTransactions) {
                        if (trans.type === 'trade') {
                            const transPlayer = trans.players.find(p =>
                                p.name && p.name.toLowerCase() === player.name.toLowerCase()
                            );
                            // Check if player was added to current team in this trade
                            if (transPlayer && (transPlayer.type === 'add' || transPlayer.destination_team_key === player.team_key)) {
                                let dateStr = '';
                                if (trans.timestamp) {
                                    const date = new Date(trans.timestamp * 1000);
                                    dateStr = `${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
                                }
                                tradeInfo = { date: dateStr };
                                break;
                            }
                        }
                    }

                    // If no trade, check for waiver pickup (only if player wasn't drafted by current team)
                    if (!tradeInfo) {
                        const wasDraftedByCurrentTeam = draftInfo && draftInfo.team_key === player.team_key;

                        if (!wasDraftedByCurrentTeam) {
                            for (const trans of playerTransactions) {
                                if (trans.type === 'add' || trans.type === 'add/drop') {
                                    const transPlayer = trans.players.find(p =>
                                        p.name && p.name.toLowerCase() === player.name.toLowerCase() &&
                                        p.type === 'add'
                                    );
                                    if (transPlayer) {
                                        let dateStr = '';
                                        if (trans.timestamp) {
                                            const date = new Date(trans.timestamp * 1000);
                                            dateStr = `${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
                                        }
                                        pickupInfo = { date: dateStr };
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                // Build acquisition HTML based on priority: Trade > Pickup > Draft
                if (tradeInfo) {
                    acquisitionHtml = `<div class="card-acquisition-corner"><span class="acq-type">Acquired via Trade:</span>${tradeInfo.date}</div>`;
                } else if (pickupInfo) {
                    acquisitionHtml = `<div class="card-acquisition-corner"><span class="acq-type">Picked up:</span>${pickupInfo.date}</div>`;
                } else if (draftInfo) {
                    acquisitionHtml = `<div class="card-acquisition-corner"><span class="acq-type">Drafted:</span>Rd ${draftInfo.round}, #${draftInfo.pick}</div>`;
                }

            } catch (e) {
                console.log('Could not load acquisition info:', e);
            }

            // Clear header (we're using body for the card)
            headerEl.innerHTML = '';

            // Build baseball card HTML
            let cardHTML = `
            <div class="baseball-card">
                <div class="card-header">
                    ${mlbLogoHtml}
                    <div class="card-player-name">${player.name}</div>
                </div>
                
                <div class="card-photo-section">
                    ${fantasyTeamLogoHtml}
                    ${acquisitionHtml}
                    <div class="card-stats-corner">
                        <div class="card-team-badge">${mlbTeamText}</div>
                        <div class="card-fantasy-points">
                            ${fantasyPts}
                            <span class="pts-label">PTS</span>
                        </div>
                        <div class="card-position-rank">${posRankDisplay}</div>
                    </div>
                    <div class="card-photo-frame">
                        <img src="${headshot}" alt="${player.name}" class="card-headshot" onerror="this.src='${placeholderHeadshot}'">
                        <div class="card-position-badge">${player.primary_position}</div>
                    </div>
                </div>

                <div class="card-info-strip">
                    <span>📊 ${selectedYear} Stats</span>
                    <span>${player.eligible_positions ? player.eligible_positions.join('/') : player.primary_position}</span>
                    <span>⚾ ${isBatter ? 'Batter' : 'Pitcher'}</span>
                </div>

                <div class="card-scrollable">
                    <div class="card-stats-section">
                        <div class="card-stats-header">
                            <div class="card-stats-title">${selectedYear} Season Statistics</div>
                            <div class="card-stat-toggle">
                                <button class="card-toggle-btn ${currentStatType === 'fantasy' ? 'active' : ''}" onclick="setModalStatType('fantasy')">Fantasy</button>
                                <button class="card-toggle-btn ${currentStatType === 'full' ? 'active' : ''}" onclick="setModalStatType('full')">Full MLB</button>
                            </div>
                        </div>
                        <div id="modal-stats-content">`;

            if (isBatter) {
                cardHTML += `
                        <table class="card-stats-table">
                            <tr>
                                <th>G</th><th>AB</th><th>H</th><th>HR</th><th>RBI</th><th>R</th><th>SB</th>
                            </tr>
                            <tr>
                                <td>${stats.G || 0}</td>
                                <td>${stats.AB || 0}</td>
                                <td>${stats.H || 0}</td>
                                <td>${stats.HR || 0}</td>
                                <td>${stats.RBI || 0}</td>
                                <td>${stats.R || 0}</td>
                                <td>${stats.SB || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>2B</th><th>3B</th><th>AVG</th><th>OBP</th><th>SLG</th><th>OPS</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats['2B'] || 0}</td>
                                <td>${stats['3B'] || 0}</td>
                                <td>${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</td>
                                <td>${stats.OBP ? stats.OBP.toFixed(3) : '.000'}</td>
                                <td>${stats.SLG ? stats.SLG.toFixed(3) : '.000'}</td>
                                <td>${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</td>
                            </tr>
                        </table>`;
            } else {
                cardHTML += `
                        <table class="card-stats-table">
                            <tr>
                                <th>W</th><th>L</th><th>SV</th><th>G</th><th>GS</th><th>IP</th><th>K</th>
                            </tr>
                            <tr>
                                <td>${stats.W || 0}</td>
                                <td>${stats.L || 0}</td>
                                <td>${stats.SV || 0}</td>
                                <td>${stats.G || 0}</td>
                                <td>${stats.GS || 0}</td>
                                <td>${stats.IP || 0}</td>
                                <td>${stats.SO || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>ERA</th><th>WHIP</th><th>K/9</th><th>K%</th><th>BB%</th><th>HLD</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</td>
                                <td>${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</td>
                                <td>${stats['K/9'] ? stats['K/9'].toFixed(1) : '0.0'}</td>
                                <td>${stats['K%'] ? stats['K%'].toFixed(0) : '0'}%</td>
                                <td>${stats['BB%'] ? stats['BB%'].toFixed(0) : '0'}%</td>
                                <td>${stats.HLD || 0}</td>
                            </tr>
                        </table>`;
            }

            cardHTML += `</div></div>`;  // Close modal-stats-content and card-stats-section

            // Career history section
            const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const playerHistory = playerHistoryData[normalizedName];

            if (playerHistory && playerHistory.seasons && playerHistory.seasons.length > 0) {
                const historyLogos = {};
                const historyRanks = {};

                for (const season of playerHistory.seasons) {
                    const teams = await getTeamData(season.year);
                    if (teams) {
                        const team = teams.find(t => t.team_name === season.team_name);
                        if (team) {
                            historyLogos[`${season.year}_${season.team_name}`] = team.team_logo;
                        }
                    }

                    const yearPlayers = await getPlayerStatsData(season.year);
                    if (yearPlayers) {
                        const sameType = yearPlayers
                            .filter(p => p.position_type === player.position_type)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const overallRank = sameType.findIndex(p => p.name === player.name) + 1;

                        const primaryPos = player.primary_position;
                        const samePos = yearPlayers
                            .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const posRank = samePos.findIndex(p => p.name === player.name) + 1;

                        historyRanks[season.year] = {
                            overall: overallRank > 0 ? overallRank : '-',
                            position: posRank > 0 ? `${primaryPos}${posRank}` : '-'
                        };
                    } else {
                        historyRanks[season.year] = { overall: '-', position: '-' };
                    }
                }

                cardHTML += `
                    <div class="card-history-section">
                        <div class="card-history-title">📜 League History</div>
                        <table class="card-history-table">
                            <thead>
                                <tr>
                                    <th>Year</th>
                                    <th>Team</th>
                                    <th>Pts</th>
                                    <th>Rk</th>
                                    <th>Pos</th>
                                </tr>
                            </thead>
                            <tbody>`;

                playerHistory.seasons.sort((a, b) => b.year - a.year).forEach(season => {
                    const logo = historyLogos[`${season.year}_${season.team_name}`] || '';
                    const ranks = historyRanks[season.year] || { overall: '-', position: '-' };
                    cardHTML += `
                                <tr>
                                    <td><strong>${season.year}</strong></td>
                                    <td>${logo ? `<img src="${logo}" class="team-logo-small" alt="">` : ''}${season.manager || ''}</td>
                                    <td>${(season.fantasy_points || 0).toFixed(0)}</td>
                                    <td>${ranks.overall}</td>
                                    <td>${ranks.position}</td>
                                </tr>`;
                });

                cardHTML += `
                            </tbody>
                        </table>
                    </div>`;
            }

            cardHTML += `</div>`; // Close card-scrollable

            // Footer with owner info
            cardHTML += `
                <div class="card-footer">
                    <div class="owner-info">
                        <span>Owned by:</span>
                        ${player.team_logo ? `<img src="${player.team_logo}" class="owner-logo" alt="">` : ''}
                        <strong>${player.manager || 'Free Agent'}</strong>
                        <span>•</span>
                        <span>${player.team_name || ''}</span>
                    </div>
                </div>
            </div>`; // Close baseball-card

            bodyEl.innerHTML = cardHTML;
            modal.classList.add('active');
            document.body.classList.add('modal-open');
        }

        function closePlayerModal() {
            document.getElementById('player-modal').classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Close player modal on outside click
        document.getElementById('player-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closePlayerModal();
            }
        });

        // ===== MANAGER NAME NORMALIZATION =====
        const MANAGER_TEAM_2023 = {
            "Draft Pool": "Logan C",
            "Peanut Butter & Elly": "Logan S"
        };

        // Logan team keys for 2023 disambiguation
        const LOGAN_TEAM_KEYS_2023 = {
            "422.l.6780.t.4": "Logan C",   // Draft Pool
            "422.l.6780.t.12": "Logan S"   // Peanut Butter & Elly
        };

        // Simple helper to capitalize manager names for display
        function capitalizeManagerName(name) {
            if (!name) return '';
            return name.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function normalizeManagerName(managerName, year = null, teamName = null, teamKey = null) {
            // Convert to title case
            let normalized = managerName.trim()
                .toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            // Handle Logan disambiguation
            if (normalized === "Logan") {
                if (year === 2023 && teamName && MANAGER_TEAM_2023[teamName]) {
                    return MANAGER_TEAM_2023[teamName];
                }
                if (year && year >= 2020 && year <= 2022) {
                    return "Logan C";
                } else if (year && year >= 2024) {
                    return "Logan S";
                }
            }

            // Handle Josh disambiguation (2019-2022)
            if (normalized === "Josh") {
                if (year && year >= 2019 && year <= 2022) {
                    if (teamKey && teamKey.endsWith('t.1')) {
                        return "Josh B";
                    } else {
                        return "Josh S";
                    }
                } else if (year && year >= 2023) {
                    // After 2022, only Josh B remains
                    if (teamKey && teamKey.endsWith('t.1')) {
                        return "Josh B";
                    }
                }
            }

            return normalized;
        }

        function normalizeStandingsData(standings, year) {
            return standings.map(team => ({
                ...team,
                manager: normalizeManagerName(team.manager, year, team.team_name, team.team_key)
            }));
        }

        function normalizeAndMergeManagerData(managersData, historyData) {
            const managerMap = {};

            console.log("Processing managers:", managersData.length);

            // Process each manager's data
            managersData.forEach(manager => {
                // Determine normalized name based on season history
                let normalizedName = manager.manager_name.trim()
                    .toLowerCase()
                    .split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(' ');

                // Handle Logan based on team keys in 2023 or years active
                if (normalizedName === "Logan") {
                    console.log("Found Logan:", manager.season_history);

                    // Check if they have 2023 season
                    const season2023 = manager.season_history.find(s => s.year === 2023);

                    if (season2023) {
                        console.log("Logan has 2023, team:", season2023.team_name);
                        // Use team name to distinguish
                        if (season2023.team_name.includes("Draft Pool")) {
                            normalizedName = "Logan C";
                            console.log("-> Logan C (Draft Pool)");
                        } else if (season2023.team_name.includes("Peanut Butter") || season2023.team_name.includes("Elly")) {
                            normalizedName = "Logan S";
                            console.log("-> Logan S (Peanut Butter & Elly)");
                        } else {
                            console.log("-> Unknown team in 2023:", season2023.team_name);
                        }
                    } else {
                        // No 2023 season - use years to determine
                        const years = manager.season_history.map(s => s.year);
                        const maxYear = Math.max(...years);
                        const minYear = Math.min(...years);

                        console.log("Logan years:", years, "min:", minYear, "max:", maxYear);

                        if (maxYear <= 2022) {
                            // Only played 2020-2022 = Logan C
                            normalizedName = "Logan C";
                            console.log("-> Logan C (only 2020-2022)");
                        } else if (minYear >= 2024) {
                            // Only played 2024+ = Logan S
                            normalizedName = "Logan S";
                            console.log("-> Logan S (only 2024+)");
                        } else {
                            console.log("-> Logan with unclear years");
                        }
                    }
                }

                // Normalize season history
                const normalizedSeasonHistory = manager.season_history.map(season => ({
                    ...season
                }));

                // DON'T merge different Logans - only merge case variations
                const shouldMerge = managerMap[normalizedName] &&
                    !(normalizedName === "Logan C" || normalizedName === "Logan S");

                if (shouldMerge) {
                    console.log("Merging into existing manager:", normalizedName);
                    // Merge stats
                    managerMap[normalizedName].total_wins += manager.total_wins;
                    managerMap[normalizedName].total_losses += manager.total_losses;
                    managerMap[normalizedName].total_ties += manager.total_ties;
                    managerMap[normalizedName].total_points_for += manager.total_points_for;
                    managerMap[normalizedName].championships += manager.championships;
                    managerMap[normalizedName].runner_ups += manager.runner_ups;
                    managerMap[normalizedName].playoff_appearances += manager.playoff_appearances;
                    managerMap[normalizedName].seasons_played += manager.seasons_played;

                    // Merge season history
                    managerMap[normalizedName].season_history = [
                        ...managerMap[normalizedName].season_history,
                        ...normalizedSeasonHistory
                    ];

                    // Update first season
                    managerMap[normalizedName].first_season = Math.min(
                        managerMap[normalizedName].first_season,
                        manager.first_season
                    );
                } else {
                    console.log("Creating new manager entry:", normalizedName);
                    // New manager entry
                    managerMap[normalizedName] = {
                        ...manager,
                        manager_name: normalizedName,
                        season_history: normalizedSeasonHistory
                    };
                }
            });

            console.log("Final managers:", Object.keys(managerMap));

            // Recalculate derived stats for merged managers
            Object.values(managerMap).forEach(manager => {
                const totalGames = manager.total_wins + manager.total_losses;
                manager.win_pct = totalGames > 0 ? manager.total_wins / totalGames : 0;
                manager.avg_finish = manager.season_history.length > 0
                    ? manager.season_history.reduce((sum, s) => sum + s.rank, 0) / manager.season_history.length
                    : 0;

                // Sort season history by year
                manager.season_history.sort((a, b) => a.year - b.year);
            });

            return Object.values(managerMap);
        }

        // Split Logan's stats for 2023 based on team_key
        async function splitLogan2023Stats() {
            try {
                // Load 2023 standings and scores
                const standingsResponse = await fetch('data/historical/2023/final_standings.json');
                const scoresResponse = await fetch('data/historical/2023/all_scores.json');

                if (!standingsResponse.ok || !scoresResponse.ok) {
                    console.log("Could not load 2023 data for Logan split");
                    return null;
                }

                const standings = await standingsResponse.json();
                const scores = await scoresResponse.json();

                // Find Logan's teams by team_key
                const loganCTeam = standings.find(t => t.team_key === "422.l.6780.t.4");
                const loganSTeam = standings.find(t => t.team_key === "422.l.6780.t.12");

                if (!loganCTeam && !loganSTeam) {
                    console.log("Could not find Logan team keys in 2023 standings");
                    return null;
                }

                // Calculate stats for each Logan based on team_key
                const loganStats = {
                    "Logan C": loganCTeam ? {
                        team_key: loganCTeam.team_key,
                        team_name: loganCTeam.team_name,
                        rank: loganCTeam.rank,
                        wins: loganCTeam.wins,
                        losses: loganCTeam.losses,
                        ties: loganCTeam.ties,
                        points_for: loganCTeam.points_for
                    } : null,
                    "Logan S": loganSTeam ? {
                        team_key: loganSTeam.team_key,
                        team_name: loganSTeam.team_name,
                        rank: loganSTeam.rank,
                        wins: loganSTeam.wins,
                        losses: loganSTeam.losses,
                        ties: loganSTeam.ties,
                        points_for: loganSTeam.points_for
                    } : null
                };

                console.log("Split Logan 2023 stats:", loganStats);
                return loganStats;

            } catch (error) {
                console.error("Error splitting Logan stats:", error);
                return null;
            }
        }

        // Apply Logan split to manager data
        async function applyLogan2023Split(managersData) {
            const logan2023Stats = await splitLogan2023Stats();

            if (!logan2023Stats) {
                console.log("No Logan split needed or data unavailable");
                return managersData;
            }

            // Update each Logan's 2023 season data
            managersData.forEach(manager => {
                if ((manager.manager_name === "Logan C" || manager.manager_name === "Logan S") && logan2023Stats[manager.manager_name]) {
                    const season2023Index = manager.season_history.findIndex(s => s.year === 2023);

                    if (season2023Index >= 0) {
                        // Update with correct stats
                        const stats = logan2023Stats[manager.manager_name];
                        manager.season_history[season2023Index] = {
                            year: 2023,
                            team_name: stats.team_name,
                            rank: stats.rank,
                            wins: stats.wins,
                            losses: stats.losses,
                            points_for: stats.points_for
                        };

                        // Recalculate totals
                        manager.total_wins = manager.season_history.reduce((sum, s) => sum + s.wins, 0);
                        manager.total_losses = manager.season_history.reduce((sum, s) => sum + s.losses, 0);
                        manager.total_points_for = manager.season_history.reduce((sum, s) => sum + s.points_for, 0);
                        manager.win_pct = manager.total_wins / (manager.total_wins + manager.total_losses);
                        manager.avg_finish = manager.season_history.reduce((sum, s) => sum + s.rank, 0) / manager.season_history.length;

                        console.log(`Updated ${manager.manager_name} with 2023 stats`);
                    }
                }
            });

            return managersData;
        }

        // ===== INITIALIZE SEASON SELECTORS =====
        async function initializeSeasonSelectors() {
            const standingsSelect = document.getElementById('standings-season');
            standingsSelect.innerHTML = '<option value="">Loading seasons...</option>';

            // Try to detect available seasons by checking for data files
            const possibleSeasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const availableSeasons = [];

            // Check current season
            try {
                const response = await fetch('data/current_season/standings.json');
                if (response.ok) {
                    availableSeasons.push({ year: 2025, isCurrent: true });
                }
            } catch (e) { }

            // Check historical seasons
            for (const year of possibleSeasons.filter(y => y < 2025)) {
                try {
                    const response = await fetch(`data/historical/${year}/final_standings.json`);
                    if (response.ok) {
                        availableSeasons.push({ year: year, isCurrent: false });
                    }
                } catch (e) { }
            }

            // Sort by year descending
            availableSeasons.sort((a, b) => b.year - a.year);

            // Populate dropdown
            standingsSelect.innerHTML = '';
            availableSeasons.forEach(season => {
                const option = document.createElement('option');
                option.value = season.year;
                option.textContent = season.isCurrent ? `${season.year} (Current)` : season.year;
                standingsSelect.appendChild(option);
            });

            // Populate scoring dropdown the same way
            const scoringSelect = document.getElementById('scoring-season');
            scoringSelect.innerHTML = standingsSelect.innerHTML;

            return availableSeasons;
        }

        // ===== LOAD STANDINGS BY SEASON =====
        async function loadStandingsBySeason() {
            const season = document.getElementById('standings-season').value;
            const loadingEl = document.getElementById('standings-loading');
            const errorEl = document.getElementById('standings-error');
            const tableEl = document.getElementById('standings-table');
            const chartContainer = document.getElementById('season-chart-container');

            if (!season) {
                return; // No season selected yet
            }

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                tableEl.style.display = 'none';
                chartContainer.style.display = 'none';

                let response;
                const seasonNum = parseInt(season);

                // Check if this is current season (2025) or historical
                const currentSeasonCheck = await fetch('data/current_season/standings.json');
                let isCurrentSeason = false;

                if (currentSeasonCheck.ok) {
                    // If current season data exists, it's 2025
                    isCurrentSeason = (seasonNum === 2025);
                }

                // Load from appropriate location
                if (isCurrentSeason) {
                    response = await fetch('data/current_season/standings.json');
                } else {
                    response = await fetch(`data/historical/${season}/final_standings.json`);
                }

                if (!response.ok) {
                    throw new Error(`Data not found for ${season}`);
                }

                let standings = await response.json();

                // Load team logos
                let teamsResponse;
                if (isCurrentSeason) {
                    teamsResponse = await fetch('data/current_season/teams.json');
                } else {
                    teamsResponse = await fetch(`data/historical/${season}/teams.json`);
                }

                let teamLogos = {};
                let teamData = [];
                if (teamsResponse.ok) {
                    teamData = await teamsResponse.json();
                    teamData.forEach(team => {
                        teamLogos[team.team_key] = team.team_logo;
                    });
                }

                // Normalize manager names
                standings = normalizeStandingsData(standings, seasonNum);

                // Sort by rank to ensure proper ordering
                standings.sort((a, b) => a.rank - b.rank);

                // Populate the table
                const tbody = document.getElementById('standings-body');
                tbody.innerHTML = '';

                standings.forEach(team => {
                    const row = document.createElement('tr');
                    const logo = teamLogos[team.team_key] ? `<img src="${teamLogos[team.team_key]}" class="team-logo" alt="Team Logo">` : '';

                    // Add medals for top 3
                    let medal = '';
                    if (team.rank === 1) medal = '<span class="medal">🥇</span>';
                    else if (team.rank === 2) medal = '<span class="medal">🥈</span>';
                    else if (team.rank === 3) medal = '<span class="medal">🥉</span>';

                    row.innerHTML = `
                        <td>${medal}${team.rank}</td>
                        <td><div class="manager-cell">${team.manager}</div></td>
                        <td><div class="team-cell-content">${logo}<span>${team.team_name}</span></div></td>
                        <td>${team.wins}</td>
                        <td>${team.losses}</td>
                        <td>${team.win_pct.toFixed(3)}</td>
                        <td>${Math.round(team.points_for).toLocaleString()}</td>
                    `;
                    tbody.appendChild(row);
                });

                loadingEl.style.display = 'none';
                tableEl.style.display = 'table';

                // Load draft data for this season
                await loadDraftResults(seasonNum, isCurrentSeason, teamLogos, teamData);

                // Load and render the season chart
                await loadSeasonChart(seasonNum, isCurrentSeason, standings, teamLogos, teamData);

            } catch (error) {
                console.error('Error loading standings:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading ${season} standings: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        // ===== DRAFT RESULTS FUNCTIONS =====
        async function loadDraftResults(seasonNum, isCurrentSeason, teamLogos, teamData) {
            const draftTable = document.getElementById('draft-table');
            const draftBody = document.getElementById('draft-body');
            const draftLoading = document.getElementById('draft-loading');
            const draftEmpty = document.getElementById('draft-empty');

            // Build team info lookup by team_key
            const teamInfo = {};
            if (teamData && teamData.length > 0) {
                teamData.forEach(team => {
                    teamInfo[team.team_key] = {
                        name: team.team_name || team.name || 'Unknown Team',
                        manager: team.manager || 'Unknown'
                    };
                });
            }

            // Reset state
            draftTable.style.display = 'none';
            draftLoading.style.display = 'block';
            draftEmpty.style.display = 'none';
            draftBody.innerHTML = '';

            try {
                // Load draft data
                let draftResponse;
                if (isCurrentSeason) {
                    draftResponse = await fetch('data/current_season/draft.json');
                } else {
                    draftResponse = await fetch(`data/historical/${seasonNum}/draft.json`);
                }

                if (!draftResponse.ok) {
                    throw new Error('Draft data not available');
                }

                const draftData = await draftResponse.json();

                if (!draftData || draftData.length === 0) {
                    draftLoading.style.display = 'none';
                    draftEmpty.style.display = 'block';
                    return;
                }

                // Load keepers data
                let keepersForYear = {};
                try {
                    const keepersResponse = await fetch('data/keepers.json');
                    if (keepersResponse.ok) {
                        const allKeepers = await keepersResponse.json();
                        keepersForYear = allKeepers[seasonNum.toString()] || {};
                        console.log(`Loaded ${Object.keys(keepersForYear).length} keepers for ${seasonNum}`);
                    } else {
                        console.log('Keepers response not ok:', keepersResponse.status);
                    }
                } catch (e) {
                    console.log('No keepers data available:', e);
                }

                // Create lowercase keeper lookup for flexible matching
                const keepersLowercase = {};
                for (const [name, info] of Object.entries(keepersForYear)) {
                    keepersLowercase[name.toLowerCase().trim()] = info;
                }

                // Load player stats to get fantasy points and position ranks
                let playerStatsResponse;
                if (isCurrentSeason) {
                    playerStatsResponse = await fetch('data/current_season/player_stats.json');
                } else {
                    playerStatsResponse = await fetch(`data/historical/${seasonNum}/player_stats.json`);
                }

                let playerStatsByKey = {};
                let playerStatsByName = {};
                let positionRanks = {};
                if (playerStatsResponse.ok) {
                    const statsData = await playerStatsResponse.json();
                    // Create lookups by player_key and by name
                    statsData.forEach(player => {
                        if (player.player_key) {
                            playerStatsByKey[player.player_key] = player;
                        }
                        if (player.name) {
                            playerStatsByName[player.name.toLowerCase()] = player;
                        }
                    });
                    // Calculate position ranks
                    positionRanks = calculateDraftPositionRanks(statsData);
                }

                // Render draft table with round separators
                let currentRound = 0;
                draftData.forEach((pick, index) => {
                    const pickRound = pick.round || 0;

                    // Add round separator when round changes
                    if (pickRound !== currentRound) {
                        currentRound = pickRound;
                        const separatorRow = document.createElement('tr');
                        separatorRow.className = 'draft-round-separator';
                        separatorRow.innerHTML = `<td colspan="6">Round ${currentRound}</td>`;
                        draftBody.appendChild(separatorRow);
                    }

                    const row = document.createElement('tr');

                    // Get player stats - try player_key first, then fall back to name match
                    const playerKey = pick.player_key;
                    let playerData = playerStatsByKey[playerKey];

                    // If not found by key, try matching by name
                    if (!playerData && pick.player_name) {
                        playerData = playerStatsByName[pick.player_name.toLowerCase()];
                    }

                    playerData = playerData || {};

                    const fantasyPoints = playerData.fantasy_points || 0;
                    const position = pick.position || playerData.position || '';
                    const primaryPos = position.split(',')[0].trim();

                    // Get position rank - try by player_key first, then by matched player's key
                    let posRank = positionRanks[playerKey];
                    if (!posRank && playerData.player_key) {
                        posRank = positionRanks[playerData.player_key];
                    }
                    posRank = posRank || '-';
                    const posRankClass = getRankClass(posRank, primaryPos);

                    // Team logo from draft
                    const teamLogo = teamLogos[pick.team_key] || '';
                    const teamDetails = teamInfo[pick.team_key] || { name: 'Unknown Team', manager: 'Unknown' };
                    const teamTooltip = `${teamDetails.name} (${teamDetails.manager})`;

                    // Player headshot
                    const headshot = pick.headshot_url || playerData.headshot_url || '';
                    const headshotImg = headshot
                        ? `<img src="${headshot}" class="draft-headshot" alt="" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23e0e0e0%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2250%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 font-size=%2240%22>⚾</text></svg>'">`
                        : '<div class="draft-headshot" style="display:flex;align-items:center;justify-content:center;font-size:14px;">⚾</div>';

                    // Check if player was a keeper - try multiple name variations
                    const playerName = pick.player_name || '';
                    let isKeeper = false;
                    if (playerName) {
                        // Try exact match first
                        if (keepersForYear[playerName]) {
                            isKeeper = true;
                        } else {
                            // Try case-insensitive match
                            const lowerName = playerName.toLowerCase();
                            for (const keeperName of Object.keys(keepersForYear)) {
                                if (keeperName.toLowerCase() === lowerName) {
                                    isKeeper = true;
                                    break;
                                }
                            }
                        }
                    }
                    const keeperBadge = isKeeper ? '<span class="keeper-badge">K</span>' : '';
                    const posClass = getDraftPosClass(primaryPos);

                    row.innerHTML = `
                        <td>${pick.round || '-'}</td>
                        <td>${pick.pick || '-'}</td>
                        <td>
                            <div class="draft-player-cell">
                                ${headshotImg}
                                <div class="draft-player-info">
                                    <span class="draft-player-name">${pick.player_name || 'Unknown'}${keeperBadge}</span>
                                    <span class="draft-player-pos ${posClass}">${primaryPos}</span>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="draft-team-cell">
                                ${teamLogo ? `<img src="${teamLogo}" class="draft-team-logo" alt="${teamDetails.name}"><span class="draft-team-tooltip">${teamTooltip}</span>` : ''}
                            </div>
                        </td>
                        <td class="draft-pts">${fantasyPoints > 0 ? Math.round(fantasyPoints).toLocaleString() : '-'}</td>
                        <td><span class="draft-rank ${posRankClass}">${primaryPos}${posRank !== '-' ? posRank : ''}</span></td>
                    `;
                    draftBody.appendChild(row);
                });

                draftLoading.style.display = 'none';
                draftTable.style.display = 'table';

            } catch (error) {
                console.error('Error loading draft:', error);
                draftLoading.style.display = 'none';
                draftEmpty.textContent = 'Draft data not available for this season';
                draftEmpty.style.display = 'block';
            }
        }

        function calculateDraftPositionRanks(players) {
            // Group players by primary position
            const positionGroups = {};

            players.forEach(player => {
                const pos = (player.position || '').split(',')[0].trim();
                if (!pos) return;

                if (!positionGroups[pos]) {
                    positionGroups[pos] = [];
                }
                positionGroups[pos].push({
                    player_key: player.player_key,
                    fantasy_points: player.fantasy_points || 0
                });
            });

            // Sort each position group by fantasy points and assign ranks
            const ranks = {};
            Object.keys(positionGroups).forEach(pos => {
                positionGroups[pos].sort((a, b) => b.fantasy_points - a.fantasy_points);
                positionGroups[pos].forEach((player, index) => {
                    ranks[player.player_key] = index + 1;
                });
            });

            return ranks;
        }

        function getRankClass(rank, position) {
            if (rank === '-' || !rank) return '';
            const numRank = parseInt(rank);
            const pos = (position || '').toUpperCase();

            // Outfield positions
            const isOutfield = ['OF', 'LF', 'CF', 'RF'].includes(pos);

            if (pos === 'SP') {
                // Starting Pitchers: Green = top 12, Yellow = top 60, Red = below
                if (numRank <= 12) return 'top-10';
                if (numRank <= 60) return 'top-25';
                return 'top-50';
            } else if (pos === 'RP' || pos === 'P') {
                // Relief Pitchers: Green = top 3, Yellow = top 10, Red = below
                if (numRank <= 3) return 'top-10';
                if (numRank <= 10) return 'top-25';
                return 'top-50';
            } else if (isOutfield) {
                // Outfielders: Green = top 9, Yellow = top 25, Red = below
                if (numRank <= 9) return 'top-10';
                if (numRank <= 25) return 'top-25';
                return 'top-50';
            } else {
                // All other hitters: Green = top 3, Yellow = top 10, Red = below
                if (numRank <= 3) return 'top-10';
                if (numRank <= 10) return 'top-25';
                return 'top-50';
            }
        }

        function getDraftPosClass(position) {
            const pos = (position || '').toUpperCase();
            
            // Infield
            if (pos === 'C') return 'pos-c';
            if (pos === '1B') return 'pos-1b';
            if (pos === '2B') return 'pos-2b';
            if (pos === '3B') return 'pos-3b';
            if (pos === 'SS') return 'pos-ss';
            
            // Outfield
            if (['OF', 'LF', 'CF', 'RF'].includes(pos)) return 'pos-of';
            
            // Designated Hitter / Utility
            if (pos === 'DH') return 'pos-dh';
            if (pos === 'UTIL') return 'pos-util';
            
            // Pitchers (Now distinct)
            if (pos === 'SP') return 'pos-sp';
            if (pos === 'RP') return 'pos-rp';
            if (pos === 'P') return 'pos-p';
            
            return 'pos-util'; // Fallback
        }

        // ===== SEASON CHART FUNCTIONS =====
        async function loadSeasonChart(seasonNum, isCurrentSeason, standings, teamLogos, teamData) {
            const chartContainer = document.getElementById('season-chart-container');
            const chartEl = document.getElementById('season-chart');

            try {
                // Load weekly scores data
                let scoresResponse;
                if (isCurrentSeason) {
                    scoresResponse = await fetch('data/current_season/all_scores.json');
                } else {
                    scoresResponse = await fetch(`data/historical/${seasonNum}/all_scores.json`);
                }

                if (!scoresResponse.ok) {
                    console.log('No scores data available for chart');
                    chartContainer.style.display = 'none';
                    return;
                }

                const scoresData = await scoresResponse.json();
                console.log('Loaded scores data:', scoresData.length, 'entries');

                // Process scores into both weekly and cumulative rankings
                currentChartData = processScoresForChart(scoresData, standings, teamLogos, teamData);
                console.log('Processed chart data:', currentChartData.weeklyTeams.length, 'teams');

                if (currentChartData.weeklyTeams.length === 0) {
                    console.log('No team data to display');
                    chartContainer.style.display = 'none';
                    return;
                }

                // Reset to total view (default)
                currentChartType = 'total';
                document.getElementById('btn-weekly').classList.remove('active');
                document.getElementById('btn-total').classList.add('active');

                // Show container first so it has dimensions
                chartContainer.style.display = 'block';

                // Use requestAnimationFrame to ensure DOM is updated before rendering
                requestAnimationFrame(() => {
                    renderSeasonChart(chartEl, currentChartData, currentChartType);
                });

            } catch (error) {
                console.error('Error loading season chart:', error);
                chartContainer.style.display = 'none';
            }
        }

        function setChartType(type) {
            if (type === currentChartType || !currentChartData) return;

            currentChartType = type;

            // Update button states
            document.getElementById('btn-weekly').classList.toggle('active', type === 'weekly');
            document.getElementById('btn-total').classList.toggle('active', type === 'total');

            // Re-render chart
            const chartEl = document.getElementById('season-chart');
            renderSeasonChart(chartEl, currentChartData, currentChartType);
        }

        function processScoresForChart(scoresData, standings, teamLogos, teamData) {
            // Group scores by week first
            const weeklyScores = {};
            const teamInfo = {};

            // Collect all scores by week and team info
            scoresData.forEach(entry => {
                const teamKey = entry.team_key;
                const week = entry.week;
                const score = entry.team_score;

                // Store team info
                if (!teamInfo[teamKey]) {
                    const standingTeam = standings.find(t => t.team_key === teamKey);
                    const teamDataEntry = teamData.find(t => t.team_key === teamKey);

                    teamInfo[teamKey] = {
                        team_key: teamKey,
                        team_name: standingTeam?.team_name || teamDataEntry?.team_name || 'Unknown Team',
                        manager: standingTeam?.manager || teamDataEntry?.manager || 'Unknown',
                        logo: teamLogos[teamKey] || teamDataEntry?.team_logo || ''
                    };
                }

                // Store weekly score
                if (!weeklyScores[week]) {
                    weeklyScores[week] = [];
                }
                weeklyScores[week].push({
                    team_key: teamKey,
                    score: score
                });
            });

            const weeks = Object.keys(weeklyScores).map(Number).sort((a, b) => a - b);
            const numTeams = Object.keys(teamInfo).length;

            // Calculate WEEKLY rankings
            const teamWeeklyRankings = {};
            weeks.forEach(week => {
                const weekScores = [...weeklyScores[week]].sort((a, b) => b.score - a.score);
                weekScores.forEach((entry, index) => {
                    const rank = index + 1;
                    if (!teamWeeklyRankings[entry.team_key]) {
                        teamWeeklyRankings[entry.team_key] = [];
                    }
                    teamWeeklyRankings[entry.team_key].push({
                        week: week,
                        rank: rank,
                        score: entry.score
                    });
                });
            });

            // Calculate CUMULATIVE rankings
            const teamCumulativeScores = {}; // team_key -> running total
            const teamCumulativeRankings = {};

            weeks.forEach(week => {
                // Update cumulative scores
                weeklyScores[week].forEach(entry => {
                    if (!teamCumulativeScores[entry.team_key]) {
                        teamCumulativeScores[entry.team_key] = 0;
                    }
                    teamCumulativeScores[entry.team_key] += entry.score;
                });

                // Sort teams by cumulative score descending
                const cumulativeRanking = Object.entries(teamCumulativeScores)
                    .map(([teamKey, total]) => ({ team_key: teamKey, cumulative: total }))
                    .sort((a, b) => b.cumulative - a.cumulative);

                // Assign cumulative ranks
                cumulativeRanking.forEach((entry, index) => {
                    const rank = index + 1;
                    if (!teamCumulativeRankings[entry.team_key]) {
                        teamCumulativeRankings[entry.team_key] = [];
                    }
                    teamCumulativeRankings[entry.team_key].push({
                        week: week,
                        rank: rank,
                        cumulative: entry.cumulative
                    });
                });
            });

            // Build result arrays for both types
            const weeklyTeams = [];
            const cumulativeTeams = [];

            Object.keys(teamInfo).forEach(teamKey => {
                const info = teamInfo[teamKey];

                // Weekly data
                const weeklyData = (teamWeeklyRankings[teamKey] || []).sort((a, b) => a.week - b.week);
                const avgWeeklyRank = weeklyData.length > 0
                    ? weeklyData.reduce((sum, r) => sum + r.rank, 0) / weeklyData.length
                    : numTeams;

                weeklyTeams.push({
                    team_key: teamKey,
                    team_name: info.team_name,
                    manager: info.manager,
                    logo: info.logo,
                    data: weeklyData,
                    avgRank: avgWeeklyRank
                });

                // Cumulative data
                const cumulativeData = (teamCumulativeRankings[teamKey] || []).sort((a, b) => a.week - b.week);
                const finalRank = cumulativeData.length > 0
                    ? cumulativeData[cumulativeData.length - 1].rank
                    : numTeams;

                cumulativeTeams.push({
                    team_key: teamKey,
                    team_name: info.team_name,
                    manager: info.manager,
                    logo: info.logo,
                    data: cumulativeData,
                    finalRank: finalRank
                });
            });

            // Sort weekly by average rank, cumulative by final rank
            weeklyTeams.sort((a, b) => a.avgRank - b.avgRank);
            cumulativeTeams.sort((a, b) => a.finalRank - b.finalRank);

            console.log('Teams with ranking data:', weeklyTeams.length);
            console.log('Weeks:', weeks.length);

            return {
                weeklyTeams: weeklyTeams,
                cumulativeTeams: cumulativeTeams,
                numTeams: numTeams,
                weeks: weeks
            };
        }

        function renderSeasonChart(container, chartData, chartType) {
            // Clear previous chart
            container.innerHTML = '';

            const { weeklyTeams, cumulativeTeams, numTeams, weeks } = chartData;
            const teams = chartType === 'weekly' ? weeklyTeams : cumulativeTeams;
            const isWeekly = chartType === 'weekly';

            // Detect mobile
            const isMobile = window.innerWidth <= 768;

            // Chart dimensions - adjusted for mobile
            const containerWidth = container.clientWidth || container.offsetWidth || 900;
            const logoRadius = isMobile ? 10 : 14;
            const logoImageSize = isMobile ? 14 : 20;
            const rowHeight = isMobile ? 28 : 40;

            // On mobile, ensure minimum width for scrolling
            const minChartWidth = isMobile ? Math.max(weeks.length * 25, 600) : 600;

            const margin = { top: 30, right: 30, bottom: 50, left: isMobile ? 40 : 70 };
            const width = Math.max(minChartWidth, containerWidth - margin.left - margin.right);
            const height = Math.max(400, numTeams * rowHeight + 60);

            const minWeek = Math.min(...weeks);
            const maxWeek = Math.max(...weeks);
            const weekRange = maxWeek - minWeek || 1;

            // Scale functions
            const xScale = (week) => margin.left + ((week - minWeek) / weekRange) * width;
            const yScale = (rank) => margin.top + ((rank - 1) / (numTeams - 1)) * (height - margin.top - margin.bottom);

            // Generate colors for teams
            const colors = generateTeamColors(teams.length);
            const teamColorMap = {};
            teams.forEach((team, index) => {
                teamColorMap[team.team_key] = colors[index];
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            svg.setAttribute('class', 'chart-svg');
            svg.style.display = 'block';
            // Don't limit width on mobile to allow scrolling
            if (!isMobile) {
                svg.style.maxWidth = '100%';
            }

            // Draw horizontal grid lines for each rank
            for (let rank = 1; rank <= numTeams; rank++) {
                const y = yScale(rank);
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);
                line.setAttribute('class', 'chart-grid-line');
                line.setAttribute('stroke-dasharray', '3,3');
                svg.appendChild(line);

                // Y-axis rank label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - (isMobile ? 15 : 25));
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('class', 'chart-axis-label');
                label.setAttribute('font-size', isMobile ? '10px' : '12px');
                label.textContent = rank;
                svg.appendChild(label);
            }

            // Draw X-axis labels - show fewer on mobile
            const numWeeksTotal = weeks.length;
            const weekStep = Math.max(1, Math.ceil(numWeeksTotal / (isMobile ? 8 : 12)));
            for (let i = 0; i < weeks.length; i += weekStep) {
                const week = weeks[i];
                const x = xScale(week);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - 10);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'chart-axis-label');
                label.setAttribute('font-size', isMobile ? '10px' : '12px');
                label.textContent = `${week}`;
                svg.appendChild(label);
            }

            // X-axis title
            const xTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xTitle.setAttribute('x', margin.left + width / 2);
            xTitle.setAttribute('y', height - 0);
            xTitle.setAttribute('text-anchor', 'middle');
            xTitle.setAttribute('class', 'chart-axis-label');
            xTitle.setAttribute('font-weight', 'bold');
            xTitle.setAttribute('font-size', isMobile ? '11px' : '12px');
            xTitle.textContent = 'Week';
            svg.appendChild(xTitle);

            // Y-axis title
            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('transform', `rotate(-90)`);
            yTitle.setAttribute('x', -(margin.top + (height - margin.top - margin.bottom) / 2));
            yTitle.setAttribute('y', isMobile ? 12 : 15);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('class', 'chart-axis-label');
            yTitle.setAttribute('font-weight', 'bold');
            yTitle.setAttribute('font-size', isMobile ? '11px' : '12px');
            yTitle.textContent = isWeekly ? 'Weekly Rank' : 'Cumulative Rank';
            svg.appendChild(yTitle);

            // Draw lines for each team (draw lines first, then logos on top)
            teams.forEach((team, index) => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                // Build path
                let d = '';
                team.data.forEach((point, i) => {
                    const x = xScale(point.week);
                    const y = yScale(point.rank);
                    d += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
                });

                path.setAttribute('d', d);
                path.setAttribute('class', 'chart-line');
                path.setAttribute('stroke', colors[index]);
                path.setAttribute('stroke-width', isMobile ? '2' : '2.5');
                path.setAttribute('data-team-key', team.team_key);
                svg.appendChild(path);
            });

            // Add team logo markers at EVERY week for each team
            teams.forEach((team, teamIndex) => {
                team.data.forEach((point) => {
                    const x = xScale(point.week);
                    const y = yScale(point.rank);

                    // Create group for logo marker
                    const logoGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    logoGroup.setAttribute('class', 'team-logo-marker');
                    logoGroup.setAttribute('data-team-key', team.team_key);
                    logoGroup.setAttribute('data-week', point.week);
                    // Store either weekly score or cumulative total
                    logoGroup.setAttribute('data-score', isWeekly ? point.score : point.cumulative);
                    logoGroup.setAttribute('data-is-weekly', isWeekly);
                    logoGroup.setAttribute('transform', `translate(${x}, ${y})`);

                    // Circle background
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', logoRadius);
                    circle.setAttribute('fill', 'white');
                    circle.setAttribute('stroke', colors[teamIndex]);
                    circle.setAttribute('stroke-width', isMobile ? '1.5' : '2');
                    logoGroup.appendChild(circle);

                    // Team logo image
                    if (team.logo) {
                        const imageOffset = logoImageSize / 2;
                        const image = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                        image.setAttribute('href', team.logo);
                        image.setAttribute('x', -imageOffset);
                        image.setAttribute('y', -imageOffset);
                        image.setAttribute('width', logoImageSize);
                        image.setAttribute('height', logoImageSize);
                        image.setAttribute('style', `clip-path: circle(${imageOffset}px at center)`);
                        logoGroup.appendChild(image);
                    }

                    // Add hover/touch events
                    const scoreValue = isWeekly ? point.score : point.cumulative;
                    const handleInteraction = (e) => {
                        e.preventDefault();
                        handleTeamHover(team.team_key, team.team_name, scoreValue, point.week, point.rank, isWeekly, e.currentTarget);
                    };

                    logoGroup.addEventListener('mouseenter', handleInteraction);
                    logoGroup.addEventListener('touchstart', handleInteraction, { passive: false });
                    logoGroup.addEventListener('mouseleave', () => handleTeamHoverEnd());
                    logoGroup.addEventListener('touchend', () => setTimeout(handleTeamHoverEnd, 1500));

                    svg.appendChild(logoGroup);
                });
            });

            container.appendChild(svg);

            // Create tooltip element
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.style.display = 'none';
            tooltip.id = 'chart-tooltip';
            container.appendChild(tooltip);

            // Add scroll hint for mobile
            if (isMobile && weeks.length > 10) {
                const scrollHint = document.createElement('div');
                scrollHint.style.cssText = 'text-align: center; color: #666; font-size: 0.8rem; margin-top: 0.5rem;';
                scrollHint.textContent = '← Scroll to see all weeks →';
                container.appendChild(scrollHint);
            }
        }

        function generateTeamColors(count) {
            const baseColors = [
                '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231',
                '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe',
                '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000',
                '#aaffc3'
            ];

            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(baseColors[i % baseColors.length]);
            }
            return colors;
        }

        function handleTeamHover(teamKey, teamName, score, week, rank, isWeekly, markerElement) {
            // Fade all lines and markers except the hovered team
            document.querySelectorAll('.chart-line').forEach(line => {
                if (line.getAttribute('data-team-key') === teamKey) {
                    line.classList.add('highlighted');
                    line.classList.remove('faded');
                } else {
                    line.classList.add('faded');
                    line.classList.remove('highlighted');
                }
            });

            document.querySelectorAll('.team-logo-marker').forEach(marker => {
                if (marker.getAttribute('data-team-key') === teamKey) {
                    marker.classList.add('highlighted');
                    marker.classList.remove('faded');
                } else {
                    marker.classList.add('faded');
                    marker.classList.remove('highlighted');
                }
            });

            // Show tooltip with appropriate label
            const tooltip = document.getElementById('chart-tooltip');

            if (tooltip && markerElement) {
                const containerRect = document.getElementById('season-chart').getBoundingClientRect();
                const markerRect = markerElement.getBoundingClientRect();

                const scoreLabel = isWeekly ? `Week ${week}: ${score.toLocaleString()} pts` : `Total: ${score.toLocaleString()} pts`;
                tooltip.innerHTML = `<strong>${teamName}</strong><br>${scoreLabel}<br>Rank: #${rank}`;
                tooltip.style.display = 'block';
                tooltip.style.left = (markerRect.left - containerRect.left + markerRect.width / 2) + 'px';
                tooltip.style.top = (markerRect.top - containerRect.top - 5) + 'px';
            }
        }

        function handleTeamHoverEnd() {
            // Remove all faded/highlighted classes
            document.querySelectorAll('.chart-line').forEach(line => {
                line.classList.remove('faded', 'highlighted');
            });

            document.querySelectorAll('.team-logo-marker').forEach(marker => {
                marker.classList.remove('faded', 'highlighted');
            });

            // Hide tooltip
            const tooltip = document.getElementById('chart-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // ===== CALCULATE MANAGER AWARDS =====
        async function calculateManagerAwards() {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const seasonData = {};

            // Load keepers data
            let allKeepers = {};
            try {
                const keepersResponse = await fetch('data/keepers.json');
                if (keepersResponse.ok) {
                    allKeepers = await keepersResponse.json();
                }
            } catch (e) {
                console.log('No keepers data available');
            }

            // Load all seasons data including player stats and draft
            for (const year of seasons) {
                try {
                    let standingsResponse, playerStatsResponse, draftResponse, teamsResponse;

                    if (year === 2025) {
                        standingsResponse = await fetch('data/current_season/standings.json');
                        playerStatsResponse = await fetch('data/current_season/player_stats.json');
                        draftResponse = await fetch('data/current_season/draft.json');
                        teamsResponse = await fetch('data/current_season/teams.json');
                    } else {
                        standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                        playerStatsResponse = await fetch(`data/historical/${year}/player_stats.json`);
                        draftResponse = await fetch(`data/historical/${year}/draft.json`);
                        teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                    }

                    if (standingsResponse.ok) {
                        const standings = await standingsResponse.json();
                        const normalizedStandings = normalizeStandingsData(standings, year);
                        const playerStats = playerStatsResponse.ok ? await playerStatsResponse.json() : [];
                        const draftData = draftResponse && draftResponse.ok ? await draftResponse.json() : [];
                        const teams = teamsResponse && teamsResponse.ok ? await teamsResponse.json() : [];

                        // Create team info map
                        const teamInfoMap = {};
                        teams.forEach(team => {
                            teamInfoMap[team.team_key] = {
                                name: team.team_name,
                                manager: team.manager,
                                logo: team.team_logo
                            };
                        });

                        seasonData[year] = {
                            standings: normalizedStandings,
                            playerStats: playerStats,
                            draftData: draftData,
                            teamInfo: teamInfoMap
                        };
                    }
                } catch (e) {
                    console.error(`Error loading ${year}:`, e);
                }
            }

            // Calculate awards by manager
            const managerAwards = {};

            for (const [year, data] of Object.entries(seasonData)) {
                const standings = data.standings;
                const playerStats = data.playerStats || [];

                // Find winners for each award category
                const mostWins = standings.reduce((max, team) =>
                    team.wins > max.wins ? team : max
                );
                const mostPoints = standings.reduce((max, team) =>
                    team.points_for > max.points_for ? team : max
                );
                const fewestWins = standings.reduce((min, team) =>
                    team.wins < min.wins ? team : min
                );
                const leastPoints = standings.reduce((min, team) =>
                    team.points_for < min.points_for ? team : min
                );
                const champion = standings.find(team => team.rank === 1);

                // Track awards
                if (champion) {
                    if (!managerAwards[champion.manager]) managerAwards[champion.manager] = {};
                    managerAwards[champion.manager].championships = (managerAwards[champion.manager].championships || 0) + 1;
                }

                if (!managerAwards[mostWins.manager]) managerAwards[mostWins.manager] = {};
                managerAwards[mostWins.manager].regularSeason = (managerAwards[mostWins.manager].regularSeason || 0) + 1;

                if (!managerAwards[mostPoints.manager]) managerAwards[mostPoints.manager] = {};
                managerAwards[mostPoints.manager].scoringChamp = (managerAwards[mostPoints.manager].scoringChamp || 0) + 1;

                if (!managerAwards[fewestWins.manager]) managerAwards[fewestWins.manager] = {};
                managerAwards[fewestWins.manager].garbage = (managerAwards[fewestWins.manager].garbage || 0) + 1;

                if (!managerAwards[leastPoints.manager]) managerAwards[leastPoints.manager] = {};
                managerAwards[leastPoints.manager].clown = (managerAwards[leastPoints.manager].clown || 0) + 1;

                // Mike Trout Award (highest scoring hitter)
                const batters = playerStats.filter(p => p.position_type === 'B');
                if (batters.length > 0) {
                    const topHitter = batters.reduce((max, player) =>
                        (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                    );
                    // Find the team_key for this player's manager
                    const playerTeam = standings.find(t => t.team_name === topHitter.team_name);
                    const teamKey = playerTeam ? playerTeam.team_key : null;

                    // NORMALIZE THE MANAGER NAME with team info
                    const normalizedManager = normalizeManagerName(topHitter.manager, parseInt(year), topHitter.team_name, teamKey);
                    if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                    managerAwards[normalizedManager].troutAward = (managerAwards[normalizedManager].troutAward || 0) + 1;
                }

                // Jacob deGrom Award (highest scoring pitcher)
                const pitchers = playerStats.filter(p => p.position_type === 'P');
                if (pitchers.length > 0) {
                    const topPitcher = pitchers.reduce((max, player) =>
                        (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                    );
                    // Find the team_key for this player's manager
                    const playerTeam = standings.find(t => t.team_name === topPitcher.team_name);
                    const teamKey = playerTeam ? playerTeam.team_key : null;

                    // NORMALIZE THE MANAGER NAME with team info
                    const normalizedManager = normalizeManagerName(topPitcher.manager, parseInt(year), topPitcher.team_name, teamKey);
                    if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                    managerAwards[normalizedManager].degromAward = (managerAwards[normalizedManager].degromAward || 0) + 1;
                }

                // Diamond in the Rough & Bust of the Year Awards
                const draftData = data.draftData || [];
                const teamInfo = data.teamInfo || {};
                const keepersForYear = allKeepers[year.toString()] || {};

                // Create lowercase keeper lookup
                const keepersLower = {};
                for (const name of Object.keys(keepersForYear)) {
                    keepersLower[name.toLowerCase()] = true;
                }

                if (draftData.length > 0 && playerStats.length > 0) {
                    // Create player stats lookup by name (lowercase)
                    const playerStatsMap = {};
                    playerStats.forEach(p => {
                        if (p.name) {
                            playerStatsMap[p.name.toLowerCase()] = p;
                        }
                    });

                    // Sort players by fantasy points to get expected value by rank
                    const sortedByPoints = [...playerStats]
                        .filter(p => p.fantasy_points && p.fantasy_points > 0)
                        .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));

                    // Create expected points by overall rank (pick number)
                    const expectedPointsByPick = {};
                    sortedByPoints.forEach((p, idx) => {
                        expectedPointsByPick[idx + 1] = p.fantasy_points || 0;
                    });

                    // Calculate value over expected for each draft pick (excluding keepers)
                    const draftValues = [];
                    draftData.forEach(pick => {
                        const playerName = pick.player_name || '';
                        const pickNum = pick.pick || 0;

                        // Skip keepers
                        if (keepersLower[playerName.toLowerCase()]) {
                            return;
                        }

                        // Get actual points
                        const playerData = playerStatsMap[playerName.toLowerCase()];
                        const actualPoints = playerData ? (playerData.fantasy_points || 0) : 0;

                        // Define headshot
                        const headshot = (playerData && playerData.headshot_url) ? playerData.headshot_url : (pick.headshot_url || '');

                        // Get expected points based on pick position
                        const expectedPoints = expectedPointsByPick[pickNum] || 0;

                        // Calculate value over expected
                        const valueOverExpected = actualPoints - expectedPoints;

                        // Get team info
                        const team = teamInfo[pick.team_key] || {};

                        // Get normalized manager name
                        const managerName = team.manager ? normalizeManagerName(team.manager, parseInt(year), team.name, pick.team_key) : '';

                        draftValues.push({
                            player_name: playerName,
                            player_headshot: headshot,
                            pick: pickNum,
                            round: pick.round || Math.ceil(pickNum / 12),
                            actualPoints: actualPoints,
                            expectedPoints: expectedPoints,
                            valueOverExpected: valueOverExpected,
                            manager: managerName, // Use the normalized name here
                            team_logo: team.logo || ''
                        });
                    });

                    // Find best value (Diamond) - highest positive value over expected
                    if (draftValues.length > 0) {
                        const bestValue = draftValues.reduce((best, pick) =>
                            pick.valueOverExpected > best.valueOverExpected ? pick : best
                        );
                        if (bestValue.valueOverExpected > 0 && bestValue.manager) {
                            const normalizedManager = normalizeManagerName(bestValue.manager, parseInt(year), null, bestValue.team_key);
                            if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                            managerAwards[normalizedManager].diamondAward = (managerAwards[normalizedManager].diamondAward || 0) + 1;
                        }

                        // Find worst value (Bust) - only from first 5 rounds
                        const earlyPicks = draftValues.filter(p => p.round <= 5);
                        if (earlyPicks.length > 0) {
                            const worstValue = earlyPicks.reduce((worst, pick) =>
                                pick.valueOverExpected < worst.valueOverExpected ? pick : worst
                            );
                            if (worstValue.valueOverExpected < 0 && worstValue.manager) {
                                const normalizedManager = normalizeManagerName(worstValue.manager, parseInt(year), null, worstValue.team_key);
                                if (!managerAwards[normalizedManager]) managerAwards[normalizedManager] = {};
                                managerAwards[normalizedManager].bustAward = (managerAwards[normalizedManager].bustAward || 0) + 1;
                            }
                        }
                    }
                }
            }

            return managerAwards;
        }

        // ===== LOAD MANAGER PROFILES =====
        async function loadManagerProfiles() {
            const loadingEl = document.getElementById('managers-loading');
            const errorEl = document.getElementById('managers-error');
            const gridEl = document.getElementById('manager-grid');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                gridEl.innerHTML = '';

                // Load manager stats
                const response = await fetch('data/managers/all_time_stats.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const rawManagersData = await response.json();

                // Load manager history for detailed view
                const historyResponse = await fetch('data/managers/manager_history.json');
                if (historyResponse.ok) {
                    managerHistoryData = await historyResponse.json();
                }

                // Normalize and merge manager data
                allManagersData = normalizeAndMergeManagerData(rawManagersData, managerHistoryData);

                // Determine all unique seasons we need to load
                const allSeasons = new Set();
                allManagersData.forEach(manager => {
                    manager.season_history.forEach(season => {
                        allSeasons.add(season.year);
                    });
                });

                // Pre-load team data for all seasons in parallel
                await Promise.all(Array.from(allSeasons).map(year => getTeamData(year)));

                // Calculate awards for all managers
                const managerAwards = await calculateManagerAwards();
                managerAwardsData = managerAwards; // Store globally for modal access

                // Now build manager logos using cached data
                const managerLogos = {};
                for (const manager of allManagersData) {
                    const recentSeason = Math.max(...manager.season_history.map(s => s.year));
                    const recentSeasonData = manager.season_history.find(s => s.year === recentSeason);

                    const teams = await getTeamData(recentSeason);
                    if (teams) {
                        const managerTeam = teams.find(t => t.team_name === recentSeasonData.team_name);
                        if (managerTeam) {
                            managerLogos[manager.manager_name] = managerTeam.team_logo;
                        }
                    }
                }

                // Determine which managers are currently active
                const currentStandingsResponse = await fetch('data/current_season/standings.json');
                let currentManagers = [];
                if (currentStandingsResponse.ok) {
                    const currentStandings = await currentStandingsResponse.json();
                    const normalizedStandings = normalizeStandingsData(currentStandings, 2025);
                    currentManagers = normalizedStandings.map(team => team.manager);
                }

                // Sort by win percentage (best first)
                allManagersData.sort((a, b) => b.win_pct - a.win_pct);

                allManagersData.forEach(manager => {
                    const isActive = currentManagers.includes(manager.manager_name);
                    const card = document.createElement('div');
                    card.className = isActive ? 'manager-card' : 'manager-card inactive';
                    card.onclick = () => showManagerDetail(manager.manager_name);

                    // Get last season played
                    const lastSeason = Math.max(...manager.season_history.map(s => s.year));

                    // Get logo if available
                    const logo = managerLogos[manager.manager_name] ? `<img src="${managerLogos[manager.manager_name]}" class="manager-logo" alt="${manager.manager_name}">` : '';

                    // Build awards display
                    const awards = managerAwards[manager.manager_name] || {};
                    let awardsHTML = '';

                    const awardsList = [];
                    if (awards.championships) awardsList.push({ type: 'image', src: 'champion_ring.png', count: awards.championships, alt: 'Championship' });
                    if (awards.regularSeason) awardsList.push({ type: 'emoji', emoji: '👑', count: awards.regularSeason });
                    if (awards.scoringChamp) awardsList.push({ type: 'emoji', emoji: '🏅', count: awards.scoringChamp });
                    if (awards.troutAward) awardsList.push({ type: 'image', src: 'attached_assets/trout_award_1764648146923.png', count: awards.troutAward, alt: 'Mike Trout Award' });
                    if (awards.degromAward) awardsList.push({ type: 'image', src: 'attached_assets/degom_award_1764648146918.png', count: awards.degromAward, alt: 'Jacob deGrom Award' });
                    if (awards.diamondAward) awardsList.push({ type: 'emoji', emoji: '💎', count: awards.diamondAward });
                    if (awards.garbage) awardsList.push({ type: 'emoji', emoji: '🗑️', count: awards.garbage });
                    if (awards.clown) awardsList.push({ type: 'image', src: 'clown_award.png', count: awards.clown, alt: 'Clown Award' });
                    if (awards.bustAward) awardsList.push({ type: 'emoji', emoji: '❌', count: awards.bustAward });

                    if (awardsList.length > 0) {
                        awardsHTML = '<div class="awards-row">';
                        awardsList.forEach(award => {
                            awardsHTML += '<div class="award-badge">';
                            if (award.type === 'image') {
                                awardsHTML += `<img src="${award.src}" alt="${award.alt}" class="award-image">`;
                            } else {
                                awardsHTML += award.emoji;
                            }
                            if (award.count > 1) {
                                awardsHTML += `<span class="award-count">x${award.count}</span>`;
                            }
                            awardsHTML += '</div>';
                        });
                        awardsHTML += '</div>';
                    }

                    card.innerHTML = `
                        <h3>${logo}${manager.manager_name}</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                            ${!isActive ? '<div class="badge">Inactive</div>' : '<div class="badge">Active</div>'}
                            ${awardsHTML}
                        </div>
                        <div class="stat"><strong>Year Joined:</strong> ${manager.first_season}</div>
                        <div class="stat"><strong>Years in League:</strong> ${manager.seasons_played}</div>
                        ${!isActive ? `<div class="stat"><strong>Last Season:</strong> ${lastSeason}</div>` : ''}
                        <div class="stat"><strong>All-Time Record:</strong> ${manager.total_wins}-${manager.total_losses}-${manager.total_ties} (${(manager.win_pct * 100).toFixed(1)}%)</div>
                        <div class="stat"><strong>Championships:</strong> ${manager.championships}</div>
                        <div class="stat"><strong>Runner-ups:</strong> ${manager.runner_ups}</div>
                        <div class="stat"><strong>Playoff Apps:</strong> ${manager.playoff_appearances}</div>
                        <div class="stat"><strong>Avg Finish:</strong> ${manager.avg_finish.toFixed(1)}</div>
                    `;
                    gridEl.appendChild(card);
                });

                loadingEl.style.display = 'none';

                // Load and render win percentage chart
                await loadWinPctChart(allManagersData, managerLogos);

            } catch (error) {
                console.error('Error loading manager profiles:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading manager profiles: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        // ===== WIN PERCENTAGE OVER TIME CHART =====
        async function loadWinPctChart(managers, managerLogos) {
            const chartContainer = document.getElementById('winpct-chart-container');
            const chartEl = document.getElementById('winpct-chart');

            try {
                // Load all scores for all seasons
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                const allScoresData = [];
                const seasonStartWeeks = {}; // Track week index where each season starts

                let globalWeekIndex = 0;

                for (const year of seasons) {
                    try {
                        let response;
                        if (year === 2025) {
                            response = await fetch('data/current_season/all_scores.json');
                        } else {
                            response = await fetch(`data/historical/${year}/all_scores.json`);
                        }

                        if (response.ok) {
                            const scores = await response.json();

                            // Load standings to map team_key to manager
                            let standingsResponse;
                            if (year === 2025) {
                                standingsResponse = await fetch('data/current_season/standings.json');
                            } else {
                                standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                            }

                            let standings = [];
                            if (standingsResponse.ok) {
                                standings = await standingsResponse.json();
                                standings = normalizeStandingsData(standings, year);
                            }

                            // Create team_key to manager mapping
                            const teamToManager = {};
                            standings.forEach(team => {
                                teamToManager[team.team_key] = team.manager;
                            });

                            // Get unique weeks in this season
                            const weeksInSeason = [...new Set(scores.map(s => s.week))].sort((a, b) => a - b);

                            // Mark season start
                            seasonStartWeeks[year] = globalWeekIndex;

                            // Add scores with global week index
                            weeksInSeason.forEach((week, weekIdx) => {
                                const weekScores = scores.filter(s => s.week === week);
                                weekScores.forEach(score => {
                                    const manager = teamToManager[score.team_key];
                                    if (manager) {
                                        allScoresData.push({
                                            manager: manager,
                                            year: year,
                                            week: week,
                                            globalWeek: globalWeekIndex + weekIdx,
                                            score: score.team_score,
                                            opponentScore: score.opponent_score,
                                            isWin: score.team_score > score.opponent_score,
                                            isLoss: score.team_score < score.opponent_score
                                        });
                                    }
                                });
                            });

                            globalWeekIndex += weeksInSeason.length;
                        }
                    } catch (e) {
                        console.log(`Could not load ${year} scores for chart`);
                    }
                }

                if (allScoresData.length === 0) {
                    chartContainer.style.display = 'none';
                    return;
                }

                // Process data for chart
                const chartData = processWinPctData(allScoresData, managers, managerLogos, seasonStartWeeks);

                chartContainer.style.display = 'block';

                requestAnimationFrame(() => {
                    renderWinPctChart(chartEl, chartData);
                });

            } catch (error) {
                console.error('Error loading win pct chart:', error);
                chartContainer.style.display = 'none';
            }
        }

        function processWinPctData(scoresData, managers, managerLogos, seasonStartWeeks) {
            // Group scores by manager and calculate cumulative stats
            const managerData = {};

            // Sort by globalWeek
            scoresData.sort((a, b) => a.globalWeek - b.globalWeek);

            // Get all unique global weeks
            const allWeeks = [...new Set(scoresData.map(s => s.globalWeek))].sort((a, b) => a - b);

            // Build week labels (with year markers)
            const weekLabels = [];
            let currentYear = null;
            allWeeks.forEach(globalWeek => {
                const weekData = scoresData.find(s => s.globalWeek === globalWeek);
                if (weekData) {
                    if (weekData.year !== currentYear) {
                        currentYear = weekData.year;
                        weekLabels.push({ globalWeek, label: `${weekData.year}`, isSeasonStart: true, year: weekData.year, week: weekData.week });
                    } else {
                        weekLabels.push({ globalWeek, label: `W${weekData.week}`, isSeasonStart: false, year: weekData.year, week: weekData.week });
                    }
                }
            });

            // Process each score
            scoresData.forEach(score => {
                if (!managerData[score.manager]) {
                    managerData[score.manager] = {
                        manager: score.manager,
                        logo: managerLogos[score.manager] || '',
                        wins: 0,
                        losses: 0,
                        data: [],
                        lastGlobalWeek: 0
                    };
                }

                const md = managerData[score.manager];
                if (score.isWin) md.wins++;
                if (score.isLoss) md.losses++;

                // Calculate Net Wins (Distance from .500)
                // Win = +1, Loss = -1, Tie = 0
                const netWins = md.wins - md.losses;

                md.data.push({
                    globalWeek: score.globalWeek,
                    netWins: netWins, // CHANGED: Store net wins instead of win %
                    wins: md.wins,
                    losses: md.losses,
                    year: score.year,
                    week: score.week
                });

                md.lastGlobalWeek = Math.max(md.lastGlobalWeek, score.globalWeek);
            });

            // Convert to array and sort by final net wins
            const managerArray = Object.values(managerData);
            managerArray.sort((a, b) => {
                const aFinal = a.data.length > 0 ? a.data[a.data.length - 1].netWins : 0;
                const bFinal = b.data.length > 0 ? b.data[b.data.length - 1].netWins : 0;
                return bFinal - aFinal;
            });

            return {
                managers: managerArray,
                weeks: allWeeks,
                weekLabels: weekLabels,
                seasonStartWeeks: seasonStartWeeks,
                maxWeek: Math.max(...allWeeks)
            };
        }

        function renderWinPctChart(container, chartData) {
            container.innerHTML = '';

            // 1. Ensure container is positioned relative so tooltip works correctly
            container.style.position = 'relative';

            const { managers, weeks, weekLabels, seasonStartWeeks, maxWeek } = chartData;

            if (managers.length === 0 || weeks.length === 0) return;

            const isMobile = window.innerWidth <= 768;

            // Chart dimensions
            const containerWidth = container.clientWidth || 900;
            const minChartWidth = isMobile ? Math.max(weeks.length * 20, 600) : Math.max(weeks.length * 12, 800);

            const margin = { top: 40, right: 80, bottom: 80, left: 60 };
            const width = Math.max(minChartWidth, containerWidth - margin.left - margin.right);
            const height = 450;

            const minWeek = Math.min(...weeks);

            // Determine Y-axis domain (Min/Max Net Wins)
            let maxNet = 0;
            let minNet = 0;

            managers.forEach(m => {
                m.data.forEach(d => {
                    if (d.netWins > maxNet) maxNet = d.netWins;
                    if (d.netWins < minNet) minNet = d.netWins;
                });
            });

            // Add padding to Y axis
            maxNet = Math.ceil(Math.max(maxNet, 5) / 5) * 5 + 5;
            minNet = Math.floor(Math.min(minNet, -5) / 5) * 5 - 5;
            const yRange = maxNet - minNet;

            // Scale functions
            const xScale = (globalWeek) => margin.left + ((globalWeek - minWeek) / (maxWeek - minWeek || 1)) * width;
            const yScale = (val) => margin.top + ((maxNet - val) / yRange) * (height - margin.top - margin.bottom);

            // Generate colors
            const colors = generateTeamColors(managers.length);
            const managerColorMap = {};
            managers.forEach((m, i) => {
                managerColorMap[m.manager] = colors[i];
            });

            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            svg.setAttribute('class', 'chart-svg winpct-chart');
            svg.style.display = 'block';

            // --- LAYERS SETUP ---
            // 1. Grid Lines Layer (bottom)
            const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(gridLayer);

            // 2. Data/Chart Layer (middle)
            const chartLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(chartLayer);

            // 3. Y-Axis Layer (top - sticky)
            const yAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            yAxisGroup.setAttribute('class', 'y-axis-group');
            // Add a white background rect to the Y-axis group to obscure lines behind it when scrolling
            const yAxisBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            yAxisBg.setAttribute('x', 0);
            yAxisBg.setAttribute('y', 0);
            yAxisBg.setAttribute('width', margin.left);
            yAxisBg.setAttribute('height', height);
            yAxisBg.setAttribute('fill', 'white');
            yAxisGroup.appendChild(yAxisBg);

            // Add a vertical divider line at the edge of the Y-axis
            const yAxisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxisLine.setAttribute('x1', margin.left);
            yAxisLine.setAttribute('y1', margin.top);
            yAxisLine.setAttribute('x2', margin.left);
            yAxisLine.setAttribute('y2', height - margin.bottom);
            yAxisLine.setAttribute('stroke', '#ccc');
            yAxisLine.setAttribute('stroke-width', '1');
            yAxisGroup.appendChild(yAxisLine);

            svg.appendChild(yAxisGroup);

            // --- SCROLL HANDLER FOR STICKY AXIS ---
            container.addEventListener('scroll', () => {
                yAxisGroup.setAttribute('transform', `translate(${container.scrollLeft}, 0)`);
            });

            // Click background to deselect
            svg.addEventListener('click', (e) => {
                if (e.target === svg) {
                    selectedManager = null;
                    resetHighlights();
                }
            });

            // Draw horizontal grid lines (on Grid Layer) and Labels (on Y-Axis Layer)
            for (let val = minNet; val <= maxNet; val += 5) {
                const y = yScale(val);

                // Grid Line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', margin.left);
                line.setAttribute('y1', y);
                line.setAttribute('x2', margin.left + width);
                line.setAttribute('y2', y);

                if (val === 0) {
                    line.setAttribute('stroke', '#000');
                    line.setAttribute('stroke-width', '2');
                } else {
                    line.setAttribute('stroke', '#e0e0e0');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '3,3');
                }
                gridLayer.appendChild(line);

                // Axis Label (Sticky)
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y + 4);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('font-size', '11px');
                label.setAttribute('fill', val === 0 ? '#000' : '#666');
                label.setAttribute('font-weight', val === 0 ? 'bold' : 'normal');
                const labelText = val > 0 ? `+${val}` : `${val}`;
                label.textContent = labelText;
                yAxisGroup.appendChild(label); // Append to sticky group
            }

            // Draw Y-axis title (Sticky)
            const yTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yTitle.setAttribute('x', 15);
            yTitle.setAttribute('y', height / 2);
            yTitle.setAttribute('text-anchor', 'middle');
            yTitle.setAttribute('font-size', '12px');
            yTitle.setAttribute('fill', '#666');
            yTitle.setAttribute('transform', `rotate(-90, 15, ${height / 2})`);
            yTitle.textContent = 'Games Above .500';
            yAxisGroup.appendChild(yTitle); // Append to sticky group

            // Draw vertical season separator lines
            Object.entries(seasonStartWeeks).forEach(([year, startWeek]) => {
                if (startWeek > minWeek) {
                    const x = xScale(startWeek);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', margin.top);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', height - margin.bottom);
                    line.setAttribute('stroke', '#1e3c72');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('stroke-dasharray', '5,3');
                    gridLayer.appendChild(line);
                }
            });

            // Draw X-axis labels
            weekLabels.forEach((wl, idx) => {
                const showLabel = wl.isSeasonStart || idx % (isMobile ? 8 : 4) === 0;
                if (!showLabel && !wl.isSeasonStart) return;

                const x = xScale(wl.globalWeek);
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - margin.bottom + 15);
                label.setAttribute('text-anchor', 'start');
                label.setAttribute('font-size', wl.isSeasonStart ? '12px' : '10px');
                label.setAttribute('font-weight', wl.isSeasonStart ? 'bold' : 'normal');
                label.setAttribute('fill', wl.isSeasonStart ? '#1e3c72' : '#666');
                label.setAttribute('transform', `rotate(45, ${x}, ${height - margin.bottom + 15})`);
                label.textContent = wl.isSeasonStart ? wl.year : wl.label;
                gridLayer.appendChild(label); // X-axis moves with scroll, so put on gridLayer
            });

            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'chart-tooltip';
            tooltip.style.display = 'none';
            container.appendChild(tooltip);

            // --- STATE MANAGEMENT ---
            let selectedManager = null; // Track locked line

            // Helper to apply visual styles
            const applyHighlight = (managerName) => {
                document.querySelectorAll('.winpct-chart .chart-line').forEach(line => {
                    if (line.getAttribute('data-manager') === managerName) {
                        line.classList.add('highlighted');
                        line.classList.remove('faded');
                        // Move to end of chartLayer to be on top of others
                        if (line.parentNode === chartLayer) {
                            chartLayer.appendChild(line);
                        }
                    } else {
                        line.classList.add('faded');
                        line.classList.remove('highlighted');
                    }
                });
            };

            const resetHighlights = () => {
                document.querySelectorAll('.winpct-chart .chart-line').forEach(line => {
                    line.classList.remove('highlighted', 'faded');
                });
            };

            // Draw lines for each manager
            const lineGroups = [];

            managers.forEach((manager, idx) => {
                if (manager.data.length < 2) return;

                const color = managerColorMap[manager.manager];
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'chart-line');
                group.setAttribute('data-manager', manager.manager);

                // Build path
                let pathD = '';
                manager.data.forEach((point, i) => {
                    const x = xScale(point.globalWeek);
                    const y = yScale(point.netWins);
                    pathD += (i === 0 ? 'M' : 'L') + `${x},${y} `;
                });

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathD.trim());
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', '2.5');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('stroke-linecap', 'round');
                group.appendChild(path);

                // Invisible wider path for hover detection
                const hoverPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hoverPath.setAttribute('d', pathD.trim());
                hoverPath.setAttribute('fill', 'none');
                hoverPath.setAttribute('stroke', 'transparent');
                hoverPath.setAttribute('stroke-width', '15');
                hoverPath.style.cursor = 'pointer';
                group.appendChild(hoverPath);

                // Logo/End marker
                const lastPoint = manager.data[manager.data.length - 1];
                const logoX = xScale(lastPoint.globalWeek);
                const logoY = yScale(lastPoint.netWins);
                const logoRadius = 14;

                if (manager.logo) {
                    const clipId = `winpct-clip-${idx}`;
                    const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                    clipPath.setAttribute('id', clipId);
                    const clipCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    clipCircle.setAttribute('cx', logoX);
                    clipCircle.setAttribute('cy', logoY);
                    clipCircle.setAttribute('r', logoRadius);
                    clipPath.appendChild(clipCircle);
                    svg.appendChild(clipPath); // Defines must be in SVG, usually ok anywhere

                    const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    bgCircle.setAttribute('cx', logoX);
                    bgCircle.setAttribute('cy', logoY);
                    bgCircle.setAttribute('r', logoRadius + 2);
                    bgCircle.setAttribute('fill', 'white');
                    bgCircle.setAttribute('stroke', color);
                    bgCircle.setAttribute('stroke-width', '2');
                    group.appendChild(bgCircle);

                    const logoImg = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                    logoImg.setAttribute('x', logoX - logoRadius);
                    logoImg.setAttribute('y', logoY - logoRadius);
                    logoImg.setAttribute('width', logoRadius * 2);
                    logoImg.setAttribute('height', logoRadius * 2);
                    logoImg.setAttribute('href', manager.logo);
                    logoImg.setAttribute('clip-path', `url(#${clipId})`);
                    logoImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
                    group.appendChild(logoImg);
                } else {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', logoX);
                    circle.setAttribute('cy', logoY);
                    circle.setAttribute('r', logoRadius);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', 'white');
                    circle.setAttribute('stroke-width', '2');
                    group.appendChild(circle);

                    const initial = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    initial.setAttribute('x', logoX);
                    initial.setAttribute('y', logoY + 5);
                    initial.setAttribute('text-anchor', 'middle');
                    initial.setAttribute('fill', 'white');
                    initial.setAttribute('font-size', '12px');
                    initial.setAttribute('font-weight', 'bold');
                    initial.textContent = manager.manager.charAt(0);
                    group.appendChild(initial);
                }

                const finalNetWins = lastPoint.netWins;

                // --- EVENTS ---

                // Click to toggle Highlight
                group.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent SVG background click
                    if (selectedManager === manager.manager) {
                        // Deselect if clicking the same one
                        selectedManager = null;
                        resetHighlights();
                    } else {
                        // Select new one
                        selectedManager = manager.manager;
                        applyHighlight(manager.manager);
                    }
                });

                // Hover Effects
                group.addEventListener('mouseenter', (e) => {
                    // Always highlight on hover, even if something else is selected (transient view)
                    applyHighlight(manager.manager);

                    // Show tooltip with Logo
                    const sign = finalNetWins > 0 ? '+' : '';

                    // Construct Logo HTML
                    const logoHtml = manager.logo ?
                        `<img src="${manager.logo}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; border: 2px solid ${color};">` :
                        `<div style="width: 40px; height: 40px; border-radius: 50%; background: ${color}; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 18px; border: 2px solid white;">${manager.manager.charAt(0)}</div>`;

                    tooltip.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            ${logoHtml}
                            <div>
                                <div style="font-weight: bold; font-size: 1.1em;">${manager.manager}</div>
                                <div style="margin-top: 2px; color: #ccc;">Record: ${manager.wins}-${manager.losses}</div>
                                <div style="margin-top: 2px; color: ${finalNetWins >= 0 ? '#4cd137' : '#ff4757'}; font-weight: bold;">
                                    ${sign}${finalNetWins} games
                                </div>
                            </div>
                        </div>
                    `;
                    tooltip.style.display = 'block';
                });

                // Tooltip follow mouse (FIXED for scrolling)
                group.addEventListener('mousemove', (e) => {
                    const rect = container.getBoundingClientRect();
                    const scrollLeft = container.scrollLeft;

                    tooltip.style.left = (e.clientX - rect.left + scrollLeft + 15) + 'px';
                    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
                });

                // Mouse Leave
                group.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';

                    // If a manager is selected, revert to highlighting them
                    if (selectedManager) {
                        applyHighlight(selectedManager);
                    } else {
                        // Otherwise reset to all visible
                        resetHighlights();
                    }
                });

                lineGroups.push(group);
            });

            // Add lines to Chart Layer
            lineGroups.reverse().forEach(g => chartLayer.appendChild(g));

            container.appendChild(svg);
        }

        // ===== SHOW MANAGER DETAIL MODAL =====
        async function showManagerDetail(managerName) {
            const manager = allManagersData.find(m => m.manager_name === managerName);
            if (!manager) return;

            const modal = document.getElementById('manager-modal');
            const modalBody = document.getElementById('modal-body');

            // Load team logos for each season using cached data
            const seasonLogos = {};
            for (const season of manager.season_history) {
                const teams = await getTeamData(season.year);
                if (teams) {
                    const managerTeam = teams.find(t => t.team_name === season.team_name);
                    if (managerTeam) {
                        seasonLogos[season.year] = managerTeam.team_logo;
                    }
                }
            }

            // Build season timeline
            const seasonHistory = manager.season_history.sort((a, b) => b.year - a.year);
            let timelineHTML = seasonHistory.map(season => {
                let rankClass = '';
                let rankText = `#${season.rank}`;

                if (season.rank === 1) {
                    rankClass = 'champion';
                    rankText = '🏆 Champion';
                } else if (season.rank === 2) {
                    rankClass = 'runner-up';
                    rankText = '🥈 Runner-up';
                }

                const logo = seasonLogos[season.year] ? `<img src="${seasonLogos[season.year]}" class="timeline-logo" alt="${season.team_name}">` : '';

                return `
                    <div class="timeline-item">
                        <div class="year">${season.year}</div>
                        <div class="details">
                            <span class="rank ${rankClass}">${rankText}</span>
                            <span>${season.wins}-${season.losses} | ${season.points_for.toLocaleString()} pts</span>
                            <div style="margin-top: 0.25rem; color: #666; font-size: 0.9rem;">
                                Team: ${season.team_name}
                            </div>
                        </div>
                        ${logo}
                    </div>
                `;
            }).join('');

            // Calculate head-to-head records
            const h2hRecords = await calculateHeadToHeadRecords(managerName);
            let h2hHTML = '';

            if (h2hRecords.length > 0) {
                h2hHTML = `
                    <div class="timeline">
                        <h3>Head-to-Head Records</h3>
                        <table class="matchup-table" id="h2h-table">
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortH2HTable(0, 'string')">Opponent</th>
                                    <th class="sortable" onclick="sortH2HTable(1, 'record')">Record</th>
                                    <th class="sortable" onclick="sortH2HTable(2, 'number')">Win %</th>
                                    <th class="sortable" onclick="sortH2HTable(3, 'number')">Avg Points For</th>
                                    <th class="sortable" onclick="sortH2HTable(4, 'number')">Avg Points Against</th>
                                </tr>
                            </thead>
                            <tbody id="h2h-body">
                                ${h2hRecords.map(record => `
                                    <tr>
                                        <td>${record.opponent}</td>
                                        <td>${record.wins}-${record.losses}</td>
                                        <td>${(record.win_pct * 100).toFixed(1)}%</td>
                                        <td>${record.avg_points_for.toFixed(1)}</td>
                                        <td>${record.avg_points_against.toFixed(1)}</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }

            modalBody.innerHTML = `
                <div class="modal-stats">
                    <div class="stat-box">
                        <div class="value">${manager.total_wins}-${manager.total_losses}-${manager.total_ties}</div>
                        <div class="label">All-Time Record</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${(manager.win_pct * 100).toFixed(1)}%</div>
                        <div class="label">Win Percentage</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.championships}</div>
                        <div class="label">Championships</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.avg_finish.toFixed(1)}</div>
                        <div class="label">Avg Finish</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.playoff_appearances}</div>
                        <div class="label">Playoff Apps</div>
                    </div>
                    <div class="stat-box">
                        <div class="value">${manager.total_points_for.toLocaleString()}</div>
                        <div class="label">Career Points</div>
                    </div>
                </div>
                
                <div class="timeline">
                    <h3>Season-by-Season Timeline</h3>
                    ${timelineHTML}
                </div>
                
                ${h2hHTML}
            `;

            // Set the header separately with awards emojis
            const modalHeaderSection = document.getElementById('modal-header-section');

            // Build awards display for modal header (same format as cards)
            const awards = managerAwardsData[manager.manager_name] || {};
            let modalAwardsHTML = '';

            const awardsList = [];
            if (awards.championships) awardsList.push({ type: 'image', src: 'champion_ring.png', count: awards.championships, alt: 'Championship' });
            if (awards.regularSeason) awardsList.push({ type: 'emoji', emoji: '👑', count: awards.regularSeason });
            if (awards.scoringChamp) awardsList.push({ type: 'emoji', emoji: '🏅', count: awards.scoringChamp });
            if (awards.troutAward) awardsList.push({ type: 'image', src: 'attached_assets/trout_award_1764648146923.png', count: awards.troutAward, alt: 'Mike Trout Award' });
            if (awards.degromAward) awardsList.push({ type: 'image', src: 'attached_assets/degom_award_1764648146918.png', count: awards.degromAward, alt: 'Jacob deGrom Award' });
            if (awards.diamondAward) awardsList.push({ type: 'emoji', emoji: '💎', count: awards.diamondAward });
            if (awards.garbage) awardsList.push({ type: 'emoji', emoji: '🗑️', count: awards.garbage });
            if (awards.clown) awardsList.push({ type: 'image', src: 'clown_award.png', count: awards.clown, alt: 'Clown Award' });
            if (awards.bustAward) awardsList.push({ type: 'emoji', emoji: '❌', count: awards.bustAward });

            if (awardsList.length > 0) {
                modalAwardsHTML = '<div class="awards-row">';
                awardsList.forEach(award => {
                    modalAwardsHTML += '<div class="award-badge">';
                    if (award.type === 'image') {
                        modalAwardsHTML += `<img src="${award.src}" alt="${award.alt}" class="award-image">`;
                    } else {
                        modalAwardsHTML += award.emoji;
                    }
                    if (award.count > 1) {
                        modalAwardsHTML += `<span class="award-count">x${award.count}</span>`;
                    }
                    modalAwardsHTML += '</div>';
                });
                modalAwardsHTML += '</div>';
            }

            modalHeaderSection.innerHTML = `
                <div class="modal-header">
                    <div style="display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
                        <h2 style="margin: 0;">${manager.manager_name}</h2>
                        ${modalAwardsHTML}
                    </div>
                    <p style="color: #666; margin-top: 0.5rem;">Joined ${manager.first_season} | ${manager.seasons_played} seasons</p>
                </div>
            `;

            // Store h2h data for sorting
            window.currentH2HData = h2hRecords;
            window.currentSortColumn = null;
            window.currentSortDirection = 'desc';

            modal.classList.add('active');
        }

        // ===== SORT HEAD-TO-HEAD TABLE =====
        function sortH2HTable(columnIndex, dataType) {
            const tbody = document.getElementById('h2h-body');
            const headers = document.querySelectorAll('#h2h-table th');

            if (!window.currentH2HData || window.currentH2HData.length === 0) return;

            // Toggle sort direction if clicking same column
            if (window.currentSortColumn === columnIndex) {
                window.currentSortDirection = window.currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                window.currentSortColumn = columnIndex;
                window.currentSortDirection = 'desc'; // Default to descending
            }

            // Update header classes
            headers.forEach((header, index) => {
                header.classList.remove('sorted-asc', 'sorted-desc');
                if (index === columnIndex) {
                    header.classList.add(window.currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });

            // Sort the data
            const sortedData = [...window.currentH2HData].sort((a, b) => {
                let valueA, valueB;

                switch (columnIndex) {
                    case 0: // Opponent
                        valueA = a.opponent.toLowerCase();
                        valueB = b.opponent.toLowerCase();
                        break;
                    case 1: // Record (by total wins)
                        valueA = a.wins;
                        valueB = b.wins;
                        break;
                    case 2: // Win %
                        valueA = a.win_pct;
                        valueB = b.win_pct;
                        break;
                    case 3: // Avg Points For
                        valueA = a.avg_points_for;
                        valueB = b.avg_points_for;
                        break;
                    case 4: // Avg Points Against
                        valueA = a.avg_points_against;
                        valueB = b.avg_points_against;
                        break;
                }

                if (window.currentSortDirection === 'asc') {
                    return valueA > valueB ? 1 : valueA < valueB ? -1 : 0;
                } else {
                    return valueA < valueB ? 1 : valueA > valueB ? -1 : 0;
                }
            });

            // Update table
            tbody.innerHTML = sortedData.map(record => `
                <tr>
                    <td>${record.opponent}</td>
                    <td>${record.wins}-${record.losses}</td>
                    <td>${(record.win_pct * 100).toFixed(1)}%</td>
                    <td>${record.avg_points_for.toFixed(1)}</td>
                    <td>${record.avg_points_against.toFixed(1)}</td>
                </tr>
            `).join('');
        }

        // ===== CALCULATE HEAD-TO-HEAD RECORDS =====
        async function calculateHeadToHeadRecords(managerName) {
            try {
                // Get all available seasons and load their scores
                const h2hMap = {};

                const manager = allManagersData.find(m => m.manager_name === managerName);
                if (!manager) return [];

                for (const season of manager.season_history.map(h => h.year)) {
                    try {
                        let scoresResponse;
                        if (season === 2025) {
                            scoresResponse = await fetch('data/current_season/all_scores.json');
                        } else {
                            scoresResponse = await fetch(`data/historical/${season}/all_scores.json`);
                        }

                        if (!scoresResponse.ok) continue;

                        const scores = await scoresResponse.json();
                        let standings = season === 2025
                            ? await (await fetch('data/current_season/standings.json')).json()
                            : await (await fetch(`data/historical/${season}/final_standings.json`)).json();

                        // Normalize standings
                        standings = normalizeStandingsData(standings, season);

                        // Create team_key to manager mapping
                        const teamToManager = {};
                        standings.forEach(team => {
                            teamToManager[team.team_key] = team.manager;
                        });

                        // Find manager's team key
                        const managerTeam = standings.find(team => team.manager === managerName);
                        if (!managerTeam) continue;

                        // Process matchups
                        scores.forEach(matchup => {
                            if (matchup.team_key === managerTeam.team_key) {
                                const opponent = teamToManager[matchup.opponent_key];
                                if (!opponent) return;

                                if (!h2hMap[opponent]) {
                                    h2hMap[opponent] = {
                                        opponent: opponent,
                                        wins: 0,
                                        losses: 0,
                                        total_points_for: 0,
                                        total_points_against: 0,
                                        games: 0
                                    };
                                }

                                h2hMap[opponent].games++;
                                h2hMap[opponent].total_points_for += matchup.team_score;
                                h2hMap[opponent].total_points_against += matchup.opponent_score;

                                if (matchup.team_score > matchup.opponent_score) {
                                    h2hMap[opponent].wins++;
                                } else if (matchup.team_score < matchup.opponent_score) {
                                    h2hMap[opponent].losses++;
                                }
                            }
                        });
                    } catch (e) {
                        console.log(`Could not load scores for ${season}`);
                    }
                }

                // Convert to array and calculate averages
                const h2hRecords = Object.values(h2hMap).map(record => ({
                    ...record,
                    win_pct: record.wins / (record.wins + record.losses),
                    avg_points_for: record.total_points_for / record.games,
                    avg_points_against: record.total_points_against / record.games
                }));

                // Sort by win percentage
                h2hRecords.sort((a, b) => b.win_pct - a.win_pct);

                return h2hRecords;
            } catch (error) {
                console.error('Error calculating head-to-head:', error);
                return [];
            }
        }

        // ===== CLOSE MANAGER MODAL =====
        function closeManagerModal() {
            const modal = document.getElementById('manager-modal');
            modal.classList.remove('active');
        }

        // Close modal when clicking outside
        window.onclick = function (event) {
            const modal = document.getElementById('manager-modal');
            if (event.target === modal) {
                closeManagerModal();
            }
        }

        // ===== NAVIGATION =====
        async function showSection(sectionId) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(section => {
                section.classList.remove('active');
            });

            // Remove active class from all desktop nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Remove active class from all mobile nav buttons
            document.querySelectorAll('.mobile-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected section
            document.getElementById(sectionId).classList.add('active');

            // Add active class to clicked button (both desktop and mobile)
            if (event && event.target) {
                event.target.closest('button')?.classList.add('active');
            }

            // Also update the corresponding nav buttons by section ID
            const sectionToIndex = {
                'standings': 0,
                'awards': 1,
                'champions': 2,
                'scoring': 3,
                'managers': 4
            };
            const index = sectionToIndex[sectionId];
            if (index !== undefined) {
                document.querySelectorAll('.nav-btn')[index]?.classList.add('active');
                document.querySelectorAll('.mobile-nav-btn')[index]?.classList.add('active');
            }

            // Load section-specific data
            if (sectionId === 'awards') {
                loadAwards();
            } else if (sectionId === 'champions') {
                loadChampionData();
            } else if (sectionId === 'scoring') {
                // Load player scoring if not already loaded
                if (allPlayersData.length === 0) {
                    loadPlayerScoring();
                }
            }
            else if (sectionId === 'preseason') {
                // Initialize keeper management first, then load projections
                // This ensures keeper data is available when rendering the table
                if (!keeperConfig) {
                    await initializeKeeperManagement();
                }
                // Initialize trade management (must be after keeper management)
                await initializeTradeManagement();

                // Refresh league keepers display once after everything is loaded
                // This ensures round costs properly account for traded picks
                // Only call if keeperConfig exists (meaning initialization already happened)
                if (keeperConfig) {
                    displayLeagueKeepers();
                }

                // Load projections if not already loaded
                if (allProjectionBatters.length === 0 && allProjectionPitchers.length === 0) {
                    loadProjections();
                } else {
                    // If projections already loaded, refresh the table to show keeper info
                    filterProjections();
                }
            }
        }

        // ===== HALL OF CHAMPIONS =====
        let championsDataLoaded = false;
        let allChampionsData = {};

        async function loadChampionData() {
            const loadingEl = document.getElementById('champions-loading');
            const errorEl = document.getElementById('champions-error');
            const contentEl = document.getElementById('champions-content');
            const seasonSelect = document.getElementById('champions-season');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                contentEl.style.display = 'none';

                // Populate season dropdown if not already done
                if (seasonSelect.options.length === 0) {
                    const seasons = [2025, 2024, 2023, 2022, 2021, 2020, 2019];
                    seasons.forEach(year => {
                        const option = document.createElement('option');
                        option.value = year;
                        option.textContent = year === 2025 ? '2025 (Current)' : year;
                        seasonSelect.appendChild(option);
                    });
                }

                const selectedYear = parseInt(seasonSelect.value) || 2025;
                const isCurrentSeason = selectedYear === 2025;
                const dataPath = isCurrentSeason ? 'data/current_season' : `data/historical/${selectedYear}`;

                // Load standings to find champion
                const standingsFile = isCurrentSeason ? 'standings.json' : 'final_standings.json';
                const standingsResponse = await fetch(`${dataPath}/${standingsFile}`);
                if (!standingsResponse.ok) throw new Error(`No data for ${selectedYear}`);
                let standings = await standingsResponse.json();
                standings = normalizeStandingsData(standings, selectedYear);

                // Find champion (rank 1)
                const champion = standings.find(team => team.rank === 1);
                if (!champion) throw new Error('Champion not found');

                // Load teams data for logo
                const teamsResponse = await fetch(`${dataPath}/teams.json`);
                let teams = [];
                if (teamsResponse.ok) {
                    teams = await teamsResponse.json();
                }
                const championTeam = teams.find(t => t.team_key === champion.team_key);
                const teamLogo = championTeam?.team_logo || '';

                // Load scores for schedule
                const scoresResponse = await fetch(`${dataPath}/all_scores.json`);
                let scores = [];
                if (scoresResponse.ok) {
                    scores = await scoresResponse.json();
                }

                // Load player stats for roster
                const playerStatsResponse = await fetch(`${dataPath}/player_stats.json`);
                let playerStats = [];
                if (playerStatsResponse.ok) {
                    playerStats = await playerStatsResponse.json();
                }

                // Count championships for this manager (and check for back-to-back)
                const championshipInfo = await countManagerChampionships(champion.manager, selectedYear);

                // Render champion header
                renderChampionHeader(champion, teamLogo, selectedYear, isCurrentSeason);

                // Render championship count
                renderChampionshipCount(championshipInfo);

                // Render stats
                renderChampionStats(champion, scores, standings);

                // Render schedule
                renderChampionSchedule(champion, scores, standings, teams);

                // Render roster
                renderChampionRoster(champion, playerStats);

                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading champion data:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        async function countManagerChampionships(managerName, upToYear) {
            const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            let count = 0;
            let thisIsNth = 0;
            let championshipYears = [];

            for (const year of seasons) {
                if (year > upToYear) break;
                try {
                    let response;
                    if (year === 2025) {
                        response = await fetch('data/current_season/standings.json');
                    } else {
                        response = await fetch(`data/historical/${year}/final_standings.json`);
                    }
                    if (response.ok) {
                        let standings = await response.json();
                        standings = normalizeStandingsData(standings, year);
                        const champ = standings.find(t => t.rank === 1);
                        if (champ && champ.manager === managerName) {
                            count++;
                            championshipYears.push(year);
                            if (year === upToYear) {
                                thisIsNth = count;
                            }
                        }
                    }
                } catch (e) {
                    console.log(`Could not load ${year} standings`);
                }
            }

            // Check for back-to-back (consecutive years)
            let isBackToBack = false;
            let consecutiveCount = 1;

            if (championshipYears.length >= 2) {
                const currentIndex = championshipYears.indexOf(upToYear);
                if (currentIndex > 0) {
                    // Check if previous championship was the year before
                    const prevYear = championshipYears[currentIndex - 1];
                    if (prevYear === upToYear - 1) {
                        isBackToBack = true;
                        // Count consecutive championships
                        consecutiveCount = 2;
                        for (let i = currentIndex - 2; i >= 0; i--) {
                            if (championshipYears[i] === championshipYears[i + 1] - 1) {
                                consecutiveCount++;
                            } else {
                                break;
                            }
                        }
                    }
                }
            }

            return {
                nth: thisIsNth,
                total: count,
                isBackToBack: isBackToBack,
                consecutiveCount: consecutiveCount,
                years: championshipYears
            };
        }

        function getOrdinal(n) {
            const s = ["th", "st", "nd", "rd"];
            const v = n % 100;
            return n + (s[(v - 20) % 10] || s[v] || s[0]);
        }

        function renderChampionHeader(champion, teamLogo, year, isCurrentSeason) {
            const headerEl = document.getElementById('champion-header');
            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzFhMWEyZSIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZm9udC1zaXplPSI0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iI2ZmZCI+8J+Phjwv dGV4dD48L3N2Zz4=';

            const seasonLabel = isCurrentSeason ? `${year} Season Leader` : `${year} Season Champion`;

            headerEl.innerHTML = `
                <img src="${teamLogo || placeholderLogo}" alt="${champion.team_name}" class="team-logo" onerror="this.src='${placeholderLogo}'">
                <div class="champion-info">
                    <h3>${champion.team_name}</h3>
                    <div class="manager-name">Manager: ${champion.manager}</div>
                    <div class="season-year">${seasonLabel}</div>
                </div>
                <div class="trophy-icon">🏆</div>
            `;
        }

        function renderChampionshipCount(info) {
            const bannerEl = document.getElementById('championship-count-banner');

            if (!info || info.nth === 0) {
                bannerEl.style.display = 'none';
                return;
            }

            const { nth, isBackToBack, consecutiveCount } = info;
            const ordinal = getOrdinal(nth);
            let message = '';

            if (nth === 1) {
                message = `🌟 First Championship Title! 🌟`;
            } else if (isBackToBack) {
                if (consecutiveCount === 2) {
                    message = `🔥 Back-to-Back Champions! ${ordinal} Title! 🔥`;
                } else if (consecutiveCount === 3) {
                    message = `👑 THREE-PEAT! ${ordinal} Championship! 👑`;
                } else if (consecutiveCount >= 4) {
                    message = `🏆👑 ${consecutiveCount}-PEAT DYNASTY! ${ordinal} Championship! 👑🏆`;
                }
            } else if (nth >= 3) {
                message = `👑 Dynasty Alert: ${ordinal} Championship! 👑`;
            } else {
                message = `🎉 ${ordinal} Championship Title! 🎉`;
            }

            bannerEl.innerHTML = message;
            bannerEl.style.display = 'block';
        }

        function renderChampionStats(champion, scores, standings) {
            // Calculate stats from scores
            const championScores = scores.filter(s => s.team_key === champion.team_key);

            let wins = 0, losses = 0, totalPoints = 0, bestWeek = 0;
            championScores.forEach(matchup => {
                totalPoints += matchup.team_score || 0;
                if (matchup.team_score > matchup.opponent_score) wins++;
                else if (matchup.team_score < matchup.opponent_score) losses++;
                if (matchup.team_score > bestWeek) bestWeek = matchup.team_score;
            });

            const gamesPlayed = wins + losses;
            const ppg = gamesPlayed > 0 ? (totalPoints / gamesPlayed).toFixed(1) : '-';

            document.getElementById('champion-record').textContent = `${wins}-${losses}`;
            document.getElementById('champion-points').textContent = totalPoints.toFixed(1);
            document.getElementById('champion-ppg').textContent = ppg;
            document.getElementById('champion-best-week').textContent = bestWeek.toFixed(1);
        }

        function renderChampionSchedule(champion, scores, standings, teams) {
            const tbody = document.getElementById('champion-schedule');
            const championScores = scores.filter(s => s.team_key === champion.team_key);

            // Create team key to name and logo mapping
            const teamKeyToInfo = {};
            standings.forEach(team => {
                const teamData = teams.find(t => t.team_key === team.team_key);
                teamKeyToInfo[team.team_key] = {
                    name: team.team_name,
                    logo: teamData?.team_logo || ''
                };
            });

            // Sort by week
            championScores.sort((a, b) => a.week - b.week);

            // Determine playoff weeks (usually last 3-4 weeks)
            const maxWeek = Math.max(...championScores.map(s => s.week));
            const playoffStart = maxWeek - 2; // Assume 3 week playoffs

            const placeholderLogo = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjwvc3ZnPg==';

            tbody.innerHTML = championScores.map(matchup => {
                const opponentInfo = teamKeyToInfo[matchup.opponent_key] || { name: 'Unknown', logo: '' };
                const opponentLogo = opponentInfo.logo || placeholderLogo;
                const isWin = matchup.team_score > matchup.opponent_score;
                const result = isWin ? 'W' : 'L';
                const resultClass = isWin ? 'result-win' : 'result-loss';
                const rowResultClass = isWin ? 'schedule-row-win' : 'schedule-row-loss';

                let rowClass = rowResultClass;

                // CHANGED: Wrap "Week " in a span so we can hide it with CSS on mobile
                const weekPrefix = '<span class="week-text">Week </span>';
                let weekLabel = `${weekPrefix}${matchup.week}`;

                if (matchup.week >= playoffStart) {
                    rowClass += ' playoff-week';
                    if (matchup.week === maxWeek) {
                        rowClass += ' championship-week';
                        weekLabel = `${weekPrefix}${matchup.week} 🏆`;
                    } else {
                        weekLabel = `${weekPrefix}${matchup.week} ⭐`;
                    }
                }

                return `
                    <tr class="${rowClass}">
                        <td>${weekLabel}</td>
                        <td>
                            <div class="schedule-opponent">
                                <img src="${opponentLogo}" alt="" class="schedule-team-logo" onerror="this.style.display='none'">
                                <span>${opponentInfo.name}</span>
                            </div>
                        </td>
                        <td>${matchup.team_score.toFixed(1)} - ${matchup.opponent_score.toFixed(1)}</td>
                        <td class="${resultClass}">${result}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderChampionRoster(champion, playerStats) {
            const rosterEl = document.getElementById('champion-roster');

            // Filter players on champion's team
            const rosterPlayers = playerStats.filter(p => p.team_key === champion.team_key);

            if (rosterPlayers.length === 0) {
                rosterEl.innerHTML = '<p style="color: #666; text-align: center;">Roster data not available for this season.</p>';
                return;
            }

            // Separate by position type and points
            const batters = rosterPlayers.filter(p => p.position_type === 'B' && (p.fantasy_points || 0) > 0);
            const pitchers = rosterPlayers.filter(p => p.position_type === 'P' && (p.fantasy_points || 0) > 0);
            const prospects = rosterPlayers.filter(p => (p.fantasy_points || 0) === 0);

            // Sort each group by fantasy points descending
            batters.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            pitchers.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
            prospects.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            const renderPlayerCard = (player, isProspect = false) => {
                const headshot = player.headshot_url || placeholderImg;
                const points = (player.fantasy_points || 0).toFixed(1);
                const cardClass = isProspect ? 'roster-player-card prospect' : 'roster-player-card';
                return `
                    <div class="${cardClass}">
                        <img src="${headshot}" alt="${player.name}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                        <div class="player-info">
                            <div class="player-name">${player.name}</div>
                            <div class="player-position">${player.primary_position || '-'}</div>
                        </div>
                        <div class="player-points">
                            <div class="points-value">${points}</div>
                            <div class="points-label">pts</div>
                        </div>
                    </div>
                `;
            };

            let html = '<div class="roster-columns">';

            // Batters column
            html += '<div class="roster-column">';
            if (batters.length > 0) {
                html += `<div class="roster-section-title">⚾ Batters (${batters.length})</div>`;
                html += `<div class="roster-grid">${batters.map(p => renderPlayerCard(p, false)).join('')}</div>`;
            }
            html += '</div>';

            // Pitchers column
            html += '<div class="roster-column">';
            if (pitchers.length > 0) {
                html += `<div class="roster-section-title">🎯 Pitchers (${pitchers.length})</div>`;
                html += `<div class="roster-grid">${pitchers.map(p => renderPlayerCard(p, false)).join('')}</div>`;
            }
            html += '</div>';

            html += '</div>';

            // Prospects section (players with 0 points)
            if (prospects.length > 0) {
                html += '<div class="prospects-section">';
                html += `<div class="roster-section-title">🌱 Prospects (${prospects.length})</div>`;
                html += `<div class="roster-grid">${prospects.map(p => renderPlayerCard(p, true)).join('')}</div>`;
                html += '</div>';
            }

            rosterEl.innerHTML = html;
        }

        // ===== LOAD AWARDS =====
        async function loadAwards() {
            console.log("Loading awards...");
            const loadingEl = document.getElementById('awards-loading');
            const errorEl = document.getElementById('awards-error');
            const contentEl = document.getElementById('awards-content');

            try {
                loadingEl.style.display = 'block';
                errorEl.style.display = 'none';
                contentEl.style.display = 'none';

                // Load all seasons data
                const seasons = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
                const seasonData = {};

                console.log("Fetching data for seasons:", seasons);

                for (const year of seasons) {
                    try {
                        let standingsResponse, teamsResponse, playerStatsResponse, draftResponse;

                        if (year === 2025) {
                            standingsResponse = await fetch('data/current_season/standings.json');
                            teamsResponse = await fetch('data/current_season/teams.json');
                            playerStatsResponse = await fetch('data/current_season/player_stats.json');
                            draftResponse = await fetch('data/current_season/draft.json');
                        } else {
                            standingsResponse = await fetch(`data/historical/${year}/final_standings.json`);
                            teamsResponse = await fetch(`data/historical/${year}/teams.json`);
                            playerStatsResponse = await fetch(`data/historical/${year}/player_stats.json`);
                            draftResponse = await fetch(`data/historical/${year}/draft.json`);
                        }

                        console.log(`${year}: standings=${standingsResponse.ok}, teams=${teamsResponse.ok}, playerStats=${playerStatsResponse.ok}`);

                        if (standingsResponse.ok && teamsResponse.ok) {
                            const standings = await standingsResponse.json();
                            const teams = await teamsResponse.json();
                            const playerStats = playerStatsResponse.ok ? await playerStatsResponse.json() : [];
                            const draftData = draftResponse && draftResponse.ok ? await draftResponse.json() : [];

                            // Normalize standings
                            const normalizedStandings = normalizeStandingsData(standings, year);

                            // Create team logo map
                            const logoMap = {};
                            teams.forEach(team => {
                                logoMap[team.team_key] = team.team_logo;
                            });

                            // Create team info map
                            const teamInfoMap = {};
                            teams.forEach(team => {
                                teamInfoMap[team.team_key] = {
                                    name: team.team_name,
                                    manager: team.manager,
                                    logo: team.team_logo
                                };
                            });

                            seasonData[year] = {
                                standings: normalizedStandings,
                                logos: logoMap,
                                teamInfo: teamInfoMap,
                                playerStats: playerStats,
                                draftData: draftData
                            };
                        }
                    } catch (e) {
                        console.error(`Error loading ${year}:`, e);
                    }
                }

                console.log("Loaded season data for:", Object.keys(seasonData));

                // Calculate awards
                const regularSeasonWinners = [];
                const scoringChampions = [];
                const garbageAwards = [];
                const clownAwards = [];
                const troutAwards = [];
                const degromAwards = [];
                const diamondAwards = [];
                const bustAwards = [];

                // Load keepers data for excluding from draft value calculations
                let allKeepers = {};
                try {
                    const keepersResponse = await fetch('data/keepers.json');
                    if (keepersResponse.ok) {
                        allKeepers = await keepersResponse.json();
                    }
                } catch (e) {
                    console.log('No keepers data available');
                }

                for (const [year, data] of Object.entries(seasonData)) {
                    const standings = data.standings;
                    const logos = data.logos;
                    const playerStats = data.playerStats || [];

                    // Regular Season Champion (most wins)
                    const mostWins = standings.reduce((max, team) =>
                        team.wins > max.wins ? team : max
                    );
                    regularSeasonWinners.push({
                        year,
                        manager: mostWins.manager,
                        team_name: mostWins.team_name,
                        logo: logos[mostWins.team_key],
                        value: mostWins.wins
                    });

                    // Scoring Champion (most points)
                    const mostPoints = standings.reduce((max, team) =>
                        team.points_for > max.points_for ? team : max
                    );
                    scoringChampions.push({
                        year,
                        manager: mostPoints.manager,
                        team_name: mostPoints.team_name,
                        logo: logos[mostPoints.team_key],
                        value: Math.round(mostPoints.points_for)
                    });

                    // Garbage Award (worst record - fewest wins)
                    const fewestWins = standings.reduce((min, team) =>
                        team.wins < min.wins ? team : min
                    );
                    garbageAwards.push({
                        year,
                        manager: fewestWins.manager,
                        team_name: fewestWins.team_name,
                        logo: logos[fewestWins.team_key],
                        wins: fewestWins.wins,
                        losses: fewestWins.losses
                    });

                    // Clown Award (least points)
                    const leastPoints = standings.reduce((min, team) =>
                        team.points_for < min.points_for ? team : min
                    );
                    clownAwards.push({
                        year,
                        manager: leastPoints.manager,
                        team_name: leastPoints.team_name,
                        logo: logos[leastPoints.team_key],
                        value: Math.round(leastPoints.points_for)
                    });

                    // Mike Trout Award (highest scoring hitter)
                    const batters = playerStats.filter(p => p.position_type === 'B');
                    if (batters.length > 0) {
                        const topHitter = batters.reduce((max, player) =>
                            (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                        );
                        troutAwards.push({
                            year,
                            manager: topHitter.manager,
                            team_logo: topHitter.team_logo,
                            player_name: topHitter.name,
                            player_headshot: topHitter.headshot_url,
                            value: Math.round(topHitter.fantasy_points || 0)
                        });
                    }

                    // Jacob deGrom Award (highest scoring pitcher)
                    const pitchers = playerStats.filter(p => p.position_type === 'P');
                    if (pitchers.length > 0) {
                        const topPitcher = pitchers.reduce((max, player) =>
                            (player.fantasy_points || 0) > (max.fantasy_points || 0) ? player : max
                        );
                        degromAwards.push({
                            year,
                            manager: topPitcher.manager,
                            team_logo: topPitcher.team_logo,
                            player_name: topPitcher.name,
                            player_headshot: topPitcher.headshot_url,
                            value: Math.round(topPitcher.fantasy_points || 0)
                        });
                    }

                    // Diamond in the Rough & Bust of the Year Awards
                    // Calculate points over expected value based on draft position
                    const draftData = data.draftData || [];
                    const teamInfo = data.teamInfo || {};
                    const keepersForYear = allKeepers[year.toString()] || {};

                    // Create lowercase keeper lookup
                    const keepersLower = {};
                    for (const name of Object.keys(keepersForYear)) {
                        keepersLower[name.toLowerCase()] = true;
                    }

                    if (draftData.length > 0 && playerStats.length > 0) {
                        // Create player stats lookup by name (lowercase)
                        const playerStatsMap = {};
                        playerStats.forEach(p => {
                            if (p.name) {
                                playerStatsMap[p.name.toLowerCase()] = p;
                            }
                        });

                        // Sort players by fantasy points to get expected value by rank
                        const sortedByPoints = [...playerStats]
                            .filter(p => p.fantasy_points && p.fantasy_points > 0)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));

                        // Create expected points by overall rank (pick number)
                        // Expected value = average points of players picked around that position
                        const expectedPointsByPick = {};
                        sortedByPoints.forEach((p, idx) => {
                            expectedPointsByPick[idx + 1] = p.fantasy_points || 0;
                        });

                        // Calculate value over expected for each draft pick (excluding keepers)
                        const draftValues = [];
                        draftData.forEach(pick => {
                            const playerName = pick.player_name || '';
                            const pickNum = pick.pick || 0;

                            // Skip keepers
                            if (keepersLower[playerName.toLowerCase()]) {
                                return;
                            }

                            // Get actual points and headshot from player stats
                            const playerData = playerStatsMap[playerName.toLowerCase()];
                            const actualPoints = playerData ? (playerData.fantasy_points || 0) : 0;

                            // Get headshot - prefer player stats (more reliable), fallback to draft data
                            const headshot = (playerData && playerData.headshot_url) ? playerData.headshot_url : (pick.headshot_url || '');

                            // Get expected points based on pick position
                            const expectedPoints = expectedPointsByPick[pickNum] || 0;

                            // Calculate value over expected
                            const valueOverExpected = actualPoints - expectedPoints;

                            // Get team info
                            const team = teamInfo[pick.team_key] || {};

                            // Normalize manager name
                            const managerName = team.manager ? normalizeManagerName(team.manager, parseInt(year), team.name, pick.team_key) : '';

                            draftValues.push({
                                player_name: playerName,
                                player_headshot: headshot,
                                pick: pickNum,
                                round: pick.round || Math.ceil(pickNum / 12),
                                actualPoints: actualPoints,
                                expectedPoints: expectedPoints,
                                valueOverExpected: valueOverExpected,
                                manager: managerName, // Use the normalized name
                                team_logo: team.logo || ''
                            });
                        });

                        // Find best value (Diamond) - highest positive value over expected
                        if (draftValues.length > 0) {
                            const bestValue = draftValues.reduce((best, pick) =>
                                pick.valueOverExpected > best.valueOverExpected ? pick : best
                            );
                            if (bestValue.valueOverExpected > 0) {
                                diamondAwards.push({
                                    year,
                                    manager: bestValue.manager,
                                    team_logo: bestValue.team_logo,
                                    player_name: bestValue.player_name,
                                    player_headshot: bestValue.player_headshot,
                                    pick: bestValue.pick,
                                    round: bestValue.round,
                                    value: Math.round(bestValue.valueOverExpected)
                                });
                            }

                            // Find worst value (Bust) - lowest (most negative) value over expected
                            // Only consider players drafted in first 5 rounds
                            const earlyPicks = draftValues.filter(p => p.round <= 5);
                            if (earlyPicks.length > 0) {
                                const worstValue = earlyPicks.reduce((worst, pick) =>
                                    pick.valueOverExpected < worst.valueOverExpected ? pick : worst
                                );
                                if (worstValue.valueOverExpected < 0) {
                                    bustAwards.push({
                                        year,
                                        manager: worstValue.manager,
                                        team_logo: worstValue.team_logo,
                                        player_name: worstValue.player_name,
                                        player_headshot: worstValue.player_headshot,
                                        pick: worstValue.pick,
                                        round: worstValue.round,
                                        value: Math.round(worstValue.valueOverExpected)
                                    });
                                }
                            }
                        }
                    }
                }

                console.log("Calculated awards:", {
                    regularSeasonWinners: regularSeasonWinners.length,
                    scoringChampions: scoringChampions.length,
                    garbageAwards: garbageAwards.length,
                    clownAwards: clownAwards.length,
                    troutAwards: troutAwards.length,
                    degromAwards: degromAwards.length,
                    diamondAwards: diamondAwards.length,
                    bustAwards: bustAwards.length
                });

                // Sort all by year (most recent first)
                [regularSeasonWinners, scoringChampions, garbageAwards, clownAwards, troutAwards, degromAwards, diamondAwards, bustAwards].forEach(arr => {
                    arr.sort((a, b) => b.year - a.year);
                });

                // Populate tables
                populateAwardTable('regular-season-winners', regularSeasonWinners, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value}</span></td>
                `);

                populateAwardTable('scoring-champions', scoringChampions, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('garbage-awards', garbageAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.wins}-${award.losses}</span></td>
                `);

                populateAwardTable('clown-awards', clownAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.logo ? `<img src="${award.logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td>${award.team_name}</td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                // Base64 encoded placeholder for player headshots
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                populateAwardTable('trout-awards', troutAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('degrom-awards', degromAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td><span class="award-value">${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('diamond-awards', diamondAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td>Rd ${award.round}, #${award.pick}</td>
                    <td><span class="award-value" style="color: #28a745;">+${award.value.toLocaleString()}</span></td>
                `);

                populateAwardTable('bust-awards', bustAwards, (award) => `
                    <td>${award.year}</td>
                    <td><div class="manager-cell">${award.team_logo ? `<img src="${award.team_logo}" class="team-logo">` : ''}${award.manager}</div></td>
                    <td><div class="player-award-cell"><img src="${award.player_headshot || placeholderImg}" class="player-award-headshot" onerror="this.src='${placeholderImg}'">${award.player_name}</div></td>
                    <td>Rd ${award.round}, #${award.pick}</td>
                    <td><span class="award-value" style="color: #dc3545;">${award.value.toLocaleString()}</span></td>
                `);

                console.log("Awards populated successfully");
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';

            } catch (error) {
                console.error('Error loading awards:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = `Error loading awards: ${error.message}`;
                errorEl.style.display = 'block';
            }
        }

        function populateAwardTable(tableId, awards, rowTemplate) {
            const tbody = document.getElementById(tableId);
            tbody.innerHTML = '';

            awards.forEach(award => {
                const row = document.createElement('tr');
                row.innerHTML = rowTemplate(award);
                tbody.appendChild(row);
            });
        }

        // ===== PRESEASON PROJECTIONS FUNCTIONS =====
        let allProjectionBatters = [];
        let allProjectionPitchers = [];
        let filteredProjections = [];
        let currentProjectionPlayerType = 'all';
        let showKeptPlayers = true;
        let projectionSort = { column: 'projected_points', direction: 'desc' };
        let projectionsData = null;

        // Helper function to create position badge(s) with color
        // Handles multiple positions like "1B, 3B" or "1B/3B"
        function getPositionBadge(position, playerName) {
            if (!position || position === '-') return '<span class="position-badge">-</span>';

            // Parse positions
            const positionsArray = position.split(/[,\/]/).map(p => p.trim()).filter(p => p);

            // Handle Ohtani batter case specifically - if Shohei Ohtani has only pitcher positions, show Util
            const pitcherPositions = ['SP', 'RP', 'P'];
            const allPitcher = positionsArray.length > 0 && positionsArray.every(p => pitcherPositions.includes(p));
            const isOhtani = playerName && playerName.toLowerCase().includes('ohtani');
            if (allPitcher && isOhtani && positionsArray.length > 1) {
                // This is Ohtani batter (has SP, P but is in batters list)
                return '<span class="position-badge pos-Util">Util</span>';
            }

            // Generate a badge for each position
            return positionsArray.map(pos => {
                return `<span class="position-badge pos-${pos}">${pos}</span>`;
            }).join(' ');
        }

        async function loadProjections() {
            const projectionType = document.getElementById('projection-type').value;
            const loadingEl = document.getElementById('proj-loading');
            const errorEl = document.getElementById('proj-error');
            const containerEl = document.getElementById('proj-stats-container');
            const noDataEl = document.getElementById('proj-no-data');

            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            containerEl.style.display = 'none';
            if (noDataEl) noDataEl.style.display = 'none';

            try {
                // Try to load projections data
                const response = await fetch(`data/projections/projections_${projectionType}.json`);

                if (!response.ok) {
                    throw new Error(`${projectionType} projections have not been released. Check back soon!`);
                }

                projectionsData = await response.json();

                allProjectionBatters = projectionsData.batters || [];
                allProjectionPitchers = projectionsData.pitchers || [];

                console.log(`Loaded ${allProjectionBatters.length} batters and ${allProjectionPitchers.length} pitchers`);

                // Pre-calculate games and PPG for sorting
                allProjectionBatters.forEach(p => {
                    const stats = p.stats || {};
                    // Use actual G from projections
                    p.games = stats.G || 0;
                    p.ppg = p.games > 0 ? (p.projected_points || 0) / p.games : 0;
                });

                allProjectionPitchers.forEach(p => {
                    const stats = p.stats || {};
                    p.games = stats.G || 0;
                    p.ppg = p.games > 0 ? (p.projected_points || 0) / p.games : 0;
                });

                // Calculate position ranks
                calculateProjectionPositionRanks();

                // Display scoring settings
                displayScoringSettings(projectionsData.scoring);

                loadingEl.style.display = 'none';
                containerEl.style.display = 'block';

                filterProjections();

            } catch (error) {
                console.error('Error loading projections:', error);
                loadingEl.style.display = 'none';
                errorEl.textContent = error.message;
                errorEl.style.display = 'block';
            }
        }

        function calculateProjectionPositionRanks() {
            // Combine all players for ranking
            const allPlayers = [...allProjectionBatters, ...allProjectionPitchers];

            // Define positions to rank (batting positions + pitching)
            const positions = ['C', '1B', '2B', '3B', 'SS', 'LF', 'CF', 'RF', 'OF', 'DH', 'SP', 'RP'];

            positions.forEach(pos => {
                // Get players eligible for this position
                let eligiblePlayers;
                if (pos === 'OF') {
                    // OF includes LF, CF, RF, OF
                    eligiblePlayers = allPlayers.filter(p => {
                        const playerPos = (p.position || '').toUpperCase();
                        return playerPos.includes('LF') || playerPos.includes('CF') ||
                            playerPos.includes('RF') || playerPos.includes('OF');
                    });
                } else {
                    eligiblePlayers = allPlayers.filter(p => {
                        const playerPos = (p.position || '').toUpperCase();
                        return playerPos.includes(pos);
                    });
                }

                // Sort by projected points descending
                eligiblePlayers.sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));

                // Assign ranks
                eligiblePlayers.forEach((player, index) => {
                    if (!player.position_ranks) {
                        player.position_ranks = {};
                    }
                    player.position_ranks[pos] = index + 1;
                });
            });

            // Also calculate overall batter and pitcher ranks
            const batters = allPlayers.filter(p => p.type === 'batter')
                .sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));
            batters.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['B'] = index + 1;
            });

            const pitchers = allPlayers.filter(p => p.type === 'pitcher')
                .sort((a, b) => (b.projected_points || 0) - (a.projected_points || 0));
            pitchers.forEach((player, index) => {
                if (!player.position_ranks) player.position_ranks = {};
                player.position_ranks['P'] = index + 1;
            });
        }

        function formatProjectionPosition(position, playerName) {
            // Format position string, excluding "Util"
            if (!position) return '-';

            // Split by comma or slash and filter out Util
            const positions = position.split(/[,\/]/)
                .map(p => p.trim())
                .filter(p => p && !['UTIL', 'NA'].includes(p.toUpperCase()));

            // Handle Ohtani batter case specifically - if Shohei Ohtani has only pitcher positions, show as Util
            const pitcherPositions = ['SP', 'RP', 'P'];
            const allPitcher = positions.length > 0 && positions.every(p => pitcherPositions.includes(p));
            const isOhtani = playerName && playerName.toLowerCase().includes('ohtani');
            if (allPitcher && isOhtani && positions.length > 1) {
                // This is Ohtani batter (has SP, P but is in batters list)
                return 'Util';
            }

            return positions.length > 0 ? positions.join(', ') : '-';
        }

        function getProjectionPositionRank(player) {
            if (!player.position_ranks || !player.position) return '-';

            // Get the first non-Util position
            const positions = (player.position || '').split(/[,\/]/)
                .map(p => p.trim())
                .filter(p => p && !['UTIL', 'NA'].includes(p.toUpperCase()));

            if (positions.length === 0) return '-';

            // Get the primary position (first one)
            let primaryPos = positions[0].toUpperCase();

            // Normalize OF positions
            if (['LF', 'CF', 'RF'].includes(primaryPos)) {
                // Use OF rank if available, otherwise use specific position
                if (player.position_ranks['OF']) {
                    return `OF${player.position_ranks['OF']}`;
                }
            }

            const rank = player.position_ranks[primaryPos];
            if (rank) {
                return `${primaryPos}${rank}`;
            }

            return positions[0];
        }

        function displayScoringSettings(scoring) {
            const container = document.getElementById('proj-scoring-display');
            // Element was removed, so just return
            if (!container) return;

            if (!scoring) {
                container.innerHTML = '<p>Scoring settings not available.</p>';
                return;
            }

            const battingHtml = scoring.batting ? `
                <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <h4 style="color: #2a5298; font-size: 0.9rem; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0;">🏏 Batting</h4>
                    ${Object.entries(scoring.batting).map(([stat, val]) => `
                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0; font-size: 0.85rem;">
                            <span style="color: #555;">${stat}</span>
                            <span style="font-weight: 600; color: ${val >= 0 ? '#28a745' : '#dc3545'};">${val >= 0 ? '+' : ''}${val}</span>
                        </div>
                    `).join('')}
                </div>
            ` : '';

            const pitchingHtml = scoring.pitching ? `
                <div style="background: #f8f9fa; border-radius: 8px; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <h4 style="color: #2a5298; font-size: 0.9rem; margin-bottom: 0.75rem; padding-bottom: 0.5rem; border-bottom: 2px solid #e0e0e0;">⚾ Pitching</h4>
                    ${Object.entries(scoring.pitching).map(([stat, val]) => `
                        <div style="display: flex; justify-content: space-between; padding: 0.25rem 0; font-size: 0.85rem;">
                            <span style="color: #555;">${stat}</span>
                            <span style="font-weight: 600; color: ${val >= 0 ? '#28a745' : '#dc3545'};">${val >= 0 ? '+' : ''}${val}</span>
                        </div>
                    `).join('')}
                </div>
            ` : '';

            container.innerHTML = battingHtml + pitchingHtml;
        }

        function setProjectionPlayerType(type) {
            currentProjectionPlayerType = type;

            document.querySelectorAll('#preseason .stat-type-toggle .toggle-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`proj-btn-${type}`).classList.add('active');

            filterProjections();
        }

        function filterProjections() {
            const positionFilter = document.getElementById('proj-position-filter').value;
            const searchTerm = document.getElementById('proj-player-search').value.toLowerCase();

            let data = [];

            if (currentProjectionPlayerType === 'all') {
                data = [...allProjectionBatters, ...allProjectionPitchers];
            } else if (currentProjectionPlayerType === 'batters') {
                data = [...allProjectionBatters];
            } else {
                data = [...allProjectionPitchers];
            }

            // Apply position filter
            if (positionFilter !== 'all') {
                if (positionFilter === 'B') {
                    data = data.filter(p => p.type === 'batter');
                } else if (positionFilter === 'P') {
                    data = data.filter(p => p.type === 'pitcher');
                } else {
                    data = data.filter(p => {
                        const pos = (p.position || '').toUpperCase();
                        if (positionFilter === 'OF') {
                            return pos.includes('LF') || pos.includes('CF') || pos.includes('RF') || pos.includes('OF');
                        }
                        return pos.includes(positionFilter);
                    });
                }
            }

            // Apply search filter
            if (searchTerm) {
                data = data.filter(p =>
                    (p.name || '').toLowerCase().includes(searchTerm) ||
                    (p.team || '').toLowerCase().includes(searchTerm)
                );
            }

            // Apply kept player filter
            if (!showKeptPlayers) {
                data = data.filter(p => getPlayerKeeperInfo(p.name) === null);
            }

            // Sort data
            data.sort((a, b) => {
                const col = projectionSort.column;

                // === HELPER: Check both main object AND stats object ===
                const getVal = (obj) => {
                    // 1. Check main object (Rank, Name, Projected Points, Games)
                    if (obj[col] !== undefined) return obj[col];

                    // 2. Check stats object (HR, RBI, ERA, WHIP, etc.)
                    if (obj.stats && obj.stats[col] !== undefined) return obj.stats[col];

                    // 3. Handle 'K' vs 'SO' mapping if needed
                    if (col === 'K' && obj.stats && obj.stats.SO !== undefined) return obj.stats.SO;

                    return 0; // Default for missing data
                };

                let aVal = getVal(a);
                let bVal = getVal(b);

                if (typeof aVal === 'string') {
                    return projectionSort.direction === 'asc'
                        ? (aVal || '').localeCompare(bVal || '')
                        : (bVal || '').localeCompare(aVal || '');
                }

                return projectionSort.direction === 'asc' ? (aVal - bVal) : (bVal - aVal);
            });

            filteredProjections = data;
            renderProjectionTable();
        }

        function renderProjectionTable() {
            const thead = document.getElementById('proj-table-head');
            const tbody = document.getElementById('proj-table-body');
            const countEl = document.getElementById('proj-player-count');

            // Check if we have mixed data or just batters/pitchers
            const hasBatters = filteredProjections.some(p => p.type === 'batter');
            const hasPitchers = filteredProjections.some(p => p.type === 'pitcher');

            // Build headers based on data type
            let headers = `
                <tr>
                    <th class="sortable" onclick="sortProjectionTable('rank')">#</th>
                    <th class="sortable" onclick="sortProjectionTable('name')">Player</th>
                    <th class="sortable" onclick="sortProjectionTable('position')">Pos</th>
                    <th>Rank</th>
                    <th class="sortable stat-col" onclick="sortProjectionTable('projected_points')">Proj Pts</th>
                    <th class="sortable stat-col" onclick="sortProjectionTable('games')">G</th>
                    <th class="sortable stat-col" onclick="sortProjectionTable('ppg')">PPG</th>
            `;

            if (hasBatters && !hasPitchers) {
                headers += `
                    <th class="sortable" onclick="sortProjectionTable('HR')">HR</th>
                    <th class="sortable" onclick="sortProjectionTable('RBI')">RBI</th>
                    <th class="sortable" onclick="sortProjectionTable('R')">R</th>
                    <th class="sortable" onclick="sortProjectionTable('SB')">SB</th>
                    <th class="sortable" onclick="sortProjectionTable('AVG')">AVG</th>
                    <th class="sortable" onclick="sortProjectionTable('OPS')">OPS</th>
                `;
            } else if (hasPitchers && !hasBatters) {
                headers += `
                    <th class="sortable" onclick="sortProjectionTable('W')">W</th>
                    <th class="sortable" onclick="sortProjectionTable('SV')">SV</th>
                    <th class="sortable" onclick="sortProjectionTable('K')">K</th>
                    <th class="sortable" onclick="sortProjectionTable('ERA')">ERA</th>
                    <th class="sortable" onclick="sortProjectionTable('WHIP')">WHIP</th>
                    <th class="sortable" onclick="sortProjectionTable('IP')">IP</th>
                `;
            } else {
                // Mixed - show key stats for both
                headers += `
                    <th class="stat-col">Key Stats</th>
                `;
            }

            headers += '</tr>';
            thead.innerHTML = headers;

            // Update sort indicators
            updateProjectionSortIndicators();

            // Build rows
            tbody.innerHTML = '';

            // Base64 placeholder for headshots
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            filteredProjections.forEach((player, index) => {
                const row = document.createElement('tr');
                const stats = player.stats || {};

                let statsHtml = '';
                if (hasBatters && !hasPitchers) {
                    statsHtml = `
                        <td class="stat-col">${stats.HR || 0}</td>
                        <td class="stat-col">${stats.RBI || 0}</td>
                        <td class="stat-col">${stats.R || 0}</td>
                        <td class="stat-col">${stats.SB || 0}</td>
                        <td class="stat-col">${(stats.AVG || 0).toFixed(3)}</td>
                        <td class="stat-col">${(stats.OPS || 0).toFixed(3)}</td>
                    `;
                } else if (hasPitchers && !hasBatters) {
                    statsHtml = `
                        <td class="stat-col">${stats.W || 0}</td>
                        <td class="stat-col">${stats.SV || 0}</td>
                        <td class="stat-col">${stats.K || stats.SO || 0}</td>
                        <td class="stat-col">${(stats.ERA || 0).toFixed(2)}</td>
                        <td class="stat-col">${(stats.WHIP || 0).toFixed(2)}</td>
                        <td class="stat-col">${(stats.IP || 0).toFixed(0)}</td>
                    `;
                } else {
                    // Mixed view - show abbreviated stats
                    if (player.type === 'batter') {
                        statsHtml = `<td class="stat-col" style="font-size: 0.8rem;">${stats.HR || 0}HR, ${stats.SB || 0}SB, ${(stats.OPS || 0).toFixed(3)}OPS</td>`;
                    } else {
                        statsHtml = `<td class="stat-col" style="font-size: 0.8rem;">${(stats.IP || 0).toFixed(0)}IP, ${(stats.ERA || 0).toFixed(2)}ERA, ${stats.K || stats.SO || 0}K</td>`;
                    }
                }

                // Get headshot - use MLB ID to construct URL if headshot_url is missing
                let headshot = player.headshot_url;
                if (!headshot && player.mlb_id) {
                    headshot = `https://img.mlbstatic.com/mlb-photos/image/upload/d_people:generic:headshot:67:current.png/w_213,q_auto:best/v1/people/${player.mlb_id}/headshot/67/current`;
                }
                if (!headshot) {
                    headshot = placeholderImg;
                }

                // Get team display and logo
                const teamDisplay = formatMLBTeamDisplay(player.team || '');
                const mlbLogoUrl = getMLBTeamLogo(player.team || '');
                const mlbLogoHtml = mlbLogoUrl
                    ? `<img src="${mlbLogoUrl}" alt="" class="player-mlb-logo" onerror="this.style.display='none'">`
                    : '';

                // Format position (excluding Util) and get position rank
                const positionDisplay = formatProjectionPosition(player.position, player.name);
                const positionRank = getProjectionPositionRank(player);

                // Use pre-calculated games and PPG
                const projPoints = player.projected_points || 0;
                const games = player.games || 0;
                const ppg = games > 0 ? player.ppg.toFixed(2) : '-';

                // Check if player is kept by someone
                const keeperInfo = getPlayerKeeperInfo(player.name);
                const isKept = keeperInfo !== null;

                // Escape player name for onclick
                const escapedName = player.name.replace(/'/g, "\\'");

                // Add keeper styling
                if (isKept) {
                    row.classList.add('is-keeper');
                }

                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>
                        <div class="player-name-cell" onclick="showProjectionPlayerDetail('${escapedName}')">
                            <img src="${headshot}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                            <div>
                                <div class="player-name">
                                    ${player.name || 'Unknown'}
                                    ${isKept ? '<span class="keeper-badge">K</span>' : ''}
                                </div>
                                <div class="player-mlb-team">${mlbLogoHtml}${teamDisplay}</div>
                                ${isKept ? `<div class="keeper-by-tag">Kept by ${keeperInfo.manager}</div>` : ''}
                            </div>
                        </div>
                    </td>
                    <td>${getPositionBadge(positionDisplay, player.name)}</td>
                    <td class="player-position">${positionRank}</td>
                    <td class="stat-col player-points">${projPoints.toFixed(1)}</td>
                    <td class="stat-col">${games || '-'}</td>
                    <td class="stat-col">${ppg}</td>
                    ${statsHtml}
                `;

                tbody.appendChild(row);
            });

            countEl.textContent = `${filteredProjections.length} players`;
        }

        // Helper function to check if a player is kept
        function getPlayerKeeperInfo(playerName) {
            if (!keeperSelections || !keeperConfig) return null;

            const normalizedName = playerName.toLowerCase().trim();

            for (const [teamKey, keepers] of Object.entries(keeperSelections)) {
                if (!keepers || !Array.isArray(keepers)) continue;

                const found = keepers.find(k => k.player_name.toLowerCase().trim() === normalizedName);
                if (found) {
                    const teamInfo = keeperConfig.teams[teamKey];
                    return {
                        teamKey,
                        manager: teamInfo?.manager || 'Unknown',
                        teamName: teamInfo?.team_name || 'Unknown'
                    };
                }
            }

            return null;
        }

        function sortProjectionTable(column) {
            if (projectionSort.column === column) {
                projectionSort.direction = projectionSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                projectionSort.column = column;
                projectionSort.direction = column === 'name' ? 'asc' : 'desc';
            }
            filterProjections();
        }

        function updateProjectionSortIndicators() {
            // 1. Remove indicators from all headers
            document.querySelectorAll('#proj-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // 2. Find the header that matches the current sort column
            const sortCol = projectionSort.column;
            const headers = document.querySelectorAll('#proj-table th');

            headers.forEach(th => {
                const onclick = th.getAttribute('onclick');
                // Check if this header's onclick contains the current sort column name
                if (onclick && onclick.includes(`'${sortCol}'`)) {
                    th.classList.add(projectionSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });
        }

        function exportProjectionsCSV() {
            if (filteredProjections.length === 0) {
                alert('No data to export');
                return;
            }

            let csv = 'Rank,Player,Team,Position,Projected Points\n';

            filteredProjections.forEach((player, index) => {
                csv += `${index + 1},"${player.name}",${player.team},${player.position},${player.projected_points}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'projected_fantasy_points.csv';
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function toggleKeptPlayers() {
            showKeptPlayers = !showKeptPlayers;
            const btn = document.getElementById('btn-toggle-kept');

            if (showKeptPlayers) {
                btn.textContent = 'Hide Kept Players';
                // Reset to default style
                btn.style.background = '#e9ecef';
                btn.style.color = '#333';
                btn.style.borderColor = '#ced4da';
            } else {
                btn.textContent = 'Show Kept Players';
                // active style to show filter is on
                btn.style.background = '#6c757d';
                btn.style.color = 'white';
                btn.style.borderColor = '#6c757d';
            }

            // Re-run filter to update table
            filterProjections();
        }

        // ===== KEEPER MANAGEMENT =====

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBDGlo49Hue0-64_kBgDlXuNExtSowCksg",
            authDomain: "fantasy-baseball-civil-war.firebaseapp.com",
            databaseURL: "https://fantasy-baseball-civil-war-default-rtdb.firebaseio.com",
            projectId: "fantasy-baseball-civil-war",
            storageBucket: "fantasy-baseball-civil-war.firebasestorage.app",
            messagingSenderId: "629177123282",
            appId: "1:629177123282:web:f8aac5965be0dea886880b",
            measurementId: "G-FGGY9F6L6C"
        };

        // Initialize Firebase
        let firebaseApp = null;
        let firebaseDb = null;
        let firebaseInitialized = false;

        function updateFirebaseStatus(connected) {
            const statusEl = document.getElementById('firebase-status');
            if (statusEl) {
                if (connected) {
                    statusEl.className = 'firebase-status connected';
                    statusEl.querySelector('.status-text').textContent = 'Live Sync';
                    statusEl.title = 'Connected to real-time database - changes sync automatically';
                } else {
                    statusEl.className = 'firebase-status disconnected';
                    statusEl.querySelector('.status-text').textContent = 'Offline';
                    statusEl.title = 'Not connected - changes saved locally only';
                }
            }
        }

        function initializeFirebase() {
            try {
                if (typeof firebase === 'undefined') {
                    console.error('Firebase SDK not loaded');
                    updateFirebaseStatus(false);
                    return;
                }

                if (!firebaseInitialized) {
                    firebaseApp = firebase.initializeApp(firebaseConfig);
                    firebaseDb = firebase.database();
                    firebaseInitialized = true;
                    console.log('Firebase initialized successfully');

                    // Monitor connection state
                    firebaseDb.ref('.info/connected').on('value', (snapshot) => {
                        const connected = snapshot.val() === true;
                        updateFirebaseStatus(connected);
                        console.log('Firebase connection:', connected ? 'connected' : 'disconnected');
                    });

                    // Set up real-time listener for keeper selections
                    setupKeeperListener();
                }
            } catch (e) {
                console.error('Firebase initialization error:', e);
                updateFirebaseStatus(false);
            }
        }

        // Listen for real-time keeper updates from Firebase
        function setupKeeperListener() {
            if (!firebaseDb) return;

            const keepersRef = firebaseDb.ref('keepers_2026');
            keepersRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    // Merge Firebase data with local selections
                    // Firebase data takes precedence except for current user's team
                    const currentTeamData = currentKeeperTeam ? keeperSelections[currentKeeperTeam] : null;

                    keeperSelections = {};
                    Object.entries(data).forEach(([sanitizedKey, keepers]) => {
                        // Convert sanitized key back to original format (underscores to dots)
                        const teamKey = unsanitizeFirebaseKey(sanitizedKey);
                        // Convert Firebase format (may have numeric keys) to array
                        if (Array.isArray(keepers)) {
                            keeperSelections[teamKey] = keepers;
                        } else if (keepers && typeof keepers === 'object') {
                            keeperSelections[teamKey] = Object.values(keepers);
                        }
                    });

                    // Restore current user's unsaved changes if they're in the modal
                    if (currentTeamData && currentKeeperTeam) {
                        // Only restore if modal is open and user has unsaved changes
                        const modal = document.getElementById('keeper-modal');
                        if (modal && modal.style.display === 'flex') {
                            keeperSelections[currentKeeperTeam] = currentTeamData;
                        }
                    }

                    console.log('Keeper data updated from Firebase');
                    displayLeagueKeepers();
                }
            }, (error) => {
                console.error('Firebase listener error:', error);
            });
        }

        // Save keeper selections to Firebase
        // Firebase paths can't contain ".", "#", "$", "[", or "]" so we sanitize team keys
        function sanitizeFirebaseKey(key) {
            return key.replace(/\./g, '_');
        }

        function unsanitizeFirebaseKey(key) {
            return key.replace(/_/g, '.');
        }

        async function saveKeepersToFirebase(teamKey, keepers) {
            console.log('saveKeepersToFirebase called, firebaseDb:', !!firebaseDb, 'firebaseInitialized:', firebaseInitialized);

            if (!firebaseDb) {
                console.log('Firebase not initialized, saving to localStorage only');
                return false;
            }

            try {
                const sanitizedKey = sanitizeFirebaseKey(teamKey);
                console.log('Attempting to save to Firebase:', sanitizedKey, keepers);
                await firebaseDb.ref(`keepers_2026/${sanitizedKey}`).set(keepers);
                console.log(`Successfully saved keepers for ${teamKey} to Firebase`);
                return true;
            } catch (e) {
                console.error('Error saving to Firebase:', e);
                return false;
            }
        }

        let keeperConfig = null;
        let keeperSelections = {};
        let currentKeeperTeam = null;
        let keeperRosterData = [];
        let keeperProjectionsMap = {};
        let keeperDraftData = {}; // Store draft data for cost calculations
        let showTradedPicks = false; // Toggle state for showing traded picks (default hidden)
        let showLeagueProspects = false; // Toggle state for showing prospects in league keepers (default hidden)
        const KEEPER_BUDGET = 50; // $50 per team

        // Password hashing function (simple SHA-256)
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Calculate dollar cost based on draft round
        function getKeeperDollarCost(draftRound) {
            if (!draftRound || draftRound < 1) return 1; // Undrafted players cost $1
            // Round 1 = $20, Round 2 = $19, ... Round 20+ = $1
            return Math.max(1, 21 - draftRound);
        }

        // Calculate next year's draft round cost for keeping a player
        function getKeeperRoundCost(previousRound, totalRounds = 20) {
            if (!previousRound || previousRound < 1) return totalRounds; // Undrafted costs last round
            // Rounds 1-3: costs a 1st rounder
            if (previousRound <= 3) return 1;
            // Rounds 4-10: costs 3 rounds earlier
            if (previousRound <= 10) return previousRound - 3;
            // Rounds 11+: costs 4 rounds earlier
            return Math.max(1, previousRound - 4);
        }

        // Get the total number of rounds in the draft
        function getTotalDraftRounds() {
            if (!keeperDraftData || !keeperDraftData.length) return 20; // Default
            return Math.max(...keeperDraftData.map(p => p.round || 0));
        }

        // Get player's draft info from 2025
        function getPlayerDraftInfo(playerName) {
            const totalRounds = getTotalDraftRounds();

            if (!keeperDraftData || !keeperDraftData.length) {
                // No draft data available, return undrafted defaults
                return {
                    round: null,
                    pick: null,
                    team_key: null,
                    dollarCost: 1,
                    roundCost: totalRounds,
                    isUndrafted: true
                };
            }

            const normalizedName = playerName.toLowerCase().trim();
            const pick = keeperDraftData.find(p =>
                p.player_name && p.player_name.toLowerCase().trim() === normalizedName
            );

            if (pick) {
                return {
                    round: pick.round,
                    pick: pick.pick,
                    team_key: pick.team_key,
                    dollarCost: getKeeperDollarCost(pick.round),
                    roundCost: getKeeperRoundCost(pick.round, totalRounds),
                    isUndrafted: false
                };
            }

            // Player was not drafted (free agent pickup)
            return {
                round: null,
                pick: null,
                team_key: null,
                dollarCost: 1, // Undrafted costs $1
                roundCost: totalRounds, // Undrafted costs last round
                isUndrafted: true
            };
        }

        // Calculate the actual round costs for a team's keepers, handling multiple last-round picks
        // This now considers traded picks - if you traded for extra round 22 picks, you can use them
        function calculateTeamKeeperRoundCosts(teamKey) {
            const allKeepers = keeperSelections[teamKey] || [];
            if (allKeepers.length === 0) return [];

            // Filter out prospects - they don't use draft picks
            const keepers = allKeepers.filter(k => !k.isProspect);
            if (keepers.length === 0) return [];

            const totalRounds = getTotalDraftRounds();

            // Get the team's available picks (including traded picks)
            const ownedPicks = getTeamPicks(teamKey);

            console.log('=== calculateTeamKeeperRoundCosts DEBUG ===');
            console.log('Team:', teamKey);
            console.log('Keepers:', keepers.map(k => `${k.player_name} (baseRoundCost: ${k.roundCost})`));
            console.log('Owned picks:', ownedPicks.map(p => `Rd ${p.round}`).join(', '));

            // Build a count of how many picks the team has at each round
            const pickCounts = {};
            ownedPicks.forEach(pick => {
                pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
            });

            console.log('Pick counts by round:', pickCounts);

            // Get base round costs for each keeper (excluding prospects)
            let roundCosts = keepers.map(k => ({
                player_name: k.player_name,
                baseRoundCost: k.roundCost || totalRounds,
                isUndrafted: k.isUndrafted || false
            }));

            // Sort by round cost (highest/latest rounds first for undrafted)
            roundCosts.sort((a, b) => b.baseRoundCost - a.baseRoundCost);

            console.log('Sorted keepers (highest round first):', roundCosts.map(k => `${k.player_name} (${k.baseRoundCost})`));

            // Track used picks at each round
            const usedPicksAtRound = {};

            // Get sorted list of rounds we actually have picks in
            const ownedRounds = [...new Set(ownedPicks.map(p => p.round))].sort((a, b) => b - a);

            // Assign actual rounds, using available picks
            roundCosts.forEach(keeper => {
                let assignedRound = keeper.baseRoundCost;

                // Initialize used count for this round
                if (!usedPicksAtRound[assignedRound]) {
                    usedPicksAtRound[assignedRound] = 0;
                }

                // Check if we have an available pick at this round
                const availableAtRound = (pickCounts[assignedRound] || 0) - (usedPicksAtRound[assignedRound] || 0);

                if (availableAtRound > 0) {
                    // We have an available pick at this round
                    usedPicksAtRound[assignedRound]++;
                } else {
                    // Need to find the next available round going backwards (earlier in draft)
                    // Only consider rounds where we actually have picks
                    let foundRound = false;

                    // Filter to rounds earlier than the base cost and sort descending (latest first)
                    const eligibleRounds = ownedRounds.filter(r => r < assignedRound);

                    for (const round of eligibleRounds) {
                        if (!usedPicksAtRound[round]) {
                            usedPicksAtRound[round] = 0;
                        }
                        const available = (pickCounts[round] || 0) - usedPicksAtRound[round];
                        if (available > 0) {
                            assignedRound = round;
                            usedPicksAtRound[round]++;
                            foundRound = true;
                            break;
                        }
                    }

                    // If no earlier round found, try any available round we own
                    if (!foundRound) {
                        for (const round of ownedRounds) {
                            if (!usedPicksAtRound[round]) {
                                usedPicksAtRound[round] = 0;
                            }
                            const available = (pickCounts[round] || 0) - usedPicksAtRound[round];
                            if (available > 0) {
                                assignedRound = round;
                                usedPicksAtRound[round]++;
                                foundRound = true;
                                break;
                            }
                        }
                    }

                    // If still no round found (shouldn't happen normally), mark as needing a pick
                    if (!foundRound) {
                        assignedRound = null; // No pick available
                    }
                }

                keeper.actualRoundCost = assignedRound;
                console.log(`  ${keeper.player_name}: base=${keeper.baseRoundCost} -> actual=${assignedRound}`);
            });

            console.log('Final assignments:', roundCosts.map(k => `${k.player_name}: Rd ${k.actualRoundCost}`));
            console.log('=== END DEBUG ===');

            return roundCosts;
        }

        // Calculate total budget used by a team's keepers
        function calculateTeamBudgetUsed(teamKey) {
            const keepers = keeperSelections[teamKey] || [];
            // Only count non-prospect keepers, and use 0 for prospects
            return keepers.reduce((total, k) => {
                if (k.isProspect) return total; // Prospects are free
                return total + (k.dollarCost !== undefined ? k.dollarCost : 1);
            }, 0);
        }

        async function initializeKeeperManagement() {
            try {
                // Initialize Firebase first
                initializeFirebase();

                // Load keeper config
                const configResponse = await fetch('data/keepers/keeper_config.json');
                if (configResponse.ok) {
                    keeperConfig = await configResponse.json();
                } else {
                    // Generate default config from current teams
                    await generateDefaultKeeperConfig();
                }

                // Load 2025 draft data for cost calculations
                try {
                    const draftResponse = await fetch('data/current_season/draft.json');
                    if (draftResponse.ok) {
                        keeperDraftData = await draftResponse.json();
                        console.log(`Loaded ${keeperDraftData.length} draft picks for keeper costs`);
                    }
                } catch (e) {
                    console.log('Could not load draft data for keeper costs');
                }

                // Load existing keeper selections from Firebase (primary) or fallback to JSON file
                if (firebaseDb) {
                    try {
                        const snapshot = await firebaseDb.ref('keepers_2026').once('value');
                        const data = snapshot.val();
                        if (data) {
                            Object.entries(data).forEach(([sanitizedKey, keepers]) => {
                                // Convert sanitized key back to original format
                                const teamKey = unsanitizeFirebaseKey(sanitizedKey);
                                if (Array.isArray(keepers)) {
                                    keeperSelections[teamKey] = keepers;
                                } else if (keepers && typeof keepers === 'object') {
                                    keeperSelections[teamKey] = Object.values(keepers);
                                }
                            });
                            console.log('Loaded keeper selections from Firebase');
                        }
                    } catch (e) {
                        console.log('Could not load from Firebase, trying JSON file:', e);
                    }
                }

                // Fallback: Load from JSON file if Firebase is empty or unavailable
                if (Object.keys(keeperSelections).length === 0) {
                    try {
                        const selectionsResponse = await fetch('data/keepers/keepers_2026.json');
                        if (selectionsResponse.ok) {
                            const data = await selectionsResponse.json();
                            keeperSelections = data.keepers || {};
                            console.log('Loaded keeper selections from JSON file');
                        }
                    } catch (e) {
                        console.log('No JSON keeper file found');
                    }
                }

                // Populate team selector
                populateKeeperTeamSelect();

                // Load and display league keepers
                displayLeagueKeepers();

                // Build projections lookup map
                const allProj = [...allProjectionBatters, ...allProjectionPitchers];
                allProj.forEach(p => {
                    const normalizedName = p.name.toLowerCase().trim();
                    keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                });

            } catch (e) {
                console.log('Error initializing keeper management:', e);
            }
        }

        async function generateDefaultKeeperConfig() {
            // Load teams from 2025
            const teams = await getTeamData(2025);
            if (!teams) return;

            // Load manager history to get join years
            let managerJoinYears = {};
            try {
                const historyResponse = await fetch('data/managers/manager_history.json');
                if (historyResponse.ok) {
                    const history = await historyResponse.json();
                    history.forEach(manager => {
                        if (manager.seasons && manager.seasons.length > 0) {
                            const firstYear = Math.min(...manager.seasons.map(s => s.year));
                            managerJoinYears[manager.manager_name] = firstYear;
                        }
                    });
                }
            } catch (e) {
                console.log('Could not load manager history');
            }

            keeperConfig = {
                season: 2026,
                max_keepers: 5,
                deadline: "2026-03-15T23:59:59",
                teams: {}
            };

            for (const team of teams) {
                const joinYear = managerJoinYears[team.manager] || 2020;
                const password = `${team.manager}${joinYear}`;
                const passwordHash = await hashPassword(password);

                keeperConfig.teams[team.team_key] = {
                    team_name: team.team_name,
                    manager: team.manager,
                    password_hash: passwordHash,
                    team_logo: team.team_logo,
                    keepers_locked: false
                };
            }
        }

        function populateKeeperTeamSelect() {
            const select = document.getElementById('keeper-team-select');
            if (!keeperConfig || !keeperConfig.teams) return;

            select.innerHTML = '<option value="">-- Select Team --</option>';

            // Sort teams by manager name
            const sortedTeams = Object.entries(keeperConfig.teams)
                .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

            for (const [teamKey, teamInfo] of sortedTeams) {
                const option = document.createElement('option');
                option.value = teamKey;
                option.textContent = `${capitalizeManagerName(teamInfo.manager)} - ${teamInfo.team_name}`;
                select.appendChild(option);
            }
        }

        function onKeeperTeamSelect() {
            const select = document.getElementById('keeper-team-select');
            const passwordField = document.getElementById('keeper-password-field');
            const errorEl = document.getElementById('keeper-auth-error');

            errorEl.style.display = 'none';

            if (select.value) {
                passwordField.style.display = 'flex';
                document.getElementById('keeper-password').value = '';
                document.getElementById('keeper-password').focus();
            } else {
                passwordField.style.display = 'none';
            }
        }

        async function authenticateKeeper() {
            const teamKey = document.getElementById('keeper-team-select').value;
            const password = document.getElementById('keeper-password').value;
            const errorEl = document.getElementById('keeper-auth-error');

            if (!teamKey || !password) {
                errorEl.textContent = 'Please select a team and enter your password.';
                errorEl.style.display = 'block';
                return;
            }

            const teamInfo = keeperConfig.teams[teamKey];
            if (!teamInfo) {
                errorEl.textContent = 'Invalid team selection.';
                errorEl.style.display = 'block';
                return;
            }

            // Hash the entered password and compare
            const enteredHash = await hashPassword(password);

            if (enteredHash !== teamInfo.password_hash) {
                errorEl.textContent = 'Incorrect password. Hint: [YourName][YearJoined]';
                errorEl.style.display = 'block';
                return;
            }

            // Authentication successful
            currentKeeperTeam = teamKey;
            errorEl.style.display = 'none';

            // Hide auth section, show selection section
            document.getElementById('keeper-modal-auth').style.display = 'none';
            document.getElementById('keeper-modal-selection').style.display = 'flex';

            // Update header with team name and logo
            document.getElementById('keeper-current-team').textContent = `${teamInfo.team_name}`;

            // Set team logo
            const logoEl = document.getElementById('keeper-team-logo');
            if (teamInfo.team_logo) {
                logoEl.src = teamInfo.team_logo;
                logoEl.style.display = 'block';
            } else {
                logoEl.style.display = 'none';
            }

            // Load roster and display
            await loadKeeperRoster(teamKey);
            updateKeeperStatus();
            updateKeeperSelectedSummary();
        }

        function logoutKeeper() {
            currentKeeperTeam = null;
            document.getElementById('keeper-modal-auth').style.display = 'block';
            document.getElementById('keeper-modal-selection').style.display = 'none';
            document.getElementById('keeper-team-select').value = '';
            document.getElementById('keeper-password-field').style.display = 'none';
            document.getElementById('keeper-password').value = '';
            document.getElementById('keeper-auth-error').style.display = 'none';
        }

        function openKeeperModal() {
            // Initialize if needed
            if (!keeperConfig) {
                initializeKeeperManagement();
            }

            // Reset to auth view
            document.getElementById('keeper-modal-auth').style.display = 'block';
            document.getElementById('keeper-modal-selection').style.display = 'none';
            document.getElementById('keeper-team-select').value = '';
            document.getElementById('keeper-password-field').style.display = 'none';
            document.getElementById('keeper-password').value = '';
            document.getElementById('keeper-auth-error').style.display = 'none';

            // Show modal and prevent background scroll
            document.getElementById('keeper-modal').classList.add('active');
            document.body.classList.add('keeper-modal-open');
        }

        function closeKeeperModal() {
            document.getElementById('keeper-modal').classList.remove('active');
            document.body.classList.remove('keeper-modal-open');
            logoutKeeper();
        }

        // Close keeper modal on outside click
        document.getElementById('keeper-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeKeeperModal();
            }
        });

        async function loadKeeperRoster(teamKey) {
            const loadingEl = document.getElementById('keeper-roster-loading');
            const tbody = document.getElementById('keeper-roster-body');

            loadingEl.style.display = 'block';
            tbody.innerHTML = '';

            // Debug: log current keeper selections for this team
            console.log('Loading roster for team:', teamKey);
            console.log('Current keeperSelections for this team:', keeperSelections[teamKey]);

            try {
                // Load 2025 player stats to get roster
                const response = await fetch('data/current_season/player_stats.json');
                if (!response.ok) throw new Error('Could not load player data');

                const allPlayers = await response.json();

                // Filter to just this team's players
                keeperRosterData = allPlayers.filter(p => p.team_key === teamKey);

                // Load projections if not already loaded - use same format as main projections
                if (Object.keys(keeperProjectionsMap).length === 0) {
                    try {
                        // First check if allProjectionBatters/Pitchers are already loaded
                        if (allProjectionBatters.length > 0 || allProjectionPitchers.length > 0) {
                            [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                                const normalizedName = p.name.toLowerCase().trim();
                                keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                            });
                            console.log(`Loaded ${Object.keys(keeperProjectionsMap).length} projections from global data`);
                        } else {
                            // Load from projections file directly
                            const projResponse = await fetch('data/projections/projections_steamer.json');
                            if (projResponse.ok) {
                                const projData = await projResponse.json();
                                const batters = projData.batters || [];
                                const pitchers = projData.pitchers || [];
                                [...batters, ...pitchers].forEach(p => {
                                    const normalizedName = p.name.toLowerCase().trim();
                                    keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                                });
                                console.log(`Loaded ${Object.keys(keeperProjectionsMap).length} projections from file`);
                            }
                        }
                    } catch (e) {
                        console.log('Could not load projections:', e);
                    }
                }

                // Load player history data if not already loaded (for prospect determination)
                if (Object.keys(playerHistoryData).length === 0) {
                    try {
                        const historyResponse = await fetch('data/players/player_history.json');
                        if (historyResponse.ok) {
                            playerHistoryData = await historyResponse.json();
                            console.log(`Loaded player history for ${Object.keys(playerHistoryData).length} players`);
                        }
                    } catch (e) {
                        console.log('Could not load player history:', e);
                    }
                }

                // Sort by fantasy points descending
                keeperRosterData.sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));

                // Get current keeper selections for this team
                const teamKeepers = keeperSelections[teamKey] || [];
                const keeperNames = teamKeepers.map(k => k.player_name.toLowerCase());

                // Render roster
                keeperRosterData.forEach((player, index) => {
                    const isKept = keeperNames.includes(player.name.toLowerCase());
                    const projPts = keeperProjectionsMap[player.name.toLowerCase().trim()];
                    const projDisplay = typeof projPts === 'number' ? projPts.toFixed(1) : '-';

                    // Get draft info and costs
                    const draftInfo = getPlayerDraftInfo(player.name);
                    const dollarCost = draftInfo ? draftInfo.dollarCost : 1;
                    const roundCost = draftInfo ? draftInfo.roundCost : getTotalDraftRounds();
                    const draftRound = draftInfo && draftInfo.round ? draftInfo.round : 99;
                    const draftRoundDisplay = draftInfo && draftInfo.round ? `Rd ${draftInfo.round}` : 'FA';
                    const isUndrafted = draftInfo ? draftInfo.isUndrafted : true;

                    // Check if player qualifies as a prospect (free keeper)
                    // Must be undrafted AND have limited playing time AND no previous season history
                    const stats = player.stats || {};
                    const isPitcher = ['SP', 'RP', 'P'].includes(player.primary_position);
                    const hasLimitedTime = isPitcher
                        ? (stats.IP || 0) < 50
                        : (stats.AB || 0) < 130;

                    // Check if player has any previous season history in the league WITH points scored
                    const normalizedName = player.name.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                    const playerHistory = playerHistoryData[normalizedName];
                    const hasPreviousSeasons = playerHistory && playerHistory.seasons &&
                        playerHistory.seasons.some(s => s.year < 2025 && (s.fantasy_points || 0) > 0);

                    // Only a prospect if undrafted, limited time, AND no previous seasons with points
                    const isProspect = isUndrafted && hasLimitedTime && !hasPreviousSeasons;

                    const row = document.createElement('tr');
                    row.className = isKept ? 'is-keeper' : '';
                    if (isProspect) row.classList.add('is-prospect');
                    row.dataset.playerName = player.name;
                    row.dataset.dollarCost = isProspect ? 0 : dollarCost;
                    row.dataset.roundCost = isProspect ? 0 : roundCost;
                    row.dataset.pts2025 = player.fantasy_points || 0;
                    row.dataset.pts2026 = projPts || 0;
                    row.dataset.position = player.primary_position || '';
                    row.dataset.drafted = draftRound;
                    row.dataset.isProspect = isProspect ? '1' : '0';

                    const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';
                    const headshot = player.headshot_url || placeholderImg;

                    // Display cost info - prospects are free
                    const rdCostDisplay = isProspect ? '<span class="keeper-round-cost prospect-free">Free</span>' : `<span class="keeper-round-cost">Rd ${roundCost}</span>`;
                    const dollarCostDisplay = isProspect ? '<span class="keeper-dollar-cost prospect-free">$0</span>' : `<span class="keeper-dollar-cost">$${dollarCost}</span>`;

                    row.innerHTML = `
                        <td style="text-align: center;">
                            <input type="checkbox" class="keeper-checkbox" 
                                   ${isKept ? 'checked' : ''} 
                                   onchange="toggleKeeper('${player.name.replace(/'/g, "\\'")}', this.checked)">
                        </td>
                        <td>
                            <div class="player-name-cell">
                                <img src="${headshot}" class="player-headshot" onerror="this.src='${placeholderImg}'">
                                <span class="player-name">${player.name}</span>
                                ${isKept ? '<span class="keeper-badge">K</span>' : ''}
                                ${isProspect ? '<span class="prospect-badge">P</span>' : ''}
                            </div>
                        </td>
                        <td>${getPositionBadge(player.primary_position || '-', player.name)}</td>
                        <td class="stat-col">${(player.fantasy_points || 0).toFixed(1)}</td>
                        <td class="stat-col"><em>${projDisplay}</em></td>
                        <td class="keeper-cost-col">
                            <span class="keeper-draft-round">${draftRoundDisplay}</span>
                        </td>
                        <td class="keeper-cost-col">
                            ${rdCostDisplay}
                        </td>
                        <td class="keeper-cost-col">
                            ${dollarCostDisplay}
                        </td>
                    `;

                    tbody.appendChild(row);
                });

                loadingEl.style.display = 'none';

                // Update the draft picks display
                updateKeeperPicksDisplay();

                // Setup sortable columns
                setupKeeperTableSort();

            } catch (e) {
                console.error('Error loading roster:', e);
                loadingEl.style.display = 'none';
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #888;">Could not load roster</td></tr>';
            }
        }

        let keeperSortColumn = 'pts2025';
        let keeperSortDirection = 'desc';

        function setupKeeperTableSort() {
            const headers = document.querySelectorAll('#keeper-roster-table th.sortable');
            headers.forEach(th => {
                th.style.cursor = 'pointer';
                th.onclick = () => sortKeeperTable(th.dataset.sort);
            });
        }

        function sortKeeperTable(column) {
            const tbody = document.getElementById('keeper-roster-body');
            const rows = Array.from(tbody.querySelectorAll('tr'));

            // Toggle direction if same column
            if (keeperSortColumn === column) {
                keeperSortDirection = keeperSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                keeperSortColumn = column;
                keeperSortDirection = 'desc';
            }

            // Update header indicators
            document.querySelectorAll('#keeper-roster-table th.sortable').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sort === column) {
                    th.classList.add(keeperSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });

            rows.sort((a, b) => {
                let aVal, bVal;

                if (column === 'name') {
                    aVal = a.dataset.playerName.toLowerCase();
                    bVal = b.dataset.playerName.toLowerCase();
                    return keeperSortDirection === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else if (column === 'position') {
                    aVal = a.dataset.position;
                    bVal = b.dataset.position;
                    return keeperSortDirection === 'asc'
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else if (column === 'pts2025') {
                    aVal = parseFloat(a.dataset.pts2025) || 0;
                    bVal = parseFloat(b.dataset.pts2025) || 0;
                } else if (column === 'pts2026') {
                    aVal = parseFloat(a.dataset.pts2026) || 0;
                    bVal = parseFloat(b.dataset.pts2026) || 0;
                } else if (column === 'drafted') {
                    aVal = parseFloat(a.dataset.drafted) || 99;
                    bVal = parseFloat(b.dataset.drafted) || 99;
                } else if (column === 'rdcost') {
                    aVal = parseFloat(a.dataset.roundCost) || 99;
                    bVal = parseFloat(b.dataset.roundCost) || 99;
                } else if (column === 'cost') {
                    aVal = parseFloat(a.dataset.dollarCost) || 0;
                    bVal = parseFloat(b.dataset.dollarCost) || 0;
                }

                if (keeperSortDirection === 'asc') {
                    return aVal - bVal;
                } else {
                    return bVal - aVal;
                }
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        function toggleKeeper(playerName, isKeeping) {
            if (!currentKeeperTeam) return;

            // Initialize array if needed
            if (!keeperSelections[currentKeeperTeam]) {
                keeperSelections[currentKeeperTeam] = [];
            }

            const teamKeepers = keeperSelections[currentKeeperTeam];
            const existingIndex = teamKeepers.findIndex(k => k.player_name.toLowerCase() === playerName.toLowerCase());

            if (isKeeping) {
                // Get player data to check prospect status
                const player = keeperRosterData.find(p => p.name === playerName);
                const draftInfo = getPlayerDraftInfo(playerName);
                const isUndrafted = draftInfo ? draftInfo.isUndrafted : true;

                // Check if player qualifies as a prospect (free keeper)
                const stats = player?.stats || {};
                const isPitcher = ['SP', 'RP', 'P'].includes(player?.primary_position);
                const hasLimitedTime = isPitcher
                    ? (stats.IP || 0) < 50
                    : (stats.AB || 0) < 130;

                // Check if player has any previous season history in the league WITH points scored
                const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
                const playerHistory = playerHistoryData[normalizedName];
                const hasPreviousSeasons = playerHistory && playerHistory.seasons &&
                    playerHistory.seasons.some(s => s.year < 2025 && (s.fantasy_points || 0) > 0);

                // Only a prospect if undrafted, limited time, AND no previous seasons with points
                const isProspect = isUndrafted && hasLimitedTime && !hasPreviousSeasons;

                // Prospects are free - no dollar or round cost
                const dollarCost = isProspect ? 0 : (draftInfo ? draftInfo.dollarCost : 1);
                const roundCost = isProspect ? 0 : (draftInfo ? draftInfo.roundCost : getTotalDraftRounds());

                // Check budget (only for non-prospects)
                if (!isProspect) {
                    const currentBudgetUsed = calculateTeamBudgetUsed(currentKeeperTeam);
                    const teamTotalBudget = getTeamBudget ? getTeamBudget(currentKeeperTeam) : KEEPER_BUDGET;
                    if (currentBudgetUsed + dollarCost > teamTotalBudget) {
                        alert(`Adding this player would exceed your keeper budget.\n\nYour Budget: $${teamTotalBudget}\nCurrently Used: $${currentBudgetUsed}\nThis player: $${dollarCost}\nTotal would be: $${currentBudgetUsed + dollarCost}`);
                        // Uncheck box
                        const row = document.querySelector(`tr[data-player-name="${playerName}"]`);
                        if (row) {
                            row.querySelector('.keeper-checkbox').checked = false;
                        }
                        return;
                    }

                    // Check if there's an available pick at or before the required round
                    const canKeepResult = canKeepPlayerWithPick(playerName, roundCost);
                    if (!canKeepResult.canKeep) {
                        alert(`Cannot keep ${playerName}.\n\n${canKeepResult.reason}\n\nYou need a pick in round ${roundCost} or earlier to keep this player.`);
                        // Uncheck box
                        const row = document.querySelector(`tr[data-player-name="${playerName}"]`);
                        if (row) {
                            row.querySelector('.keeper-checkbox').checked = false;
                        }
                        return;
                    }
                }

                // Add keeper with cost info
                if (existingIndex === -1) {
                    teamKeepers.push({
                        player_name: playerName,
                        player_id: player?.player_key || '',
                        position: player?.primary_position || '',
                        fantasy_points_2025: player?.fantasy_points || 0,
                        dollarCost: dollarCost,
                        roundCost: roundCost,
                        draftRound: draftInfo?.round || null,
                        isUndrafted: isUndrafted,
                        isProspect: isProspect
                    });
                }
            } else {
                // Remove keeper
                if (existingIndex !== -1) {
                    teamKeepers.splice(existingIndex, 1);
                }
            }

            // Trigger updates immediately
            updateKeeperRosterDisplay();
            updateKeeperStatus();
            updateKeeperSelectedSummary();
        }

        // Check if a player can be kept given their round cost and current keeper selections
        function canKeepPlayerWithPick(playerName, requiredRound) {
            const teamPicks = getTeamPicks(currentKeeperTeam);
            const currentKeepers = (keeperSelections[currentKeeperTeam] || []).filter(k => !k.isProspect);

            console.log('canKeepPlayerWithPick:', playerName, 'requiredRound:', requiredRound);
            console.log('Current keepers for team:', currentKeepers.map(k => `${k.player_name} (Rd ${k.roundCost})`));
            console.log('Team picks:', teamPicks.map(p => `Rd ${p.round}`));

            // Check if we have at least one pick at or before the required round
            const eligiblePicksForNewPlayer = teamPicks.filter(p => p.round <= requiredRound);

            if (eligiblePicksForNewPlayer.length === 0) {
                return {
                    canKeep: false,
                    reason: `You don't have any draft picks in rounds 1-${requiredRound}.`
                };
            }

            // Count ALL picks (not just eligible ones) - keepers use their own round cost picks
            const pickCounts = {};
            teamPicks.forEach(pick => {
                pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
            });

            // Get all current keepers plus the new player we're trying to add
            const keeperRoundCosts = currentKeepers.map(k => ({
                player_name: k.player_name,
                roundCost: k.roundCost
            }));

            // Add the new player we're trying to keep
            keeperRoundCosts.push({
                player_name: playerName,
                roundCost: requiredRound
            });

            // Sort by round cost descending (latest rounds first - they get assigned first)
            keeperRoundCosts.sort((a, b) => b.roundCost - a.roundCost);

            console.log('Attempting to assign keepers:', keeperRoundCosts.map(k => `${k.player_name} (Rd ${k.roundCost})`));

            // Track used picks at each round
            const usedPicksAtRound = {};

            // Try to assign each keeper to a pick
            for (const keeper of keeperRoundCosts) {
                let assigned = false;

                // Try to find an available pick at the keeper's round cost first, then work backwards
                for (let round = keeper.roundCost; round >= 1; round--) {
                    const available = (pickCounts[round] || 0) - (usedPicksAtRound[round] || 0);
                    if (available > 0) {
                        usedPicksAtRound[round] = (usedPicksAtRound[round] || 0) + 1;
                        assigned = true;
                        console.log(`  ${keeper.player_name} (needs Rd ${keeper.roundCost}) -> assigned to Rd ${round}`);
                        break;
                    }
                }

                if (!assigned) {
                    if (keeper.player_name === playerName) {
                        // This is the player we're trying to add and they couldn't be assigned
                        const usedRounds = Object.entries(usedPicksAtRound)
                            .filter(([r, c]) => c > 0)
                            .map(([r]) => `Rd ${r}`)
                            .join(', ');

                        return {
                            canKeep: false,
                            reason: `All your available picks in rounds 1-${requiredRound} are already being used by other keepers${usedRounds ? ` (${usedRounds})` : ''}.`
                        };
                    } else {
                        // An existing keeper couldn't be assigned - this shouldn't happen if data is valid
                        console.warn(`Warning: Existing keeper ${keeper.player_name} couldn't be assigned a pick`);
                    }
                }
            }

            return { canKeep: true };
        }

        function updateKeeperStatus() {
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];
            const statusEl = document.getElementById('keeper-status');
            const barEl = document.getElementById('keeper-progress-bar');

            // Calculate budget used and team's total budget (may be affected by trades)
            const budgetUsed = calculateTeamBudgetUsed(currentKeeperTeam);
            const teamTotalBudget = getTeamBudget ? getTeamBudget(currentKeeperTeam) : KEEPER_BUDGET;
            const budgetRemaining = teamTotalBudget - budgetUsed;

            // Count prospects vs regular keepers
            const prospectCount = teamKeepers.filter(k => k.isProspect).length;
            const regularCount = teamKeepers.filter(k => !k.isProspect).length;

            // Update status text to show budget and prospect count
            let statusText = `$${budgetUsed} / $${teamTotalBudget} used (${regularCount} keeper${regularCount !== 1 ? 's' : ''})`;
            if (prospectCount > 0) {
                statusText += ` + ${prospectCount} prospect${prospectCount !== 1 ? 's' : ''}`;
            }
            statusEl.textContent = statusText;

            // Update progress bar based on budget
            if (barEl) {
                const percentage = teamTotalBudget > 0 ? Math.min((budgetUsed / teamTotalBudget) * 100, 100) : 0;
                barEl.style.width = percentage + '%';

                // Add/remove full class for color change
                if (budgetUsed >= teamTotalBudget) {
                    barEl.classList.add('full');
                    statusEl.classList.add('full');
                } else {
                    barEl.classList.remove('full');
                    statusEl.classList.remove('full');
                }
            }
        }

        function saveKeeperSelections() {
            // Save current team's selections to localStorage
            const localData = JSON.parse(localStorage.getItem('keeper_selections_2026') || '{}');
            localData[currentKeeperTeam] = keeperSelections[currentKeeperTeam];
            localStorage.setItem('keeper_selections_2026', JSON.stringify(localData));
        }

        async function clearKeeperCache() {
            // Show current state before clearing
            const localData = localStorage.getItem('keeper_selections_2026');
            console.log('=== BEFORE CLEAR ===');
            console.log('localStorage keeper_selections_2026:', localData);
            console.log('In-memory keeperSelections:', JSON.stringify(keeperSelections, null, 2));

            if (!confirm('This will clear all locally cached keeper data and reload from Firebase. Continue?')) {
                return;
            }

            // Clear localStorage
            localStorage.removeItem('keeper_selections_2026');
            console.log('Cleared keeper_selections_2026 from localStorage');

            // Reset in-memory data
            keeperSelections = {};

            // Reload from Firebase
            if (firebaseDb) {
                try {
                    const snapshot = await firebaseDb.ref('keepers_2026').once('value');
                    const data = snapshot.val();
                    console.log('Raw Firebase data:', data);
                    if (data) {
                        Object.entries(data).forEach(([sanitizedKey, keepers]) => {
                            const teamKey = unsanitizeFirebaseKey(sanitizedKey);
                            if (Array.isArray(keepers)) {
                                keeperSelections[teamKey] = keepers;
                            } else if (keepers && typeof keepers === 'object') {
                                keeperSelections[teamKey] = Object.values(keepers);
                            }
                        });
                    }
                    console.log('=== AFTER RELOAD ===');
                    console.log('In-memory keeperSelections:', JSON.stringify(keeperSelections, null, 2));
                } catch (e) {
                    console.error('Error reloading from Firebase:', e);
                }
            } else {
                console.log('Firebase not available');
            }

            // Refresh display
            displayLeagueKeepers();

            alert('✅ Cache cleared! Check console for details.');
        }

        function updateKeeperRosterDisplay() {
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];
            const keeperNames = teamKeepers.map(k => k.player_name.toLowerCase());

            document.querySelectorAll('#keeper-roster-body tr').forEach(row => {
                const playerName = row.dataset.playerName;
                const isKept = keeperNames.includes(playerName.toLowerCase());

                row.className = isKept ? 'is-keeper' : '';

                // Update checkbox
                const checkbox = row.querySelector('.keeper-checkbox');
                if (checkbox) checkbox.checked = isKept;

                // Update keeper badge
                const nameCell = row.querySelector('.player-name-cell');
                const existingBadge = nameCell.querySelector('.keeper-badge');
                if (isKept && !existingBadge) {
                    nameCell.insertAdjacentHTML('beforeend', '<span class="keeper-badge">K</span>');
                } else if (!isKept && existingBadge) {
                    existingBadge.remove();
                }
            });

            // Also update the picks display
            updateKeeperPicksDisplay();
        }

        function toggleTradedPicks() {
            showTradedPicks = !showTradedPicks;
            const btn = document.getElementById('keeper-toggle-traded');
            const text = document.getElementById('toggle-traded-text');

            if (showTradedPicks) {
                btn.classList.add('active');
                text.textContent = 'Hide Traded';
            } else {
                btn.classList.remove('active');
                text.textContent = 'Show Traded';
            }

            updateKeeperPicksDisplay();
        }

        function updateKeeperPicksDisplay() {
            const grid = document.getElementById('keeper-picks-grid');
            if (!grid || !currentKeeperTeam) return;

            const totalRounds = getTotalDraftRounds();
            const teamPicks = getTeamPicks(currentKeeperTeam);
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];

            // Separate prospects from regular keepers
            const regularKeepers = teamKeepers.filter(k => !k.isProspect);
            const prospects = teamKeepers.filter(k => k.isProspect);

            // Calculate which rounds are used by regular keepers (not prospects)
            const roundCosts = calculateTeamKeeperRoundCosts(currentKeeperTeam);

            // Build a map of round -> keeper info for picks used (only regular keepers)
            const keeperByRound = {};
            roundCosts.forEach(rc => {
                const keeper = regularKeepers.find(k => k.player_name === rc.player_name);
                if (keeper && rc.actualRoundCost !== null) {
                    if (!keeperByRound[rc.actualRoundCost]) {
                        keeperByRound[rc.actualRoundCost] = [];
                    }
                    keeperByRound[rc.actualRoundCost].push({
                        name: rc.player_name,
                        headshot: keeperRosterData.find(p => p.name === rc.player_name)?.headshot_url
                    });
                }
            });

            // Build a map of which picks we own at each round
            const picksAtRound = {};
            teamPicks.forEach(pick => {
                if (!picksAtRound[pick.round]) {
                    picksAtRound[pick.round] = [];
                }
                picksAtRound[pick.round].push(pick);
            });

            // Generate HTML for each round
            let html = '';
            for (let round = 1; round <= totalRounds; round++) {
                const picks = picksAtRound[round] || [];
                const ownsPick = picks.length > 0;

                // Check if we traded away our pick at this round
                const tradedAway = !ownsPick;

                // Skip traded AWAY picks if toggle is off (but always show picks we own)
                if (!showTradedPicks && tradedAway) {
                    continue;
                }

                if (ownsPick) {
                    // Show each pick we own at this round (always show these regardless of toggle)
                    picks.forEach((pick, idx) => {
                        const isFromTrade = pick.originalOwner !== currentKeeperTeam;
                        const originalTeam = keeperConfig?.teams[pick.originalOwner]?.team_name || '';

                        // Check if this specific pick slot is used for a keeper
                        const keepersAtThisRound = keeperByRound[round] || [];
                        const keeperForThisPick = keepersAtThisRound[idx];

                        let boxClass = 'keeper-pick-box';
                        if (isFromTrade) boxClass += ' traded-for';
                        if (keeperForThisPick) boxClass += ' used-for-keeper';

                        const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                        if (keeperForThisPick) {
                            const headshot = keeperForThisPick.headshot || placeholderImg;

                            html += `
                                <div class="${boxClass}" title="${keeperForThisPick.name} - Round ${round}">
                                    <img src="${headshot}" class="keeper-headshot" onerror="this.src='${placeholderImg}'">
                                    <div class="keeper-overlay">
                                        <span>Rd ${round}</span>
                                    </div>
                                </div>
                            `;
                        } else {
                            html += `
                                <div class="${boxClass}" title="Round ${round}${isFromTrade ? ' (from ' + originalTeam + ')' : ''}">
                                    <span class="pick-round">Rd</span>
                                    <span class="pick-number">${round}</span>
                                    ${isFromTrade ? '<span class="traded-label">+Trade</span>' : ''}
                                </div>
                            `;
                        }
                    });
                } else if (showTradedPicks) {
                    // Traded away - only show if toggle is on
                    html += `
                        <div class="keeper-pick-box traded-away" title="Round ${round} - Traded Away">
                            <span class="pick-round">Rd</span>
                            <span class="pick-number">${round}</span>
                            <span class="traded-label">Traded</span>
                        </div>
                    `;
                }
            }

            // Add prospects section if there are any
            if (prospects.length > 0) {
                const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

                html += `<div class="keeper-prospects-divider">Prospects (Free)</div>`;

                prospects.forEach(prospect => {
                    const player = keeperRosterData.find(p => p.name === prospect.player_name);
                    const headshot = player?.headshot_url || placeholderImg;

                    html += `
                        <div class="keeper-pick-box prospect-pick" title="${prospect.player_name} - Free Prospect">
                            <img src="${headshot}" class="keeper-headshot" onerror="this.src='${placeholderImg}'">
                            <div class="keeper-overlay prospect-overlay">
                                <span>P</span>
                            </div>
                        </div>
                    `;
                });
            }

            grid.innerHTML = html;
        }

        function updateKeeperSelectedSummary() {
            const summaryEl = document.getElementById('keeper-selected-summary');
            const teamKeepers = keeperSelections[currentKeeperTeam] || [];

            if (teamKeepers.length === 0) {
                summaryEl.innerHTML = '<span class="no-selection">No keepers selected. Check the boxes next to players you want to keep.</span>';
            } else {
                const totalCost = calculateTeamBudgetUsed(currentKeeperTeam);
                const prospectCount = teamKeepers.filter(k => k.isProspect).length;

                // Calculate actual round costs (handling multiple last-round picks) - excludes prospects
                const roundCosts = calculateTeamKeeperRoundCosts(currentKeeperTeam);

                let headerText = `Selected Keepers (Total: $${totalCost})`;
                if (prospectCount > 0) {
                    headerText = `Selected Keepers ($${totalCost} + ${prospectCount} prospect${prospectCount !== 1 ? 's' : ''})`;
                }

                let summaryHtml = `<div class="keeper-summary-header">${headerText}</div>`;
                summaryHtml += '<div class="keeper-summary-list">';
                summaryHtml += teamKeepers.map(k => {
                    const isProspect = k.isProspect || false;

                    if (isProspect) {
                        // Prospect display - no round cost, $0
                        return `
                        <span class="selected-player is-prospect">
                            <span class="prospect-badge">P</span>
                            ${k.player_name}
                            <span class="keeper-cost-tag prospect-free">Free</span>
                            <span class="remove-keeper" onclick="toggleKeeper('${k.player_name.replace(/'/g, "\\'")}', false)" title="Remove">✕</span>
                        </span>
                    `;
                    } else {
                        // Regular keeper display
                        const roundInfo = roundCosts.find(rc => rc.player_name === k.player_name);
                        const actualRound = roundInfo ? roundInfo.actualRoundCost : k.roundCost;
                        const isAdjusted = roundInfo && roundInfo.actualRoundCost !== roundInfo.baseRoundCost;
                        const noPick = actualRound === null;

                        const roundDisplay = noPick
                            ? '<span class="keeper-round-tag no-pick">No Pick!</span>'
                            : `<span class="keeper-round-tag ${isAdjusted ? 'adjusted' : ''}">Rd ${actualRound}</span>`;

                        return `
                        <span class="selected-player ${noPick ? 'no-pick-warning' : ''}">
                            <span class="keeper-badge">K</span>
                            ${k.player_name}
                            <span class="keeper-cost-tag">$${k.dollarCost !== undefined ? k.dollarCost : 1}</span>
                            ${roundDisplay}
                            <span class="remove-keeper" onclick="toggleKeeper('${k.player_name.replace(/'/g, "\\'")}', false)" title="Remove">✕</span>
                        </span>
                    `;
                    }
                }).join('');
                summaryHtml += '</div>';
                summaryEl.innerHTML = summaryHtml;
            }

            // Update submit button state
            const submitBtn = document.getElementById('keeper-submit-btn');
            submitBtn.disabled = teamKeepers.length === 0;
        }

        async function submitKeepers() {
            if (!currentKeeperTeam) return;

            const teamKeepers = keeperSelections[currentKeeperTeam] || [];
            const teamInfo = keeperConfig.teams[currentKeeperTeam];

            if (teamKeepers.length === 0) {
                alert('Please select at least one keeper before submitting.');
                return;
            }

            // Separate prospects from regular keepers
            const regularKeepers = teamKeepers.filter(k => !k.isProspect);
            const prospects = teamKeepers.filter(k => k.isProspect);

            // Calculate total cost and actual round costs
            const totalCost = calculateTeamBudgetUsed(currentKeeperTeam);
            const roundCosts = calculateTeamKeeperRoundCosts(currentKeeperTeam);

            // Confirm submission with cost details
            let confirmMsg = `Submit the following keepers for ${teamInfo.team_name}?\n\n`;

            if (regularKeepers.length > 0) {
                confirmMsg += `KEEPERS:\n`;
                regularKeepers.forEach(k => {
                    const roundInfo = roundCosts.find(rc => rc.player_name === k.player_name);
                    const actualRound = roundInfo ? roundInfo.actualRoundCost : k.roundCost;
                    confirmMsg += `• ${k.player_name} ($${k.dollarCost !== undefined ? k.dollarCost : 1}, Round ${actualRound})\n`;
                });
            }

            if (prospects.length > 0) {
                confirmMsg += `\nPROSPECTS (Free):\n`;
                prospects.forEach(k => {
                    confirmMsg += `• ${k.player_name}\n`;
                });
            }

            confirmMsg += `\nTotal Budget Used: $${totalCost} / $${KEEPER_BUDGET}`;
            if (prospects.length > 0) {
                confirmMsg += ` + ${prospects.length} prospect${prospects.length !== 1 ? 's' : ''}`;
            }

            confirmMsg += `\n\nThis will be visible to all managers.`;

            const confirmed = confirm(confirmMsg);

            if (!confirmed) return;

            // Save to Firebase (primary) and localStorage (backup)
            const firebaseSaved = await saveKeepersToFirebase(currentKeeperTeam, teamKeepers);
            saveKeeperSelections(); // localStorage backup

            // Update the visual display of the league grid
            displayLeagueKeepers();

            // CRITICAL: Force re-render of the main projections table to show "K" badges immediately
            // We call filterProjections() which internally calls renderProjectionTable()
            filterProjections();

            // Show success message
            const keeperText = regularKeepers.length > 0 ? `${regularKeepers.length} keeper${regularKeepers.length !== 1 ? 's' : ''}` : '';
            const prospectText = prospects.length > 0 ? `${prospects.length} prospect${prospects.length !== 1 ? 's' : ''}` : '';
            const totalText = [keeperText, prospectText].filter(t => t).join(' and ');

            if (firebaseSaved) {
                alert(`✅ Keepers submitted successfully!\n\nYour ${totalText} have been saved and are now visible to all managers.`);
            } else {
                alert(`⚠️ Keepers saved locally.\n\nYour ${totalText} have been saved, but could not sync to the server. They will sync when connection is restored.`);
            }

            // Close the modal
            closeKeeperModal();
        }

        let displayLeagueKeepersRunning = false;
        
        async function displayLeagueKeepers() {
            // Prevent multiple simultaneous calls
            if (displayLeagueKeepersRunning) {
                console.log('displayLeagueKeepers already running, skipping');
                return;
            }
            displayLeagueKeepersRunning = true;
            
            try {
                const grid = document.getElementById('keeper-league-grid');
                if (!keeperConfig || !keeperConfig.teams) {
                    grid.innerHTML = '<p style="color: #888;">Keeper data not available.</p>';
                    return;
                }

                grid.innerHTML = '';

            // Ensure projections are loaded for display
            if (Object.keys(keeperProjectionsMap).length === 0) {
                try {
                    if (allProjectionBatters.length > 0 || allProjectionPitchers.length > 0) {
                        [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                            const normalizedName = p.name.toLowerCase().trim();
                            keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                        });
                    } else {
                        const projResponse = await fetch('data/projections/projections_steamer.json');
                        if (projResponse.ok) {
                            const projData = await projResponse.json();
                            [...(projData.batters || []), ...(projData.pitchers || [])].forEach(p => {
                                const normalizedName = p.name.toLowerCase().trim();
                                keeperProjectionsMap[normalizedName] = p.projected_points || 0;
                            });
                        }
                    }
                } catch (e) {
                    console.log('Could not load projections for league keepers:', e);
                }
            }

            // Sort teams by manager name
            const sortedTeams = Object.entries(keeperConfig.teams)
                .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

            for (const [teamKey, teamInfo] of sortedTeams) {
                const teamKeepers = keeperSelections[teamKey] || [];

                // Filter out prospects if toggle is off
                let displayKeepers = showLeagueProspects
                    ? [...teamKeepers]
                    : teamKeepers.filter(k => !k.isProspect);

                const budgetUsed = teamKeepers.reduce((sum, k) => sum + (k.dollarCost || 0), 0);
                const teamTotalBudget = getTeamBudget ? getTeamBudget(teamKey) : KEEPER_BUDGET;

                // Calculate actual round costs for this team's keepers
                const roundCosts = calculateTeamKeeperRoundCosts(teamKey);

                // Sort keepers: regular keepers first (by round asc, then proj pts desc), then prospects (by proj pts desc, then position)
                displayKeepers.sort((a, b) => {
                    const aIsProspect = a.isProspect || false;
                    const bIsProspect = b.isProspect || false;

                    // Regular keepers come before prospects
                    if (aIsProspect !== bIsProspect) {
                        return aIsProspect ? 1 : -1;
                    }

                    // Get projected points for sorting
                    const aProjPts = keeperProjectionsMap[a.player_name.toLowerCase().trim()] || 0;
                    const bProjPts = keeperProjectionsMap[b.player_name.toLowerCase().trim()] || 0;

                    if (aIsProspect) {
                        // Both are prospects: sort by projected points desc, then position alphabetically
                        if (bProjPts !== aProjPts) {
                            return bProjPts - aProjPts;
                        }
                        return (a.position || '').localeCompare(b.position || '');
                    } else {
                        // Both are regular keepers: sort by round asc, then projected points desc
                        const aRoundInfo = roundCosts.find(rc => rc.player_name === a.player_name);
                        const bRoundInfo = roundCosts.find(rc => rc.player_name === b.player_name);
                        const aRound = aRoundInfo ? aRoundInfo.actualRoundCost : (a.roundCost || 99);
                        const bRound = bRoundInfo ? bRoundInfo.actualRoundCost : (b.roundCost || 99);

                        // Handle null rounds (no pick) - sort them last among regular keepers
                        const aRoundVal = aRound === null ? 999 : aRound;
                        const bRoundVal = bRound === null ? 999 : bRound;

                        if (aRoundVal !== bRoundVal) {
                            return aRoundVal - bRoundVal;
                        }
                        // Same round: sort by projected points descending
                        return bProjPts - aProjPts;
                    }
                });

                const card = document.createElement('div');
                card.className = 'keeper-team-card';

                const logoImg = teamInfo.team_logo
                    ? `<img src="${teamInfo.team_logo}" class="keeper-team-card-logo" alt="">`
                    : '';

                let keepersHtml = '';
                if (displayKeepers.length === 0) {
                    keepersHtml = '<div class="no-keepers">No keepers selected yet</div>';
                } else {
                    keepersHtml = displayKeepers.map(k => {
                        const projPts = keeperProjectionsMap[k.player_name.toLowerCase().trim()];
                        const projDisplay = typeof projPts === 'number' ? projPts.toFixed(0) : '-';
                        const isProspect = k.isProspect || false;

                        // Find the actual round cost for this keeper
                        const roundInfo = roundCosts.find(rc => rc.player_name === k.player_name);
                        const actualRound = roundInfo ? roundInfo.actualRoundCost : k.roundCost;
                        const noPick = actualRound === null && !isProspect;

                        let roundDisplay;
                        if (isProspect) {
                            roundDisplay = '<span class="keeper-round-small prospect-free">Free</span>';
                        } else if (noPick) {
                            roundDisplay = '<span class="keeper-round-small no-pick">No Pick!</span>';
                        } else {
                            roundDisplay = `<span class="keeper-round-small">Rd ${actualRound}</span>`;
                        }

                        const costDisplay = isProspect
                            ? '<span class="keeper-cost-small prospect-free">$0</span>'
                            : `<span class="keeper-cost-small">$${k.dollarCost || 0}</span>`;

                        return `
                            <div class="keeper-player-row ${noPick ? 'no-pick-warning' : ''} ${isProspect ? 'is-prospect' : ''}">
                                ${isProspect ? '<span class="prospect-badge">P</span>' : '<span class="keeper-badge">K</span>'}
                                <span class="player-name">${k.player_name}</span>
                                ${getPositionBadge(k.position || '', k.player_name)}
                                ${roundDisplay}
                                ${costDisplay}
                                <span class="player-pts">${projDisplay}</span>
                            </div>
                        `;
                    }).join('');
                }

                // Count prospects vs regular keepers
                const prospectCount = teamKeepers.filter(k => k.isProspect).length;
                const regularCount = teamKeepers.filter(k => !k.isProspect).length;

                // Calculate budget bar - width proportional to team's total budget relative to default
                const maxBudgetForWidth = Math.max(KEEPER_BUDGET, teamTotalBudget);
                const barWidth = Math.round((teamTotalBudget / maxBudgetForWidth) * 100); // 100px max width scaled
                const fillPercentage = teamTotalBudget > 0 ? Math.min((budgetUsed / teamTotalBudget) * 100, 100) : 0;
                const barClass = budgetUsed > teamTotalBudget ? 'over' : (budgetUsed >= teamTotalBudget ? 'full' : '');

                // Build budget bar display
                let budgetDisplay = '';
                if (teamTotalBudget !== KEEPER_BUDGET || teamKeepers.length > 0) {
                    budgetDisplay = `
                        <div class="league-budget-container">
                            <div class="league-budget-bar-wrapper" style="width: ${barWidth}px;">
                                <div class="league-budget-bar ${barClass}" style="width: ${fillPercentage}%;"></div>
                            </div>
                            <span class="league-budget-text">$${budgetUsed}/$${teamTotalBudget}</span>
                            ${prospectCount > 0 && showLeagueProspects ? `<span class="prospect-count">(+${prospectCount}P)</span>` : ''}
                        </div>
                    `;
                }

                card.innerHTML = `
                    <div class="keeper-team-card-header">
                        ${logoImg}
                        <div class="keeper-team-card-info">
                            <h5>${teamInfo.team_name}</h5>
                            <span>${capitalizeManagerName(teamInfo.manager)}</span>
                            ${budgetDisplay}
                        </div>
                    </div>
                    <div class="keeper-team-card-body">
                        ${keepersHtml}
                    </div>
                `;

                grid.appendChild(card);
            }

            // Update keeper value analysis
            initializeKeeperValueAnalysis();
            } finally {
                displayLeagueKeepersRunning = false;
            }
        }

        function toggleLeagueProspects() {
            showLeagueProspects = !showLeagueProspects;
            const btn = document.getElementById('btn-toggle-prospects');
            const text = document.getElementById('toggle-prospects-text');

            if (showLeagueProspects) {
                btn.classList.add('active');
                text.textContent = 'Hide Prospects';
            } else {
                btn.classList.remove('active');
                text.textContent = 'Show Prospects';
            }

            displayLeagueKeepers();
        }

        // ===== BUDGET ADJUSTMENT =====

        let manualBudgetAdjustments = {}; // Store manual budget adjustments
        let budgetsLoadedFromServer = false;

        async function loadManualBudgetAdjustments() {
            // First try to load from server JSON file
            try {
                const response = await fetch('data/keepers/budget_adjustments_2026.json');
                if (response.ok) {
                    const serverData = await response.json();
                    // Extract just the adjustment values from the server data
                    if (serverData.adjustments) {
                        Object.entries(serverData.adjustments).forEach(([teamKey, data]) => {
                            if (typeof data === 'object' && data.adjustment !== undefined) {
                                manualBudgetAdjustments[teamKey] = data.adjustment;
                            } else if (typeof data === 'number') {
                                manualBudgetAdjustments[teamKey] = data;
                            }
                        });
                    }
                    budgetsLoadedFromServer = true;
                    console.log(`Loaded budget adjustments from server for ${Object.keys(manualBudgetAdjustments).length} teams`);
                }
            } catch (e) {
                console.log('No server budget adjustments file found, checking localStorage');
            }

            // If no server data, check localStorage
            if (!budgetsLoadedFromServer) {
                try {
                    const saved = localStorage.getItem('keeper_budget_adjustments_2026');
                    if (saved) {
                        manualBudgetAdjustments = JSON.parse(saved);
                    }
                } catch (e) {
                    console.log('Could not load budget adjustments from localStorage:', e);
                }
            }
        }

        function saveManualBudgetAdjustments() {
            try {
                localStorage.setItem('keeper_budget_adjustments_2026', JSON.stringify(manualBudgetAdjustments));
            } catch (e) {
                console.log('Could not save budget adjustments:', e);
            }
        }

        function openBudgetAdjustmentModal() {
            const modal = document.getElementById('budget-adjustment-modal');
            const listEl = document.getElementById('budget-adjustment-list');

            if (!keeperConfig || !keeperConfig.teams) {
                alert('Keeper configuration not loaded yet.');
                return;
            }

            // Sort teams by manager name
            const sortedTeams = Object.entries(keeperConfig.teams)
                .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

            let html = '';
            sortedTeams.forEach(([teamKey, teamInfo]) => {
                const logoImg = teamInfo.team_logo
                    ? `<img src="${teamInfo.team_logo}" class="team-logo" alt="">`
                    : '<div class="team-logo" style="background: #1e3c72;"></div>';

                // Get current budget (base + trades + manual adjustments)
                const baseBudget = KEEPER_BUDGET;
                const tradeAdjustment = getTradeAdjustedBudget(teamKey) - baseBudget;
                const manualAdjustment = manualBudgetAdjustments[teamKey] || 0;
                const currentBudget = baseBudget + tradeAdjustment + manualAdjustment;

                html += `
                    <div class="budget-row" data-team-key="${teamKey}">
                        ${logoImg}
                        <div class="team-info">
                            <div class="team-name">${teamInfo.team_name}</div>
                            <div class="manager-name">${teamInfo.manager}</div>
                        </div>
                        <div class="budget-input-group">
                            <span>$</span>
                            <input type="number" class="budget-input" 
                                   id="budget-input-${teamKey}" 
                                   value="${currentBudget}" 
                                   min="0" max="200"
                                   data-base="${baseBudget + tradeAdjustment}"
                                   onchange="updateBudgetDiff('${teamKey}')">
                            <span class="budget-diff" id="budget-diff-${teamKey}"></span>
                        </div>
                    </div>
                `;
            });

            listEl.innerHTML = html;

            // Update all diffs
            sortedTeams.forEach(([teamKey]) => updateBudgetDiff(teamKey));

            modal.style.display = 'flex';
        }

        function updateBudgetDiff(teamKey) {
            const input = document.getElementById(`budget-input-${teamKey}`);
            const diffEl = document.getElementById(`budget-diff-${teamKey}`);

            if (!input || !diffEl) return;

            const baseValue = parseFloat(input.dataset.base) || KEEPER_BUDGET;
            const currentValue = parseFloat(input.value) || 0;
            const diff = currentValue - baseValue;

            if (diff > 0) {
                diffEl.textContent = `+$${diff}`;
                diffEl.className = 'budget-diff positive';
            } else if (diff < 0) {
                diffEl.textContent = `-$${Math.abs(diff)}`;
                diffEl.className = 'budget-diff negative';
            } else {
                diffEl.textContent = '';
                diffEl.className = 'budget-diff';
            }
        }

        function getTradeAdjustedBudget(teamKey) {
            // This gets the budget after trades but before manual adjustments
            let budget = KEEPER_BUDGET;

            if (tradeData && tradeData.trades) {
                tradeData.trades.forEach(trade => {
                    if (trade.teamA === teamKey) {
                        // Team A receives assets from B, gives up assets to B
                        trade.assetsB?.forEach(asset => {
                            if (asset.type === 'money') budget += (asset.amount || 0);
                        });
                        trade.assetsA?.forEach(asset => {
                            if (asset.type === 'money') budget -= (asset.amount || 0);
                        });
                    } else if (trade.teamB === teamKey) {
                        // Team B receives assets from A, gives up assets to A
                        trade.assetsA?.forEach(asset => {
                            if (asset.type === 'money') budget += (asset.amount || 0);
                        });
                        trade.assetsB?.forEach(asset => {
                            if (asset.type === 'money') budget -= (asset.amount || 0);
                        });
                    }
                });
            }

            return budget;
        }

        function saveBudgetAdjustments() {
            const rows = document.querySelectorAll('.budget-row');

            rows.forEach(row => {
                const teamKey = row.dataset.teamKey;
                const input = row.querySelector('.budget-input');
                const baseValue = parseFloat(input.dataset.base) || KEEPER_BUDGET;
                const currentValue = parseFloat(input.value) || KEEPER_BUDGET;
                const manualAdjustment = currentValue - baseValue;

                if (manualAdjustment !== 0) {
                    manualBudgetAdjustments[teamKey] = manualAdjustment;
                } else {
                    delete manualBudgetAdjustments[teamKey];
                }
            });

            saveManualBudgetAdjustments();
            closeBudgetModal();
            displayLeagueKeepers();

            alert('✅ Budget adjustments saved!');
        }

        function resetAllBudgets() {
            if (!confirm('Reset all manual budget adjustments to default ($50 + trade adjustments)?')) {
                return;
            }

            manualBudgetAdjustments = {};
            saveManualBudgetAdjustments();
            closeBudgetModal();
            displayLeagueKeepers();

            alert('✅ All budgets reset to defaults.');
        }

        function closeBudgetModal() {
            document.getElementById('budget-adjustment-modal').style.display = 'none';
        }

        function exportBudgetsForSite() {
            // First save current changes
            const rows = document.querySelectorAll('.budget-row');
            rows.forEach(row => {
                const teamKey = row.dataset.teamKey;
                const input = row.querySelector('.budget-input');
                const baseValue = parseFloat(input.dataset.base) || KEEPER_BUDGET;
                const currentValue = parseFloat(input.value) || KEEPER_BUDGET;
                const manualAdjustment = currentValue - baseValue;

                if (manualAdjustment !== 0) {
                    manualBudgetAdjustments[teamKey] = manualAdjustment;
                } else {
                    delete manualBudgetAdjustments[teamKey];
                }
            });
            saveManualBudgetAdjustments();

            // Build export object with team details for readability
            const exportData = {
                "_comment": "Fantasy Baseball Civil War - Budget Adjustments for 2026 Season",
                "_updated": new Date().toISOString(),
                "adjustments": {}
            };

            // Add adjustments with team names for clarity
            Object.entries(manualBudgetAdjustments).forEach(([teamKey, adjustment]) => {
                const teamInfo = keeperConfig?.teams[teamKey];
                exportData.adjustments[teamKey] = {
                    team_name: teamInfo?.team_name || 'Unknown',
                    manager: teamInfo?.manager || 'Unknown',
                    adjustment: adjustment
                };
            });

            const jsonString = JSON.stringify(exportData, null, 2);
            document.getElementById('export-budgets-json-content').value = jsonString;
            document.getElementById('export-budgets-modal').style.display = 'flex';
        }

        function closeExportBudgetsModal() {
            document.getElementById('export-budgets-modal').style.display = 'none';
        }

        function copyExportBudgetsJson() {
            const textarea = document.getElementById('export-budgets-json-content');
            textarea.select();
            document.execCommand('copy');
            alert('✅ Budget adjustments JSON copied to clipboard!');
        }

        function downloadExportBudgetsJson() {
            const content = document.getElementById('export-budgets-json-content').value;
            const blob = new Blob([content], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'budget_adjustments_2026.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ===== KEEPER VALUE ANALYSIS =====

        let expectedPointsByRound = {};
        let keeperValueData = {
            teams: [],
            prospects: [],
            allKeepers: []
        };
        let expectedPointsChart = null;
        let valueScatterChart = null;

        async function calculateExpectedPoints() {
            // Load draft data from all years (2019-2025)
            const years = [2019, 2020, 2021, 2022, 2023, 2024, 2025];
            const weights = {
                2025: 2.0,   // Most recent, highest weight
                2024: 1.75,
                2023: 1.5,
                2022: 1.25,
                2021: 1.0,
                2020: 0.75,  // COVID year, lower weight
                2019: 0.75
            };

            // Load keepers data to exclude from calculations
            let allKeepersData = {};
            try {
                const keepersResponse = await fetch('data/keepers.json');
                if (keepersResponse.ok) {
                    allKeepersData = await keepersResponse.json();
                }
            } catch (e) {
                console.log('Could not load keepers data for exclusion');
            }

            const roundStats = {}; // { round: { totalPoints: 0, totalWeight: 0, picks: [] } }

            for (const year of years) {
                try {
                    // Load draft data
                    const draftPath = year === 2025 
                        ? 'data/current_season/draft.json' 
                        : `data/historical/${year}/draft.json`;
                    const draftResponse = await fetch(draftPath);
                    if (!draftResponse.ok) {
                        console.log(`Draft data not found for ${year}: ${draftPath}`);
                        continue;
                    }
                    const draftData = await draftResponse.json();
                    console.log(`Loaded ${draftData.length} draft picks for ${year}`);

                    // Load player stats for that year
                    const statsPath = year === 2025 
                        ? 'data/current_season/player_stats.json' 
                        : `data/historical/${year}/player_stats.json`;
                    const statsResponse = await fetch(statsPath);
                    if (!statsResponse.ok) {
                        console.log(`Player stats not found for ${year}: ${statsPath}`);
                        continue;
                    }
                    const statsData = await statsResponse.json();
                    console.log(`Loaded ${statsData.length} player stats for ${year}`);

                    // Create player lookup by name (handle Ohtani special case)
                    const playerStatsByName = {};
                    statsData.forEach(p => {
                        if (p.name) {
                            const nameLower = p.name.toLowerCase().trim();
                            playerStatsByName[nameLower] = p;
                            // Also store without (Batter)/(Pitcher) suffix for matching
                            const baseName = nameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                            if (baseName !== nameLower && !playerStatsByName[baseName]) {
                                playerStatsByName[baseName] = p;
                            }
                        }
                    });

                    // Get keepers for this year to exclude
                    const yearKeepers = allKeepersData[year.toString()] || {};
                    const keeperNamesLower = Object.keys(yearKeepers).map(n => n.toLowerCase().trim());

                    const weight = weights[year] || 1.0;

                    // Process each draft pick
                    draftData.forEach(pick => {
                        const round = pick.round;
                        const playerName = pick.player_name || '';
                        
                        // Skip if this player was a keeper
                        if (keeperNamesLower.includes(playerName.toLowerCase().trim())) {
                            return;
                        }

                        // Find player stats
                        const playerStats = playerStatsByName[playerName.toLowerCase().trim()];
                        const fantasyPoints = playerStats?.fantasy_points || 0;
                        
                        // Skip players with 0 points (injured, didn't play, etc.)
                        if (fantasyPoints === 0) {
                            return;
                        }

                        // Initialize round if needed
                        if (!roundStats[round]) {
                            roundStats[round] = { totalPoints: 0, totalWeight: 0, picks: [] };
                        }

                        // Add weighted points
                        roundStats[round].totalPoints += fantasyPoints * weight;
                        roundStats[round].totalWeight += weight;
                        roundStats[round].picks.push({
                            year,
                            player: playerName,
                            points: fantasyPoints,
                            weight
                        });
                    });

                } catch (e) {
                    console.log(`Error processing year ${year}:`, e);
                }
            }

            // Calculate weighted averages
            const result = {};
            for (let round = 1; round <= 23; round++) {
                const stats = roundStats[round];
                if (stats && stats.totalWeight > 0) {
                    result[round] = {
                        avg: Math.round(stats.totalPoints / stats.totalWeight),
                        sampleSize: stats.picks.length,
                        picks: stats.picks
                    };
                } else {
                    result[round] = { avg: 0, sampleSize: 0, picks: [] };
                }
            }

            expectedPointsByRound = result;
            
            // Fit exponential decay model: y = a * e^(-b * x) + c
            // Using least squares fitting on the log-transformed data
            fitExpectedPointsModel(result);
            
            console.log('Expected points by round:', expectedPointsByRound);
            return result;
        }
        
        // Model parameters for expected points prediction
        let expectedPointsModel = { a: 400, b: 0.15, c: 50 };
        
        function fitExpectedPointsModel(data) {
            // Collect data points for fitting
            const points = [];
            for (let round = 1; round <= 23; round++) {
                if (data[round] && data[round].avg > 0) {
                    points.push({ x: round, y: data[round].avg });
                }
            }
            
            if (points.length < 3) return;
            
            // Use iterative least squares to fit y = a * e^(-b * x) + c
            // Start with reasonable initial guesses
            let a = points[0].y - points[points.length - 1].y;
            let b = 0.12;
            let c = points[points.length - 1].y * 0.8;
            
            // Simple gradient descent optimization
            const learningRate = 0.0001;
            const iterations = 1000;
            
            for (let iter = 0; iter < iterations; iter++) {
                let gradA = 0, gradB = 0, gradC = 0;
                
                for (const p of points) {
                    const predicted = a * Math.exp(-b * p.x) + c;
                    const error = predicted - p.y;
                    const expTerm = Math.exp(-b * p.x);
                    
                    gradA += error * expTerm;
                    gradB += error * a * (-p.x) * expTerm;
                    gradC += error;
                }
                
                a -= learningRate * gradA;
                b -= learningRate * 0.01 * gradB; // Smaller learning rate for b
                c -= learningRate * gradC;
                
                // Keep parameters in reasonable bounds
                a = Math.max(100, Math.min(800, a));
                b = Math.max(0.05, Math.min(0.3, b));
                c = Math.max(0, Math.min(200, c));
            }
            
            expectedPointsModel = { a, b, c };
            console.log('Fitted model parameters:', expectedPointsModel);
        }
        
        function predictExpectedPoints(round) {
            const { a, b, c } = expectedPointsModel;
            return Math.round(a * Math.exp(-b * round) + c);
        }

        async function analyzeKeeperValues() {
            const loadingEl = document.getElementById('keeper-value-loading');
            const contentEl = document.getElementById('keeper-value-content');

            if (!loadingEl || !contentEl) {
                console.error('Keeper value elements not found');
                return;
            }

            loadingEl.style.display = 'block';
            contentEl.style.display = 'none';

            // Step 1: Calculate expected points (this should always work)
            try {
                if (Object.keys(expectedPointsByRound).length === 0) {
                    await calculateExpectedPoints();
                }
            } catch (e) {
                console.error('Error calculating expected points:', e);
            }

            // Step 2: Always render expected points chart
            try {
                renderExpectedPointsChart();
            } catch (e) {
                console.error('Error rendering expected points chart:', e);
            }

            // Step 3: Try to load teams data
            let teamsData = [];
            try {
                const teamsResponse = await fetch('data/current_season/teams.json');
                if (teamsResponse.ok) {
                    teamsData = await teamsResponse.json();
                }
            } catch (e) {
                console.log('Could not load teams data:', e);
            }

            // Step 4: Build projections map
            let localProjectionsMap = {};
            try {
                // First try to use global projections if loaded
                if (allProjectionBatters.length > 0 || allProjectionPitchers.length > 0) {
                    [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                        const nameLower = p.name.toLowerCase().trim();
                        localProjectionsMap[nameLower] = p.projected_points || 0;
                    });
                }
                
                // If still empty, try loading from file
                if (Object.keys(localProjectionsMap).length === 0) {
                    const projResponse = await fetch('data/projections/projections_steamer.json');
                    if (projResponse.ok) {
                        const projData = await projResponse.json();
                        [...(projData.batters || []), ...(projData.pitchers || [])].forEach(p => {
                            const nameLower = p.name.toLowerCase().trim();
                            localProjectionsMap[nameLower] = p.projected_points || 0;
                        });
                    }
                }
            } catch (e) {
                console.log('Could not load projections:', e);
            }

            // Step 5: Check if we have keeper selections from Firebase
            const hasKeeperSelections = Object.keys(keeperSelections).length > 0;
            
            if (!hasKeeperSelections) {
                // Show placeholder messages but keep the expected points chart visible
                const rankingsBody = document.getElementById('value-rankings-body');
                if (rankingsBody) {
                    rankingsBody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; font-style: italic; padding: 1rem;">Waiting for keeper selections from Firebase...</td></tr>';
                }
                
                const teamGrid = document.getElementById('team-value-grid');
                if (teamGrid) {
                    teamGrid.innerHTML = '<p style="color: #666; font-style: italic; grid-column: 1 / -1; text-align: center; padding: 2rem;">Team keeper breakdowns will appear once keeper selections have been made.</p>';
                }
                
                const prospectsSection = document.getElementById('prospects-value-section');
                if (prospectsSection) prospectsSection.style.display = 'none';
                
                const scatterWrapper = document.querySelector('.value-scatter-wrapper');
                if (scatterWrapper) scatterWrapper.style.display = 'none';
                
                loadingEl.style.display = 'none';
                contentEl.style.display = 'block';
                return;
            }

            // Step 6: Process each team's keepers
            const teamValues = [];
            const allKeepers = [];
            const prospects = [];

            for (const team of teamsData) {
                const teamKeepers = keeperSelections[team.team_key] || [];
                
                if (teamKeepers.length === 0) continue;

                let totalProjected = 0;
                let totalExpected = 0;
                const keeperDetails = [];

                for (const keeper of teamKeepers) {
                    const playerNameNorm = (keeper.player_name || '').toLowerCase().trim();
                    // Try exact match first, then try without (Batter)/(Pitcher) suffix
                    let projectedPts = localProjectionsMap[playerNameNorm] || keeperProjectionsMap[playerNameNorm];
                    if (projectedPts === undefined || projectedPts === 0) {
                        // Try without suffix (for players like "Shohei Ohtani (Batter)")
                        const baseNameNorm = playerNameNorm.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                        if (baseNameNorm !== playerNameNorm) {
                            projectedPts = localProjectionsMap[baseNameNorm] || keeperProjectionsMap[baseNameNorm] || 0;
                        }
                    }
                    projectedPts = projectedPts || 0;
                    
                    const isProspect = keeper.isProspect || false;
                    const roundCost = keeper.roundCost || 0;
                    const expectedPts = isProspect ? 0 : (expectedPointsByRound[roundCost]?.avg || 0);
                    const value = projectedPts - expectedPts;

                    const keeperData = {
                        player_name: keeper.player_name,
                        team_key: team.team_key,
                        team_name: team.team_name,
                        manager: team.manager,
                        team_logo: team.team_logo,
                        position: keeper.position || '',
                        roundCost: roundCost,
                        isProspect: isProspect,
                        projectedPts: projectedPts,
                        expectedPts: expectedPts,
                        value: value
                    };

                    if (isProspect) {
                        prospects.push(keeperData);
                    } else {
                        keeperDetails.push(keeperData);
                        allKeepers.push(keeperData);
                        totalProjected += projectedPts;
                        totalExpected += expectedPts;
                    }
                }

                // Sort keepers by round
                keeperDetails.sort((a, b) => a.roundCost - b.roundCost);

                if (keeperDetails.length > 0) {
                    // Calculate pick value for this team
                    const teamPicks = getTeamPicks(team.team_key) || [];
                    const roundCostsForTeam = calculateTeamKeeperRoundCosts(team.team_key);
                    
                    // Count used rounds
                    const usedRounds = {};
                    roundCostsForTeam.forEach(rc => {
                        usedRounds[rc.actualRoundCost] = (usedRounds[rc.actualRoundCost] || 0) + 1;
                    });
                    
                    // Count available picks at each round
                    const pickCounts = {};
                    teamPicks.forEach(pick => {
                        pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
                    });
                    
                    // Calculate total unused pick value
                    let totalPickValue = 0;
                    Object.keys(pickCounts).forEach(round => {
                        const roundNum = parseInt(round);
                        const available = pickCounts[roundNum] || 0;
                        const used = usedRounds[roundNum] || 0;
                        const unused = available - used;
                        if (unused > 0) {
                            const expectedPts = expectedPointsByRound[roundNum]?.avg || 0;
                            totalPickValue += expectedPts * unused;
                        }
                    });
                    
                    teamValues.push({
                        team_key: team.team_key,
                        team_name: team.team_name,
                        manager: capitalizeManagerName(team.manager || 'Unknown'),
                        team_logo: team.team_logo,
                        keepers: keeperDetails,
                        totalProjected: totalProjected,
                        totalExpected: totalExpected,
                        totalValue: totalProjected - totalExpected,
                        totalPickValue: totalPickValue,
                        combinedTotal: (totalProjected - totalExpected) + totalPickValue,
                        keeperCount: keeperDetails.length
                    });
                }
            }

            // Sort teams by combined total (keeper value + pick value)
            teamValues.sort((a, b) => b.combinedTotal - a.combinedTotal);

            // Sort prospects by projected points
            prospects.sort((a, b) => b.projectedPts - a.projectedPts);

            keeperValueData = {
                teams: teamValues,
                prospects: prospects,
                allKeepers: allKeepers
            };

            // Step 7: Render all components
            try {
                renderValueRankings(teamValues);
            } catch (e) {
                console.error('Error rendering value rankings:', e);
            }
            
            try {
                renderTeamValueCards(teamValues);
            } catch (e) {
                console.error('Error rendering team value cards:', e);
            }
            
            try {
                renderProspectsSection(prospects);
            } catch (e) {
                console.error('Error rendering prospects section:', e);
            }
            
            try {
                const scatterWrapper = document.querySelector('.value-scatter-wrapper');
                if (scatterWrapper) scatterWrapper.style.display = 'block';
                renderValueScatterChart(allKeepers, prospects);
            } catch (e) {
                console.error('Error rendering scatter chart:', e);
            }

            loadingEl.style.display = 'none';
            contentEl.style.display = 'block';
        }

        function renderExpectedPointsChart() {
            const ctx = document.getElementById('expected-points-chart');
            if (!ctx) {
                console.log('Expected points chart canvas not found');
                return;
            }

            // Destroy existing chart
            if (expectedPointsChart) {
                expectedPointsChart.destroy();
            }

            const rounds = Object.keys(expectedPointsByRound).map(Number).sort((a, b) => a - b);
            const data = rounds.map(r => expectedPointsByRound[r]?.avg || 0);
            
            console.log('Rendering expected points chart with', rounds.length, 'rounds');
            
            // If no data yet, show a message
            if (rounds.length === 0) {
                const container = ctx.parentElement;
                if (container) {
                    container.innerHTML = '<p style="color: #666; text-align: center; padding: 2rem;">Loading historical draft data...</p><canvas id="expected-points-chart"></canvas>';
                }
                return;
            }
            
            // Create gradient for bars
            const chartArea = ctx.getContext('2d');
            const gradient = chartArea.createLinearGradient(0, 0, ctx.width, 0);
            gradient.addColorStop(0, 'rgba(30, 60, 114, 0.85)');    // Dark blue for early rounds
            gradient.addColorStop(0.5, 'rgba(42, 82, 152, 0.75)');  // Medium blue
            gradient.addColorStop(1, 'rgba(100, 150, 200, 0.65)');  // Light blue for late rounds
            
            // Create individual bar colors based on round
            const barColors = rounds.map((r, i) => {
                const ratio = i / (rounds.length - 1);
                const r1 = Math.round(30 + ratio * 70);
                const g1 = Math.round(60 + ratio * 90);
                const b1 = Math.round(114 + ratio * 86);
                return `rgba(${r1}, ${g1}, ${b1}, 0.8)`;
            });

            expectedPointsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: rounds.map(r => `${r}`),
                    datasets: [
                        {
                            label: 'Historical Average',
                            data: data,
                            backgroundColor: barColors,
                            borderRadius: 3,
                            order: 2
                        },
                        {
                            label: 'Model Prediction',
                            data: rounds.map(r => predictExpectedPoints(r)),
                            type: 'line',
                            borderColor: 'rgba(220, 53, 69, 0.9)',
                            borderWidth: 2,
                            pointRadius: 0,
                            fill: false,
                            tension: 0.4,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            position: 'top',
                            labels: {
                                boxWidth: 12,
                                padding: 8,
                                font: { size: 10 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const round = context.dataIndex + 1;
                                    if (context.dataset.label === 'Model Prediction') {
                                        return `Model: ${context.raw} pts`;
                                    }
                                    const stats = expectedPointsByRound[round];
                                    return [
                                        `Actual: ${stats?.avg || 0} pts`,
                                        `Sample: ${stats?.sampleSize || 0} picks`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Points',
                                font: { size: 10 }
                            },
                            ticks: { font: { size: 9 } }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Round',
                                font: { size: 10 }
                            },
                            ticks: { font: { size: 9 } }
                        }
                    }
                }
            });
        }

        function renderValueRankings(teamValues) {
            const tbody = document.getElementById('value-rankings-body');
            if (!tbody) return;
            
            // Build a headshot lookup from projections data
            const headshotLookup = {};
            [...allProjectionBatters, ...allProjectionPitchers].forEach(p => {
                if (p.name && p.headshot_url) {
                    const nameLower = p.name.toLowerCase().trim();
                    headshotLookup[nameLower] = p.headshot_url;
                    // Also store without (Batter)/(Pitcher) suffix
                    const baseName = nameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                    if (baseName !== nameLower) {
                        headshotLookup[baseName] = p.headshot_url;
                    }
                }
            });
            
            const placeholderImg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            tbody.innerHTML = teamValues.map((team, idx) => {
                const keeperValueClass = team.totalValue > 0 ? 'value-positive' : 
                                  team.totalValue < 0 ? 'value-negative' : 'value-neutral';
                const keeperValuePrefix = team.totalValue > 0 ? '+' : '';
                
                // Get top 3 best value players on this team
                const topPlayers = [...team.keepers]
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 3);
                
                const topPlayersHtml = topPlayers.map(player => {
                    const playerNameLower = player.player_name.toLowerCase().trim();
                    const baseNameLower = playerNameLower.replace(/\s*\(batter\)|\s*\(pitcher\)/gi, '').trim();
                    const headshot = headshotLookup[playerNameLower] || headshotLookup[baseNameLower] || placeholderImg;
                    const playerValueClass = player.value > 0 ? 'value-positive' : player.value < 0 ? 'value-negative' : 'value-neutral';
                    const playerValuePrefix = player.value > 0 ? '+' : '';
                    const displayName = player.player_name.replace(/\s*\(Batter\)|\s*\(Pitcher\)/gi, '');
                    
                    return `
                        <div class="best-player-cell">
                            <img src="${headshot}" class="player-headshot-mini" alt="" onerror="this.src='${placeholderImg}'">
                            <div class="player-info">
                                <span class="player-name">${displayName}</span>
                                <span class="player-details">${getPositionBadge(player.position, player.player_name)} Rd ${player.roundCost}</span>
                            </div>
                            <span class="player-value ${playerValueClass}">${playerValuePrefix}${Math.round(player.value)}</span>
                        </div>
                    `;
                }).join('');
                
                // Get team's available picks and calculate which ones are NOT used for keepers
                const teamPicks = getTeamPicks(team.team_key) || [];
                const teamKeepers = keeperSelections[team.team_key] || [];
                const nonProspectKeepers = teamKeepers.filter(k => !k.isProspect);
                
                // Calculate which rounds are used by keepers
                const usedRounds = {};
                const roundCosts = calculateTeamKeeperRoundCosts(team.team_key);
                roundCosts.forEach(rc => {
                    usedRounds[rc.actualRoundCost] = (usedRounds[rc.actualRoundCost] || 0) + 1;
                });
                
                // Count available picks at each round
                const pickCounts = {};
                teamPicks.forEach(pick => {
                    pickCounts[pick.round] = (pickCounts[pick.round] || 0) + 1;
                });
                
                // Find unused picks (available picks minus keeper-used picks)
                const unusedPicks = [];
                Object.keys(pickCounts).forEach(round => {
                    const roundNum = parseInt(round);
                    const available = pickCounts[roundNum] || 0;
                    const used = usedRounds[roundNum] || 0;
                    const unused = available - used;
                    for (let i = 0; i < unused; i++) {
                        unusedPicks.push({
                            round: roundNum,
                            expectedPts: expectedPointsByRound[roundNum]?.avg || 0
                        });
                    }
                });
                
                // Sort by expected points (highest value first) and take top 3
                unusedPicks.sort((a, b) => b.expectedPts - a.expectedPts);
                const topPicks = unusedPicks.slice(0, 3);
                
                // Calculate total pick value for team total
                const totalPickValue = unusedPicks.reduce((sum, p) => sum + p.expectedPts, 0);
                const draftValueClass = totalPickValue > 0 ? 'value-positive' : 'value-neutral';
                
                const combinedTotal = team.totalValue + totalPickValue;
                const combinedValueClass = combinedTotal > 0 ? 'value-positive' : 
                                          combinedTotal < 0 ? 'value-negative' : 'value-neutral';
                const combinedValuePrefix = combinedTotal > 0 ? '+' : '';
                
                const topPicksHtml = topPicks.length > 0 ? topPicks.map(pick => `
                    <div class="pick-value-item">
                        <div class="pick-circle">${pick.round}</div>
                        <span class="pick-expected">${Math.round(pick.expectedPts)}</span>
                    </div>
                `).join('') : '<span style="color:#999;font-size:0.7rem;">—</span>';

                return `
                    <tr data-keeper-value="${team.totalValue}" data-draft-value="${totalPickValue}" data-total="${combinedTotal}">
                        <td>
                            <div class="team-cell">
                                ${team.team_logo ? `<img src="${team.team_logo}" class="team-logo-small" alt="">` : ''}
                                <div>
                                    <div style="font-weight: 500;">${team.team_name}</div>
                                    <div style="font-size: 0.7rem; color: #666;">${team.manager}</div>
                                </div>
                            </div>
                        </td>
                        <td><div class="top-players-cell">${topPlayersHtml}</div></td>
                        <td class="value-cell ${keeperValueClass}">${keeperValuePrefix}${Math.round(team.totalValue)}</td>
                        <td><div class="top-picks-cell">${topPicksHtml}</div></td>
                        <td class="value-cell ${draftValueClass}">+${Math.round(totalPickValue)}</td>
                        <td class="value-cell ${combinedValueClass}">${combinedValuePrefix}${Math.round(combinedTotal)}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Sorting state for value rankings
        let valueRankingsSortColumn = 'total';
        let valueRankingsSortDirection = 'desc';
        
        function sortValueRankings(column) {
            const table = document.getElementById('value-rankings-table');
            const tbody = document.getElementById('value-rankings-body');
            if (!table || !tbody) return;
            
            // Toggle direction if same column, otherwise default to desc
            if (valueRankingsSortColumn === column) {
                valueRankingsSortDirection = valueRankingsSortDirection === 'desc' ? 'asc' : 'desc';
            } else {
                valueRankingsSortColumn = column;
                valueRankingsSortDirection = 'desc';
            }
            
            // Update header icons
            table.querySelectorAll('.sortable-header').forEach(th => {
                const icon = th.querySelector('.sort-icon');
                if (th.dataset.sort === column) {
                    th.classList.add('active');
                    icon.textContent = valueRankingsSortDirection === 'desc' ? '▼' : '▲';
                } else {
                    th.classList.remove('active');
                    icon.textContent = '';
                }
            });
            
            // Get rows and sort
            const rows = Array.from(tbody.querySelectorAll('tr'));
            
            const dataAttr = column === 'keeperValue' ? 'keeper-value' : 
                            column === 'draftValue' ? 'draft-value' : 'total';
            
            rows.sort((a, b) => {
                const aVal = parseFloat(a.dataset[dataAttr.replace(/-([a-z])/g, (g) => g[1].toUpperCase())]) || 0;
                const bVal = parseFloat(b.dataset[dataAttr.replace(/-([a-z])/g, (g) => g[1].toUpperCase())]) || 0;
                return valueRankingsSortDirection === 'desc' ? bVal - aVal : aVal - bVal;
            });
            
            // Re-render with new rank numbers
            rows.forEach((row, idx) => {
                row.querySelector('.rank-cell').textContent = idx + 1;
                tbody.appendChild(row);
            });
        }

        function renderTeamValueCards(teamValues) {
            const container = document.getElementById('team-value-grid');
            if (!container) return;

            container.innerHTML = teamValues.map(team => {
                const valueClass = team.totalValue > 0 ? 'positive' : team.totalValue < 0 ? 'negative' : '';
                const valuePrefix = team.totalValue > 0 ? '+' : '';

                const keepersHtml = team.keepers.map(k => {
                    const kValueClass = k.value > 0 ? 'value-positive' : k.value < 0 ? 'value-negative' : 'value-neutral';
                    const kValuePrefix = k.value > 0 ? '+' : '';
                    
                    return `
                        <tr>
                            <td>
                                <div class="player-cell">
                                    ${getPositionBadge(k.position, k.player_name)}
                                    <span>${k.player_name}</span>
                                </div>
                            </td>
                            <td>Rd ${k.roundCost}</td>
                            <td>${Math.round(k.projectedPts)}</td>
                            <td>${Math.round(k.expectedPts)}</td>
                            <td class="${kValueClass}">${kValuePrefix}${Math.round(k.value)}</td>
                        </tr>
                    `;
                }).join('');

                return `
                    <div class="team-value-card">
                        <div class="team-value-card-header">
                            <div class="team-info">
                                ${team.team_logo ? `<img src="${team.team_logo}" class="team-logo" alt="">` : ''}
                                <div>
                                    <div class="team-name">${team.team_name}</div>
                                    <div class="team-manager">${team.manager}</div>
                                </div>
                            </div>
                            <div class="total-value ${valueClass}">${valuePrefix}${Math.round(team.totalValue)}</div>
                        </div>
                        <div class="team-value-card-body">
                            <table class="team-value-table">
                                <thead>
                                    <tr>
                                        <th>Player</th>
                                        <th>Cost</th>
                                        <th>Proj</th>
                                        <th>Exp</th>
                                        <th>Value</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${keepersHtml}
                                </tbody>
                            </table>
                        </div>
                        <div class="team-value-card-footer">
                            <div>
                                <span class="label">Total Projected:</span>
                                <span class="value">${Math.round(team.totalProjected)} pts</span>
                            </div>
                            <div>
                                <span class="label">Expected:</span>
                                <span class="value">${Math.round(team.totalExpected)} pts</span>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderProspectsSection(prospects) {
            const section = document.getElementById('prospects-value-section');
            const grid = document.getElementById('prospects-value-grid');
            if (!section || !grid) return;

            // Filter out prospects with 0 projected points
            const displayProspects = prospects.filter(p => p.projectedPts > 0);

            if (displayProspects.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            grid.innerHTML = displayProspects.map(p => `
                <div class="prospect-value-item">
                    <div class="prospect-info">
                        ${p.team_logo ? `<img src="${p.team_logo}" class="prospect-team-logo" alt="">` : ''}
                        <span>${p.player_name}</span>
                    </div>
                    <span class="prospect-pts">+${Math.round(p.projectedPts)}</span>
                </div>
            `).join('');
        }

        function renderValueScatterChart(keepers, prospects) {
            const ctx = document.getElementById('value-scatter-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (valueScatterChart) {
                valueScatterChart.destroy();
            }

            // Prepare data points for regular keepers
            const keeperPoints = keepers.map(k => ({
                x: k.roundCost,
                y: k.projectedPts,
                player: k.player_name,
                team: k.team_name,
                value: k.value,
                expected: k.expectedPts
            }));

            // Prepare data points for prospects (x = 24 to put them after round 23)
            // Only include prospects with projected points > 0
            const prospectPoints = prospects.filter(p => p.projectedPts > 0).map(p => ({
                x: 24,
                y: p.projectedPts,
                player: p.player_name,
                team: p.team_name,
                value: p.projectedPts,
                expected: 0
            }));

            // Expected value line data
            const expectedLine = [];
            for (let r = 1; r <= 23; r++) {
                expectedLine.push({
                    x: r,
                    y: expectedPointsByRound[r]?.avg || 0
                });
            }

            valueScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Above Expected',
                            data: keeperPoints.filter(p => p.value > 0),
                            backgroundColor: 'rgba(40, 167, 69, 0.7)',
                            borderColor: 'rgba(40, 167, 69, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                        },
                        {
                            label: 'Below Expected',
                            data: keeperPoints.filter(p => p.value <= 0),
                            backgroundColor: 'rgba(220, 53, 69, 0.7)',
                            borderColor: 'rgba(220, 53, 69, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                        },
                        {
                            label: 'Prospects (Free)',
                            data: prospectPoints,
                            backgroundColor: 'rgba(23, 162, 184, 0.7)',
                            borderColor: 'rgba(23, 162, 184, 1)',
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointStyle: 'triangle',
                        },
                        {
                            label: 'Expected Value',
                            data: expectedLine,
                            type: 'line',
                            borderColor: 'rgba(30, 60, 114, 0.5)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    if (!point.player) return `Expected: ${point.y} pts`;
                                    const valuePrefix = point.value > 0 ? '+' : '';
                                    return [
                                        `${point.player}`,
                                        `Team: ${point.team}`,
                                        `Projected: ${Math.round(point.y)} pts`,
                                        `Expected: ${Math.round(point.expected)} pts`,
                                        `Value: ${valuePrefix}${Math.round(point.value)}`
                                    ];
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Keeper Cost (Round)'
                            },
                            min: 0.5,
                            max: 25,
                            ticks: {
                                callback: function(value) {
                                    if (value === 24) return 'Free';
                                    if (value % 2 === 0 || value === 1) return value;
                                    return '';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Projected Points'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Initialize keeper value analysis when keepers are displayed
        function initializeKeeperValueAnalysis() {
            // Always run the analysis - it will show expected points chart
            // even if no keeper selections exist yet
            analyzeKeeperValues();
        }

        // ===== TRADE MANAGEMENT =====

        let tradeData = {
            trades: []
        };
        let currentTrade = {
            teamA: null,
            teamB: null,
            assetsA: [], // Assets Team A gives up
            assetsB: []  // Assets Team B gives up
        };
        let teamRosters = {}; // Cache of team rosters
        let teamPicksOwned = {}; // Track which picks each team owns
        let teamBudgets = {}; // Track each team's budget
        let tradesLoadedFromServer = false; // Track if we loaded from server

        async function initializeTradeManagement() {
            // Load manual budget adjustments (now async to check server first)
            await loadManualBudgetAdjustments();

            // First, try to load trades from the server JSON file
            try {
                const response = await fetch('data/keepers/trades_2026.json');
                if (response.ok) {
                    const serverTrades = await response.json();
                    tradeData = serverTrades;
                    tradesLoadedFromServer = true;
                    console.log(`Loaded ${tradeData.trades?.length || 0} trades from server`);
                }
            } catch (e) {
                console.log('No server trades file found, checking localStorage');
            }

            // If no server trades, check localStorage for commissioner's working copy
            if (!tradesLoadedFromServer || !tradeData.trades || tradeData.trades.length === 0) {
                const storedTrades = localStorage.getItem('keeper_trades_2026');
                if (storedTrades) {
                    const localTrades = JSON.parse(storedTrades);
                    // Merge: keep server trades and add any new local trades
                    if (localTrades.trades && localTrades.trades.length > 0) {
                        const serverIds = new Set((tradeData.trades || []).map(t => t.id));
                        const newLocalTrades = localTrades.trades.filter(t => !serverIds.has(t.id));
                        tradeData.trades = [...(tradeData.trades || []), ...newLocalTrades];
                    }
                }
            }

            // Ensure trades array exists
            if (!tradeData.trades) {
                tradeData.trades = [];
            }

            // Initialize team budgets and picks
            await initializeTeamAssets();

            // Display existing trades
            displayTrades();
        }

        async function initializeTeamAssets() {
            const totalRounds = getTotalDraftRounds();

            // Initialize each team with default budget and all their picks
            if (keeperConfig && keeperConfig.teams) {
                for (const teamKey of Object.keys(keeperConfig.teams)) {
                    // Default budget
                    teamBudgets[teamKey] = KEEPER_BUDGET;

                    // Default picks (team owns all their own picks)
                    teamPicksOwned[teamKey] = [];
                    for (let round = 1; round <= totalRounds; round++) {
                        teamPicksOwned[teamKey].push({
                            round: round,
                            originalOwner: teamKey
                        });
                    }
                }
            }

            // Apply trades to adjust budgets and picks
            applyTradesToAssets();
        }

        function applyTradesToAssets() {
            // Reset to defaults first
            const totalRounds = getTotalDraftRounds();

            if (keeperConfig && keeperConfig.teams) {
                for (const teamKey of Object.keys(keeperConfig.teams)) {
                    teamBudgets[teamKey] = KEEPER_BUDGET;
                    teamPicksOwned[teamKey] = [];
                    for (let round = 1; round <= totalRounds; round++) {
                        teamPicksOwned[teamKey].push({
                            round: round,
                            originalOwner: teamKey
                        });
                    }
                }
            }

            // Apply each trade
            tradeData.trades.forEach(trade => {
                // Process assets Team A gave to Team B
                trade.assetsA.forEach(asset => {
                    if (asset.type === 'money') {
                        teamBudgets[trade.teamA] -= asset.amount;
                        teamBudgets[trade.teamB] += asset.amount;
                    } else if (asset.type === 'pick') {
                        // Remove pick from Team A
                        const pickIndex = teamPicksOwned[trade.teamA].findIndex(p =>
                            p.round === asset.round && p.originalOwner === asset.originalOwner
                        );
                        if (pickIndex !== -1) {
                            const pick = teamPicksOwned[trade.teamA].splice(pickIndex, 1)[0];
                            teamPicksOwned[trade.teamB].push(pick);
                        }
                    }
                });

                // Process assets Team B gave to Team A
                trade.assetsB.forEach(asset => {
                    if (asset.type === 'money') {
                        teamBudgets[trade.teamB] -= asset.amount;
                        teamBudgets[trade.teamA] += asset.amount;
                    } else if (asset.type === 'pick') {
                        // Remove pick from Team B
                        const pickIndex = teamPicksOwned[trade.teamB].findIndex(p =>
                            p.round === asset.round && p.originalOwner === asset.originalOwner
                        );
                        if (pickIndex !== -1) {
                            const pick = teamPicksOwned[trade.teamB].splice(pickIndex, 1)[0];
                            teamPicksOwned[trade.teamA].push(pick);
                        }
                    }
                });
            });

            // Sort picks by round for each team
            for (const teamKey of Object.keys(teamPicksOwned)) {
                teamPicksOwned[teamKey].sort((a, b) => a.round - b.round);
            }
        }

        function getTeamBudget(teamKey) {
            // Base budget from trades
            const tradeBudget = teamBudgets[teamKey] || KEEPER_BUDGET;
            // Add manual adjustments
            const manualAdjustment = manualBudgetAdjustments[teamKey] || 0;
            return tradeBudget + manualAdjustment;
        }

        function getTeamPicks(teamKey) {
            return teamPicksOwned[teamKey] || [];
        }

        function displayTrades() {
            const container = document.getElementById('trades-list');
            const noTradesMsg = document.getElementById('no-trades-msg');

            if (!tradeData.trades || tradeData.trades.length === 0) {
                container.innerHTML = '<p class="no-trades" id="no-trades-msg">No trades recorded yet. Click "New Trade" to add one.</p>';
                return;
            }

            let html = '';
            tradeData.trades.forEach((trade, index) => {
                const teamAInfo = keeperConfig?.teams[trade.teamA] || { team_name: 'Unknown', manager: '' };
                const teamBInfo = keeperConfig?.teams[trade.teamB] || { team_name: 'Unknown', manager: '' };
                const tradeDate = new Date(trade.timestamp).toLocaleDateString();

                html += `
                    <div class="trade-card">
                        <div class="trade-card-header">
                            <span class="trade-card-date">📅 ${tradeDate}</span>
                            <div class="trade-card-actions">
                                <button onclick="deleteTrade(${index})" title="Delete trade">🗑️</button>
                            </div>
                        </div>
                        <div class="trade-card-body">
                            <div class="trade-card-side">
                                <div class="trade-card-team">
                                    ${teamAInfo.team_logo ? `<img src="${teamAInfo.team_logo}" alt="">` : ''}
                                    ${teamAInfo.team_name}
                                </div>
                                <div class="trade-card-assets">
                                    ${formatTradeAssets(trade.assetsA)}
                                </div>
                            </div>
                            <div class="trade-card-arrow">⇄</div>
                            <div class="trade-card-side">
                                <div class="trade-card-team">
                                    ${teamBInfo.team_logo ? `<img src="${teamBInfo.team_logo}" alt="">` : ''}
                                    ${teamBInfo.team_name}
                                </div>
                                <div class="trade-card-assets">
                                    ${formatTradeAssets(trade.assetsB)}
                                </div>
                            </div>
                        </div>
                        ${trade.notes ? `<div class="trade-card-notes">📝 ${trade.notes}</div>` : ''}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function formatTradeAssets(assets) {
            if (!assets || assets.length === 0) {
                return '<span style="color: #888; font-style: italic;">Nothing</span>';
            }

            return assets.map(asset => {
                if (asset.type === 'player') {
                    return `<span class="trade-asset-tag player">👤 ${asset.name}</span>`;
                } else if (asset.type === 'pick') {
                    const originalOwner = keeperConfig?.teams[asset.originalOwner]?.team_name || 'Unknown';
                    const pickLabel = asset.originalOwner !== asset.fromTeam
                        ? `Round ${asset.round} (${originalOwner}'s pick)`
                        : `Round ${asset.round}`;
                    return `<span class="trade-asset-tag pick">📋 ${pickLabel}</span>`;
                } else if (asset.type === 'money') {
                    return `<span class="trade-asset-tag money">💵 $${asset.amount}</span>`;
                }
                return '';
            }).join('');
        }

        function openTradeBuilder() {
            // Reset current trade
            currentTrade = {
                teamA: null,
                teamB: null,
                assetsA: [],
                assetsB: []
            };

            // Populate team dropdowns
            populateTradeTeamSelects();

            // Reset UI
            document.getElementById('trade-team-a').value = '';
            document.getElementById('trade-team-b').value = '';
            document.getElementById('trade-team-a-info').style.display = 'none';
            document.getElementById('trade-team-b-info').style.display = 'none';
            document.getElementById('trade-add-asset-a').style.display = 'none';
            document.getElementById('trade-add-asset-b').style.display = 'none';
            document.getElementById('trade-assets-a').innerHTML = '';
            document.getElementById('trade-assets-b').innerHTML = '';
            document.getElementById('trade-notes').value = '';
            document.getElementById('trade-submit-btn').disabled = true;

            // Show modal
            document.getElementById('trade-modal').classList.add('active');
        }

        function closeTradeModal() {
            document.getElementById('trade-modal').classList.remove('active');
        }

        function populateTradeTeamSelects() {
            const selectA = document.getElementById('trade-team-a');
            const selectB = document.getElementById('trade-team-b');

            let options = '<option value="">-- Select Team --</option>';

            if (keeperConfig && keeperConfig.teams) {
                const sortedTeams = Object.entries(keeperConfig.teams)
                    .sort((a, b) => a[1].manager.localeCompare(b[1].manager));

                sortedTeams.forEach(([teamKey, teamInfo]) => {
                    options += `<option value="${teamKey}">${teamInfo.team_name} (${teamInfo.manager})</option>`;
                });
            }

            selectA.innerHTML = options;
            selectB.innerHTML = options;
        }

        async function onTradeTeamSelect(side) {
            const teamKey = document.getElementById(`trade-team-${side}`).value;
            const infoEl = document.getElementById(`trade-team-${side}-info`);
            const addAssetEl = document.getElementById(`trade-add-asset-${side}`);
            const assetsEl = document.getElementById(`trade-assets-${side}`);

            if (!teamKey) {
                infoEl.style.display = 'none';
                addAssetEl.style.display = 'none';
                currentTrade[side === 'a' ? 'teamA' : 'teamB'] = null;
                return;
            }

            // Update current trade
            currentTrade[side === 'a' ? 'teamA' : 'teamB'] = teamKey;

            // Load team roster if not cached
            if (!teamRosters[teamKey]) {
                try {
                    const response = await fetch('data/current_season/player_stats.json');
                    if (response.ok) {
                        const allPlayers = await response.json();
                        teamRosters[teamKey] = allPlayers.filter(p => p.team_key === teamKey);
                    }
                } catch (e) {
                    console.log('Could not load roster');
                }
            }

            // Update budget display
            const budget = getTeamBudget(teamKey);
            document.getElementById(`trade-budget-${side}`).textContent = `$${budget}`;

            infoEl.style.display = 'block';
            addAssetEl.style.display = 'block';

            // Reset asset type selector
            document.getElementById(`trade-asset-type-${side}`).value = '';
            document.getElementById(`trade-asset-selector-${side}`).style.display = 'none';

            // Clear assets when team changes
            assetsEl.innerHTML = '';
            currentTrade[side === 'a' ? 'assetsA' : 'assetsB'] = [];

            updateTradeSubmitButton();
        }

        function onAssetTypeChange(side) {
            const assetType = document.getElementById(`trade-asset-type-${side}`).value;
            const selectorEl = document.getElementById(`trade-asset-selector-${side}`);
            const teamKey = currentTrade[side === 'a' ? 'teamA' : 'teamB'];

            if (!assetType || !teamKey) {
                selectorEl.style.display = 'none';
                return;
            }

            let selectorHtml = '';

            if (assetType === 'player') {
                const roster = teamRosters[teamKey] || [];
                selectorHtml = `
                    <select id="trade-player-select-${side}">
                        <option value="">-- Select Player --</option>
                        ${roster.map(p => `<option value="${p.name}">${p.name} (${p.primary_position})</option>`).join('')}
                    </select>
                    <button onclick="addTradeAsset('${side}', 'player')">Add</button>
                `;
            } else if (assetType === 'pick') {
                const picks = getTeamPicks(teamKey);
                selectorHtml = `
                    <select id="trade-pick-select-${side}">
                        <option value="">-- Select Pick --</option>
                        ${picks.map(p => {
                    const originalOwner = keeperConfig?.teams[p.originalOwner]?.team_name || 'Unknown';
                    const label = p.originalOwner !== teamKey
                        ? `Round ${p.round} (${originalOwner}'s pick)`
                        : `Round ${p.round}`;
                    return `<option value="${p.round}-${p.originalOwner}">${label}</option>`;
                }).join('')}
                    </select>
                    <button onclick="addTradeAsset('${side}', 'pick')">Add</button>
                `;
            } else if (assetType === 'money') {
                const budget = getTeamBudget(teamKey);
                selectorHtml = `
                    <input type="number" id="trade-money-input-${side}" min="1" max="${budget}" value="1" placeholder="$">
                    <span>/ $${budget}</span>
                    <button onclick="addTradeAsset('${side}', 'money')">Add</button>
                `;
            }

            selectorEl.innerHTML = selectorHtml;
            selectorEl.style.display = 'flex';
        }

        function addTradeAsset(side, type) {
            const teamKey = currentTrade[side === 'a' ? 'teamA' : 'teamB'];
            const assetsKey = side === 'a' ? 'assetsA' : 'assetsB';
            const assetsEl = document.getElementById(`trade-assets-${side}`);

            let asset = null;

            if (type === 'player') {
                const playerName = document.getElementById(`trade-player-select-${side}`).value;
                if (!playerName) return;

                // Check if already added
                if (currentTrade[assetsKey].some(a => a.type === 'player' && a.name === playerName)) {
                    alert('This player is already in the trade.');
                    return;
                }

                asset = { type: 'player', name: playerName };
            } else if (type === 'pick') {
                const pickValue = document.getElementById(`trade-pick-select-${side}`).value;
                if (!pickValue) return;

                const [round, originalOwner] = pickValue.split('-');

                // Check if already added
                if (currentTrade[assetsKey].some(a => a.type === 'pick' && a.round === parseInt(round) && a.originalOwner === originalOwner)) {
                    alert('This pick is already in the trade.');
                    return;
                }

                asset = { type: 'pick', round: parseInt(round), originalOwner: originalOwner, fromTeam: teamKey };
            } else if (type === 'money') {
                const amount = parseInt(document.getElementById(`trade-money-input-${side}`).value);
                if (!amount || amount < 1) return;

                // Check total money in trade doesn't exceed budget
                const currentMoney = currentTrade[assetsKey]
                    .filter(a => a.type === 'money')
                    .reduce((sum, a) => sum + a.amount, 0);
                const budget = getTeamBudget(teamKey);

                if (currentMoney + amount > budget) {
                    alert(`Cannot add $${amount}. Team only has $${budget - currentMoney} available.`);
                    return;
                }

                asset = { type: 'money', amount: amount };
            }

            if (asset) {
                currentTrade[assetsKey].push(asset);
                renderTradeAssets(side);

                // Reset selector
                document.getElementById(`trade-asset-type-${side}`).value = '';
                document.getElementById(`trade-asset-selector-${side}`).style.display = 'none';

                updateTradeSubmitButton();
            }
        }

        function removeTradeAsset(side, index) {
            const assetsKey = side === 'a' ? 'assetsA' : 'assetsB';
            currentTrade[assetsKey].splice(index, 1);
            renderTradeAssets(side);
            updateTradeSubmitButton();
        }

        function renderTradeAssets(side) {
            const assetsKey = side === 'a' ? 'assetsA' : 'assetsB';
            const assetsEl = document.getElementById(`trade-assets-${side}`);
            const teamKey = currentTrade[side === 'a' ? 'teamA' : 'teamB'];

            if (currentTrade[assetsKey].length === 0) {
                assetsEl.innerHTML = '<div style="color: #888; font-style: italic; padding: 1rem; text-align: center;">No assets added yet</div>';
                return;
            }

            assetsEl.innerHTML = currentTrade[assetsKey].map((asset, index) => {
                let icon, label;

                if (asset.type === 'player') {
                    icon = '👤';
                    label = asset.name;
                } else if (asset.type === 'pick') {
                    icon = '📋';
                    const originalOwner = keeperConfig?.teams[asset.originalOwner]?.team_name || 'Unknown';
                    label = asset.originalOwner !== teamKey
                        ? `Round ${asset.round} (${originalOwner}'s pick)`
                        : `Round ${asset.round}`;
                } else if (asset.type === 'money') {
                    icon = '💵';
                    label = `$${asset.amount}`;
                }

                return `
                    <div class="trade-asset-item">
                        <div class="asset-info">
                            <span class="asset-type-icon ${asset.type}">${icon}</span>
                            <span>${label}</span>
                        </div>
                        <button class="remove-asset" onclick="removeTradeAsset('${side}', ${index})">✕</button>
                    </div>
                `;
            }).join('');
        }

        function updateTradeSubmitButton() {
            const submitBtn = document.getElementById('trade-submit-btn');

            // Need both teams selected and at least one asset on either side
            const hasTeams = currentTrade.teamA && currentTrade.teamB && currentTrade.teamA !== currentTrade.teamB;
            const hasAssets = currentTrade.assetsA.length > 0 || currentTrade.assetsB.length > 0;

            submitBtn.disabled = !(hasTeams && hasAssets);
        }

        function submitTrade() {
            if (!currentTrade.teamA || !currentTrade.teamB) {
                alert('Please select both teams.');
                return;
            }

            if (currentTrade.teamA === currentTrade.teamB) {
                alert('Cannot trade with the same team.');
                return;
            }

            if (currentTrade.assetsA.length === 0 && currentTrade.assetsB.length === 0) {
                alert('Please add at least one asset to the trade.');
                return;
            }

            const teamAInfo = keeperConfig?.teams[currentTrade.teamA];
            const teamBInfo = keeperConfig?.teams[currentTrade.teamB];

            // Build confirmation message
            let confirmMsg = `Confirm this trade?\n\n`;
            confirmMsg += `${teamAInfo?.team_name || 'Team A'} sends:\n`;
            currentTrade.assetsA.forEach(a => {
                if (a.type === 'player') confirmMsg += `  • ${a.name}\n`;
                else if (a.type === 'pick') confirmMsg += `  • Round ${a.round} pick\n`;
                else if (a.type === 'money') confirmMsg += `  • $${a.amount}\n`;
            });
            if (currentTrade.assetsA.length === 0) confirmMsg += `  • (nothing)\n`;

            confirmMsg += `\n${teamBInfo?.team_name || 'Team B'} sends:\n`;
            currentTrade.assetsB.forEach(a => {
                if (a.type === 'player') confirmMsg += `  • ${a.name}\n`;
                else if (a.type === 'pick') confirmMsg += `  • Round ${a.round} pick\n`;
                else if (a.type === 'money') confirmMsg += `  • $${a.amount}\n`;
            });
            if (currentTrade.assetsB.length === 0) confirmMsg += `  • (nothing)\n`;

            if (!confirm(confirmMsg)) return;

            // Create trade record
            const trade = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                teamA: currentTrade.teamA,
                teamB: currentTrade.teamB,
                assetsA: [...currentTrade.assetsA],
                assetsB: [...currentTrade.assetsB],
                notes: document.getElementById('trade-notes').value.trim()
            };

            // Add to trades
            tradeData.trades.push(trade);

            // Save to localStorage
            localStorage.setItem('keeper_trades_2026', JSON.stringify(tradeData));

            // Reapply trades to update budgets/picks
            applyTradesToAssets();

            // Update displays
            displayTrades();
            displayLeagueKeepers(); // Refresh keeper display with new budgets

            // Close modal
            closeTradeModal();

            alert('Trade recorded successfully!');
        }

        function deleteTrade(index) {
            if (!confirm('Are you sure you want to delete this trade?')) return;

            tradeData.trades.splice(index, 1);
            localStorage.setItem('keeper_trades_2026', JSON.stringify(tradeData));

            // Reapply remaining trades
            applyTradesToAssets();

            // Update displays
            displayTrades();
            displayLeagueKeepers();
        }

        // Close trade modal on outside click
        document.getElementById('trade-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeTradeModal();
            }
        });

        // ===== TRADE EXPORT FUNCTIONS =====

        function exportTradesForSite() {
            // Generate clean JSON for the trades file
            const exportData = {
                _comment: "Fantasy Baseball Civil War - Keeper Trades for 2026 Season",
                _updated: new Date().toISOString(),
                trades: tradeData.trades.map(trade => ({
                    id: trade.id,
                    timestamp: trade.timestamp,
                    teamA: trade.teamA,
                    teamB: trade.teamB,
                    assetsA: trade.assetsA,
                    assetsB: trade.assetsB,
                    notes: trade.notes || ""
                }))
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            document.getElementById('export-json-content').value = jsonString;
            document.getElementById('export-trades-modal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('export-trades-modal').classList.remove('active');
        }

        function copyExportJson() {
            const textarea = document.getElementById('export-json-content');
            textarea.select();
            document.execCommand('copy');

            // Show feedback
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '✓ Copied!';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadExportJson() {
            const jsonContent = document.getElementById('export-json-content').value;
            const blob = new Blob([jsonContent], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'trades_2026.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Close export modal on outside click
        document.getElementById('export-trades-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeExportModal();
            }
        });

        // ===== PROJECTION PLAYER DETAIL MODAL =====

        async function showProjectionPlayerDetail(playerName) {
            const modal = document.getElementById('projection-modal');
            const cardContainer = document.getElementById('projection-card-container');
            const posChartEl = document.getElementById('projection-pos-chart');
            const scatterChartEl = document.getElementById('projection-scatter-chart');
            const scatterTitleEl = document.getElementById('projection-scatter-title');

            // Find player in projection data
            const allPlayers = [...allProjectionBatters, ...allProjectionPitchers];
            const player = allPlayers.find(p => p.name === playerName);
            if (!player) return;

            const isBatter = player.type === 'batter';
            const stats = player.stats || {};

            // Placeholders
            const placeholderHeadshot = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2UwZTBlMCIvPjxjaXJjbGUgY3g9IjUwIiBjeT0iMzUiIHI9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PGVsbGlwc2UgY3g9IjUwIiBjeT0iODUiIHJ4PSIzMCIgcnk9IjIwIiBmaWxsPSIjYmRiZGJkIi8+PC9zdmc+';

            const headshot = player.headshot_url || placeholderHeadshot;
            const mlbLogoUrl = getMLBTeamLogo(player.team || '');
            const mlbTeamText = formatMLBTeamDisplay(player.team || '');
            const mlbLogoHtml = mlbLogoUrl
                ? `<img src="${mlbLogoUrl}" alt="" class="card-mlb-logo" onerror="this.outerHTML='<div class=\\'card-mlb-fa\\'>FA</div>'">`
                : `<div class="card-mlb-fa">FA</div>`;

            const projPoints = (player.projected_points || 0).toFixed(1);
            const positionDisplay = formatProjectionPosition(player.position, player.name);
            const positionRank = getProjectionPositionRank(player);
            const primaryPos = positionDisplay.split(',')[0].trim() || (isBatter ? 'B' : 'P');

            // Check if player is kept
            const keeperInfo = getPlayerKeeperInfo(player.name);
            let keeperLogoHtml = '';
            if (keeperInfo && keeperConfig?.teams[keeperInfo.teamKey]) {
                const keeperTeam = keeperConfig.teams[keeperInfo.teamKey];
                if (keeperTeam.team_logo) {
                    keeperLogoHtml = `
                        <div class="card-keeper-logo-wrapper">
                            <img src="${keeperTeam.team_logo}" alt="" class="card-team-logo-corner" onerror="this.style.display='none'">
                            <div class="card-keeper-badge">K</div>
                        </div>`;
                }
            }

            // Load player history data
            if (Object.keys(playerHistoryData).length === 0) {
                try {
                    const historyResponse = await fetch('data/players/player_history.json');
                    if (historyResponse.ok) {
                        playerHistoryData = await historyResponse.json();
                    }
                } catch (e) {
                    console.log('Could not load player history');
                }
            }

            // Build baseball card HTML
            let cardHTML = `
            <div class="baseball-card">
                <div class="card-header">
                    ${mlbLogoHtml}
                    <div class="card-player-name">${player.name}</div>
                </div>
                
                <div class="card-photo-section">
                    ${keeperLogoHtml}
                    <div class="card-stats-corner">
                        <div class="card-team-badge">${mlbTeamText}</div>
                        <div class="card-fantasy-points">
                            ${projPoints}
                            <span class="pts-label">PROJ</span>
                        </div>
                        <div class="card-position-rank">${positionRank}</div>
                    </div>
                    <div class="card-photo-frame">
                        <img src="${headshot}" alt="${player.name}" class="card-headshot" onerror="this.src='${placeholderHeadshot}'">
                        <div class="card-position-badge">${primaryPos}</div>
                    </div>
                </div>

                <div class="card-info-strip">
                    <span>📊 2026 Projections</span>
                    <span>${positionDisplay}</span>
                    <span>⚾ ${isBatter ? 'Batter' : 'Pitcher'}</span>
                </div>

                <div class="card-scrollable">
                    <div class="card-stats-section">
                        <div class="card-stats-header">
                            <div class="card-stats-title">2026 Projected Statistics</div>
                        </div>
                        <div id="projection-modal-stats-content">`;

            if (isBatter) {
                const singles = (stats['1B'] || 0);
                cardHTML += `
                        <table class="card-stats-table">
                            <tr>
                                <th>G</th><th>PA</th><th>H</th><th>HR</th><th>RBI</th><th>R</th><th>SB</th>
                            </tr>
                            <tr>
                                <td>${player.games || 0}</td>
                                <td>${stats.PA || 0}</td>
                                <td>${stats.H || 0}</td>
                                <td>${stats.HR || 0}</td>
                                <td>${stats.RBI || 0}</td>
                                <td>${stats.R || 0}</td>
                                <td>${stats.SB || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>1B</th><th>2B</th><th>3B</th><th>AVG</th><th>OPS</th><th>PPG</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${singles}</td>
                                <td>${stats['2B'] || 0}</td>
                                <td>${stats['3B'] || 0}</td>
                                <td>${stats.AVG ? stats.AVG.toFixed(3) : '.000'}</td>
                                <td>${stats.OPS ? stats.OPS.toFixed(3) : '.000'}</td>
                                <td>${player.ppg ? player.ppg.toFixed(2) : '-'}</td>
                            </tr>
                        </table>`;
            } else {
                cardHTML += `
                        <table class="card-stats-table">
                            <tr>
                                <th>W</th><th>L</th><th>SV</th><th>G</th><th>GS</th><th>IP</th><th>K</th>
                            </tr>
                            <tr>
                                <td>${stats.W || 0}</td>
                                <td>${stats.L || 0}</td>
                                <td>${stats.SV || 0}</td>
                                <td>${stats.G || 0}</td>
                                <td>${stats.GS || 0}</td>
                                <td>${(stats.IP || 0).toFixed(1)}</td>
                                <td>${stats.K || stats.SO || 0}</td>
                            </tr>
                            <tr>
                                <th>BB</th><th>ER</th><th>H</th><th>ERA</th><th>WHIP</th><th>HLD</th><th>PPG</th>
                            </tr>
                            <tr>
                                <td>${stats.BB || 0}</td>
                                <td>${stats.ER || 0}</td>
                                <td>${stats.H || 0}</td>
                                <td>${stats.ERA ? stats.ERA.toFixed(2) : '0.00'}</td>
                                <td>${stats.WHIP ? stats.WHIP.toFixed(2) : '0.00'}</td>
                                <td>${stats.HLD || 0}</td>
                                <td>${player.ppg ? player.ppg.toFixed(2) : '-'}</td>
                            </tr>
                        </table>`;
            }

            cardHTML += `</div></div>`; // Close stats content and section

            // Build League History section with 2026 projection and past seasons
            const normalizedName = playerName.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const playerHistory = playerHistoryData[normalizedName];

            // Prepare history data
            const historyLogos = {};
            const historyRanks = {};

            if (playerHistory && playerHistory.seasons && playerHistory.seasons.length > 0) {
                for (const season of playerHistory.seasons) {
                    const teams = await getTeamData(season.year);
                    if (teams) {
                        const team = teams.find(t => t.team_name === season.team_name);
                        if (team) {
                            historyLogos[`${season.year}_${season.team_name}`] = team.team_logo;
                        }
                    }

                    const yearPlayers = await getPlayerStatsData(season.year);
                    if (yearPlayers) {
                        const posType = isBatter ? 'B' : 'P';
                        const sameType = yearPlayers
                            .filter(p => p.position_type === posType)
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const overallRank = sameType.findIndex(p => p.name === playerName) + 1;

                        const samePos = yearPlayers
                            .filter(p => p.eligible_positions && p.eligible_positions.includes(primaryPos))
                            .sort((a, b) => (b.fantasy_points || 0) - (a.fantasy_points || 0));
                        const posRank = samePos.findIndex(p => p.name === playerName) + 1;

                        historyRanks[season.year] = {
                            overall: overallRank > 0 ? overallRank : '-',
                            position: posRank > 0 ? `${primaryPos}${posRank}` : '-'
                        };
                    } else {
                        historyRanks[season.year] = { overall: '-', position: '-' };
                    }
                }
            }

            cardHTML += `
                    <div class="card-history-section">
                        <div class="card-history-title">📜 League History</div>
                        <table class="card-history-table">
                            <thead>
                                <tr>
                                    <th>Year</th>
                                    <th>Team</th>
                                    <th>Pts</th>
                                    <th>Rk</th>
                                    <th>Pos</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: rgba(245, 215, 66, 0.3);">
                                    <td><strong>2026</strong></td>
                                    <td><em>Projected</em></td>
                                    <td>${(player.projected_points || 0).toFixed(0)}</td>
                                    <td>${player.position_ranks ? (isBatter ? player.position_ranks['B'] : player.position_ranks['P']) || '-' : '-'}</td>
                                    <td>${positionRank}</td>
                                </tr>`;

            // Add historical seasons
            if (playerHistory && playerHistory.seasons && playerHistory.seasons.length > 0) {
                playerHistory.seasons.sort((a, b) => b.year - a.year).forEach(season => {
                    const logo = historyLogos[`${season.year}_${season.team_name}`] || '';
                    const ranks = historyRanks[season.year] || { overall: '-', position: '-' };
                    cardHTML += `
                                <tr>
                                    <td><strong>${season.year}</strong></td>
                                    <td>${logo ? `<img src="${logo}" class="team-logo-small" alt="">` : ''}${season.manager || ''}</td>
                                    <td>${(season.fantasy_points || 0).toFixed(0)}</td>
                                    <td>${ranks.overall}</td>
                                    <td>${ranks.position}</td>
                                </tr>`;
                });
            }

            cardHTML += `
                            </tbody>
                        </table>
                    </div>`;

            cardHTML += `</div>`; // Close card-scrollable

            // Footer
            cardHTML += `
                <div class="card-footer">
                    <div class="owner-info">
                        <span style="color: #666; font-style: italic;">2026 Preseason Projection</span>
                    </div>
                </div>
            </div>`; // Close baseball-card

            cardContainer.innerHTML = cardHTML;

            // Render position ranking chart
            renderPositionRankChart(player, posChartEl);

            // Render scatter chart
            scatterTitleEl.textContent = isBatter ? 'Points vs PA' : 'Points vs IP';
            renderScatterChart(player, scatterChartEl, isBatter);

            modal.classList.add('active');

            // 1. Set Card HTML
            cardContainer.innerHTML = cardHTML;

            // 2. SHOW MODAL FIRST (Fixes width calculation)
            modal.classList.add('active');
            document.body.classList.add('modal-open');

            // 3. Render Charts (Now they can see the real width)
            renderPositionRankChart(player, posChartEl);

            // Set title and render scatter
            scatterTitleEl.textContent = (player.type === 'batter') ? 'Points vs PA' : 'Points vs IP';
            renderScatterChart(player, scatterChartEl, (player.type === 'batter'));
        }

        function renderPositionRankChart(selectedPlayer, container) {
            const isBatter = selectedPlayer.type === 'batter';
            const allPlayers = isBatter ? [...allProjectionBatters] : [...allProjectionPitchers];

            // Get primary position
            const posDisplay = formatProjectionPosition(selectedPlayer.position, selectedPlayer.name);
            const primaryPos = posDisplay.split(',')[0].trim();

            // Filter players
            let positionPlayers;
            if (['LF', 'CF', 'RF', 'OF'].includes(primaryPos.toUpperCase())) {
                positionPlayers = allPlayers.filter(p => {
                    const pos = (p.position || '').toUpperCase();
                    return pos.includes('LF') || pos.includes('CF') || pos.includes('RF') || pos.includes('OF');
                });
            } else if (['SP', 'RP'].includes(primaryPos.toUpperCase())) {
                positionPlayers = allPlayers.filter(p => {
                    const pos = (p.position || '').toUpperCase();
                    return pos.includes(primaryPos.toUpperCase());
                });
            } else {
                positionPlayers = allPlayers.filter(p => {
                    const pos = (p.position || '').toUpperCase();
                    return pos.includes(primaryPos.toUpperCase());
                });
            }

            // Sort by projected points
            positionPlayers.sort((a, b) => (a.projected_points || 0) - (b.projected_points || 0));

            // LIMIT: 75 for SP, 50 for others
            const limit = primaryPos.toUpperCase() === 'SP' ? 75 : 50;
            const topPlayers = positionPlayers.slice(-limit);

            // Dimensions
            const width = container.clientWidth || 320;
            const height = 180;
            // Reduced right padding to 10 to fill box better
            const padding = { top: 15, right: 10, bottom: 25, left: 45 };

            // Y-Scale
            const minPts = Math.min(...topPlayers.map(p => p.projected_points || 0));
            const maxPts = Math.max(...topPlayers.map(p => p.projected_points || 0));
            const tickInterval = 50;
            const niceMin = Math.floor(minPts / tickInterval) * tickInterval;
            const niceMax = Math.ceil(maxPts / tickInterval) * tickInterval;
            const range = niceMax - niceMin || 1;
            const scaleY = (val) => padding.top + (height - padding.top - padding.bottom) - ((val - niceMin) / range * (height - padding.top - padding.bottom));

            // SVG setup
            let svg = `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" style="display: block;">`;

            // Draw Axis/Grid
            svg += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" class="chart-axis"/>`;
            for (let val = niceMin; val <= niceMax; val += tickInterval) {
                const y = scaleY(val);
                svg += `<line x1="${padding.left - 5}" y1="${y}" x2="${padding.left}" y2="${y}" class="chart-axis"/>`;
                svg += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" class="chart-axis-label">${val}</text>`;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="chart-grid"/>`;
            }
            svg += `<text x="12" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})" class="chart-axis-label" style="font-weight: bold;">Proj Pts</text>`;
            svg += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" class="chart-axis"/>`;

            // NEW Spacing Logic: Spread fully edge-to-edge
            const chartWidth = width - padding.left - padding.right;
            const count = topPlayers.length;
            const dotSpacing = count > 1 ? chartWidth / (count - 1) : 0;

            // Draw Dots (Background)
            topPlayers.forEach((player, i) => {
                if (player.name === selectedPlayer.name) return;
                // Use i directly to start at 0 (left) and end at width (right)
                const x = padding.left + (dotSpacing * i);
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                const isKeeper = getPlayerKeeperInfo(player.name) !== null;
                const keeperClass = isKeeper ? 'keeper-dot' : '';
                svg += `<circle cx="${x}" cy="${y}" r="5" class="chart-dot ${keeperClass}" data-name="${player.name}" data-pts="${pts}"/>`;
            });

            // Draw Selected Dot (Foreground)
            topPlayers.forEach((player, i) => {
                if (player.name !== selectedPlayer.name) return;
                const x = padding.left + (dotSpacing * i);
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                svg += `<circle cx="${x}" cy="${y}" r="8" class="chart-dot highlighted" data-name="${player.name}" data-pts="${pts}"/>`;
            });

            svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle" class="chart-axis-label" style="font-weight: bold;">${primaryPos.toUpperCase()} Rankings</text>`;
            svg += '</svg>';
            svg += `<div class="chart-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 100;"></div>`;

            container.innerHTML = svg;
            container.style.position = 'relative';

            // Tooltip listeners
            const tooltip = container.querySelector('.chart-tooltip');
            container.querySelectorAll('.chart-dot').forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const name = dot.getAttribute('data-name');
                    const pts = dot.getAttribute('data-pts');
                    tooltip.textContent = `${name}: ${pts} pts`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mousemove', (e) => {
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            });
        }

        function renderScatterChart(selectedPlayer, container, isBatter) {
            const allPlayers = isBatter ? [...allProjectionBatters] : [...allProjectionPitchers];

            const getXValue = (p) => isBatter ? (p.stats?.PA || 0) : (p.stats?.IP || 0);
            const validPlayers = allPlayers.filter(p => getXValue(p) > 0);

            // Chart dimensions
            const width = container.clientWidth || 320;
            const height = 180;
            const padding = { top: 15, right: 10, bottom: 30, left: 45 };

            const xValues = validPlayers.map(p => getXValue(p));
            const yValues = validPlayers.map(p => p.projected_points || 0);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);

            // CHANGED: Y-Axis interval set to 100
            const yTickInterval = 100;
            const niceMinY = Math.floor(minY / yTickInterval) * yTickInterval;
            const niceMaxY = Math.ceil(maxY / yTickInterval) * yTickInterval;
            const rangeY = niceMaxY - niceMinY || 1;

            // CHANGED: X-Axis now uses tight "Min to Max" range (with tiny buffer for dots)
            const xTickInterval = 100;
            const bufferX = (maxX - minX) * 0.02; // 2% buffer so dots don't get cut off
            const niceMinX = Math.floor(minX - bufferX);
            const niceMaxX = Math.ceil(maxX + bufferX);
            const rangeX = niceMaxX - niceMinX || 1;

            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            const scaleX = (val) => padding.left + ((val - niceMinX) / rangeX * chartWidth);
            const scaleY = (val) => padding.top + chartHeight - ((val - niceMinY) / rangeY * chartHeight);

            let svg = `<svg width="100%" height="${height}" viewBox="0 0 ${width} ${height}" style="display: block;">`;

            // Draw Y-Axis (Vertical)
            svg += `<line x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" class="chart-axis"/>`;

            // Draw Y-Axis Ticks & Grid (Every 100)
            for (let val = niceMinY; val <= niceMaxY; val += yTickInterval) {
                const y = scaleY(val);
                svg += `<line x1="${padding.left - 5}" y1="${y}" x2="${padding.left}" y2="${y}" class="chart-axis"/>`;
                svg += `<text x="${padding.left - 8}" y="${y + 4}" text-anchor="end" class="chart-axis-label">${val}</text>`;
                svg += `<line x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" class="chart-grid"/>`;
            }

            svg += `<text x="12" y="${height / 2}" text-anchor="middle" transform="rotate(-90, 12, ${height / 2})" class="chart-axis-label" style="font-weight: bold;">Proj Pts</text>`;

            // Draw X-Axis (Baseline)
            svg += `<line x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" class="chart-axis"/>`;

            // CHANGED: Draw X-Axis Ticks (Every 100, starting at first multiple of 100)
            const firstXTick = Math.ceil(niceMinX / xTickInterval) * xTickInterval;

            for (let val = firstXTick; val <= niceMaxX; val += xTickInterval) {
                const x = scaleX(val);
                // Ensure tick is within visible chart area
                if (x >= padding.left && x <= width - padding.right) {
                    svg += `<line x1="${x}" y1="${height - padding.bottom}" x2="${x}" y2="${height - padding.bottom + 5}" class="chart-axis"/>`;
                    svg += `<text x="${x}" y="${height - padding.bottom + 15}" text-anchor="middle" class="chart-axis-label">${Math.round(val)}</text>`;
                }
            }

            // Plot Dots
            validPlayers.forEach(player => {
                if (player.name === selectedPlayer.name) return;
                const x = scaleX(getXValue(player));
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                const xVal = isBatter ? getXValue(player) : getXValue(player).toFixed(1);
                const isKeeper = getPlayerKeeperInfo(player.name) !== null;
                const keeperClass = isKeeper ? 'keeper-dot' : '';
                svg += `<circle cx="${x}" cy="${y}" r="4" class="chart-dot ${keeperClass}" data-name="${player.name}" data-pts="${pts}" data-x="${xVal}"/>`;
            });

            // Plot Selected Player Dot (On Top)
            validPlayers.forEach(player => {
                if (player.name !== selectedPlayer.name) return;
                const x = scaleX(getXValue(player));
                const y = scaleY(player.projected_points || 0);
                const pts = (player.projected_points || 0).toFixed(1);
                const xVal = isBatter ? getXValue(player) : getXValue(player).toFixed(1);
                svg += `<circle cx="${x}" cy="${y}" r="8" class="chart-dot highlighted" data-name="${player.name}" data-pts="${pts}" data-x="${xVal}"/>`;
            });

            svg += `<text x="${width / 2}" y="${height - 3}" text-anchor="middle" class="chart-axis-label" style="font-weight: bold;">${isBatter ? 'Plate Appearances' : 'Innings Pitched'}</text>`;
            svg += '</svg>';
            svg += `<div class="chart-tooltip" style="display: none; position: absolute; background: rgba(0,0,0,0.8); color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; pointer-events: none; z-index: 100;"></div>`;

            container.innerHTML = svg;
            container.style.position = 'relative';

            // Re-attach listeners
            const tooltip = container.querySelector('.chart-tooltip');
            const xLabel = isBatter ? 'PA' : 'IP';
            container.querySelectorAll('.chart-dot').forEach(dot => {
                dot.addEventListener('mouseenter', (e) => {
                    const name = dot.getAttribute('data-name');
                    const pts = dot.getAttribute('data-pts');
                    const xVal = dot.getAttribute('data-x');
                    tooltip.textContent = `${name}: ${pts} pts, ${xVal} ${xLabel}`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mousemove', (e) => {
                    tooltip.style.left = (e.offsetX + 10) + 'px';
                    tooltip.style.top = (e.offsetY - 20) + 'px';
                });
                dot.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
            });
        }

        function closeProjectionModal() {
            document.getElementById('projection-modal').classList.remove('active');
            document.body.classList.remove('modal-open');
        }

        // Close projection modal on outside click
        document.getElementById('projection-modal')?.addEventListener('click', function (e) {
            if (e.target === this) {
                closeProjectionModal();
            }
        });

        // ===== INITIALIZE ON PAGE LOAD =====
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize season selectors (detect available seasons)
            await initializeSeasonSelectors();

            // Load current season standings by default
            loadStandingsBySeason();

            // Load manager profiles
            loadManagerProfiles();
        });
    </script>
</body>

</html>
